<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="shuyi">
<meta name="description" content="旧岁舍人如木落 新春予义再易风">
<meta name="theme-color" content="#000">
<title>EM算法 | 薅羊毛记录仪</title>
<link rel="shortcut icon" href="/favicon.ico?v=1616552344162">
<link rel="stylesheet" href="/media/css/muse.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/atom-one-light.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content="EM算法" />
  <meta name="keywords" content="机器学习" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="muse">
  <header class="header bg-color ">
    <div class="blog-header box-shadow-wrapper  " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>薅羊毛记录仪</span>
            </a>  
          
        </div>
        
          <p class="subtitle">旧岁舍人如木落 新春予义再易风</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> tags
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout muse bg-color">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper  right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body muse" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper ">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">shuyi</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">83</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">11</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">11</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
  

  



</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number no_compress"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li><a href="#%E5%BC%95%E5%85%A5em%E7%AE%97%E6%B3%95">引入EM算法</a>
<ul>
<li><a href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90">一个简单的例子</a>
<ul>
<li><a href="#1-%E5%81%87%E8%AE%BE%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%82%E6%95%B0">1. 假设我们知道所有的参数</a></li>
<li><a href="#2-%E5%81%87%E8%AE%BE%E6%88%91%E4%BB%AC%E4%B8%8D%E7%9F%A5%E9%81%93%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0">2. 假设我们不知道所有参数</a></li>
<li><a href="#3-%E9%B8%A1%E7%94%9F%E8%9B%8B%E8%9B%8B%E7%94%9F%E9%B8%A1%E9%97%AE%E9%A2%98">3. 鸡生蛋蛋生鸡问题</a></li>
<li><a href="#4-%E5%8F%96%E7%BA%A2%E7%90%83%E9%97%AE%E9%A2%98%E7%9A%84%E6%A8%A1%E6%8B%9F">4. 取红球问题的模拟</a></li>
</ul>
</li>
<li><a href="#why-em%E7%AE%97%E6%B3%95">why EM算法</a></li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9">算法内容</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B">算法的一般流程</a></li>
<li><a href="#%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B%E4%B8%8Bem%E7%AE%97%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B">高斯混合模型下EM算法的流程</a></li>
<li><a href="#k%E5%9D%87%E5%80%BC%E4%B8%8Eem%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB">K均值与EM算法的关系</a></li>
<li><a href="#%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0%E4%B8%8B%E7%95%8C%E7%9A%84%E6%8E%A8%E5%AF%BC">似然函数下界的推导</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://yangggshuyi.github.io/post/em-suan-fa/">
      EM算法
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-12-14 17:13:19">2020-12-14</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://yangggshuyi.github.io/tag/hFVVfPh4o/">
        <span>机器学习</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>9<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>2093<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
    
    
    <span id="/post/em-suan-fa/" data-flag-title="EM算法" class="meta-item pc-show leancloud_visitors">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span><span class="language" data-lan="view">浏览量</span>：<span class="leancloud-visitors-count"></span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <p><ul class="markdownIt-TOC">
<li><a href="#%E5%BC%95%E5%85%A5em%E7%AE%97%E6%B3%95">引入EM算法</a>
<ul>
<li><a href="#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90">一个简单的例子</a>
<ul>
<li><a href="#1-%E5%81%87%E8%AE%BE%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%82%E6%95%B0">1. 假设我们知道所有的参数</a></li>
<li><a href="#2-%E5%81%87%E8%AE%BE%E6%88%91%E4%BB%AC%E4%B8%8D%E7%9F%A5%E9%81%93%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0">2. 假设我们不知道所有参数</a></li>
<li><a href="#3-%E9%B8%A1%E7%94%9F%E8%9B%8B%E8%9B%8B%E7%94%9F%E9%B8%A1%E9%97%AE%E9%A2%98">3. 鸡生蛋蛋生鸡问题</a></li>
<li><a href="#4-%E5%8F%96%E7%BA%A2%E7%90%83%E9%97%AE%E9%A2%98%E7%9A%84%E6%A8%A1%E6%8B%9F">4. 取红球问题的模拟</a></li>
</ul>
</li>
<li><a href="#why-em%E7%AE%97%E6%B3%95">why EM算法</a></li>
</ul>
</li>
<li><a href="#%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9">算法内容</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B">算法的一般流程</a></li>
<li><a href="#%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B%E4%B8%8Bem%E7%AE%97%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B">高斯混合模型下EM算法的流程</a></li>
<li><a href="#k%E5%9D%87%E5%80%BC%E4%B8%8Eem%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB">K均值与EM算法的关系</a></li>
<li><a href="#%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0%E4%B8%8B%E7%95%8C%E7%9A%84%E6%8E%A8%E5%AF%BC">似然函数下界的推导</a></li>
</ul>
</li>
</ul>
</p>
<p>主要内容：隐变量、EM算法的引入、一般流程、高斯混合模型的EM算法、Kmeans与EM算法关系、EM算法的推出。首先声明，本文来源于我个人理解，可能有误欢迎纠错嗷！至于写这篇的原因，只是希望通过梳理自己学到的，或许尝试输出才知道哪里没有理解。</p>
<!-- more -->
<h1 id="引入em算法">引入EM算法</h1>
<h2 id="一个简单的例子">一个简单的例子</h2>
<p>现在有2个袋子，里面都装着红球和白球。第一步随机选择一个袋子，第二步从选出的袋子里取出一个球，记录取出的球的颜色。</p>
<h3 id="1-假设我们知道所有的参数">1. 假设我们知道所有的参数</h3>
<p>假设我们知道第一步中随机选到1号袋子的概率是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>，选到二号袋子的概率是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>−</mo><mi>π</mi></mrow><annotation encoding="application/x-tex">1-\pi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span></span></span></span>，并且我们知道每个袋子里面红球和白球的比例为：</p>
<table>
<thead>
<tr>
<th>-</th>
<th>1号袋子</th>
<th>二号袋子</th>
</tr>
</thead>
<tbody>
<tr>
<td>红球</td>
<td>p</td>
<td>1-p</td>
</tr>
<tr>
<td>白球</td>
<td>q</td>
<td>1-q</td>
</tr>
</tbody>
</table>
<p>那么我们可以根据参数计算出许多概率/条件概率，比如已知第二步取到白色球，想问它属于1号袋子的条件概率是多少？由贝叶斯公式可知：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi><mo>(</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mi>w</mi><mi>h</mi><mi>i</mi><mi>t</mi><mi>e</mi><mo>)</mo><mo>=</mo><mfrac><mrow><mi>p</mi><mo>(</mo><mi>w</mi><mi>h</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">∣</mi><mn>1</mn><mo>)</mo><mi>p</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><mrow><mi>p</mi><mo>(</mo><mi>w</mi><mi>h</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">∣</mi><mn>1</mn><mo>)</mo><mi>p</mi><mo>(</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>p</mi><mo>(</mo><mi>w</mi><mi>h</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi mathvariant="normal">∣</mi><mn>2</mn><mo>)</mo><mi>p</mi><mo>(</mo><mn>2</mn><mo>)</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">p(1 | white) = \frac{p(white|1)p(1)}{p(white|1)p(1) + p(white|2)p(2)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">1</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord">∣</span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord">∣</span><span class="mord">2</span><span class="mclose">)</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">2</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">h</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord">∣</span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h3 id="2-假设我们不知道所有参数">2. 假设我们不知道所有参数</h3>
<p>现在我们想要估计所有的参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi><mo>=</mo><mrow><mi>π</mi><mo separator="true">,</mo><mi>p</mi><mo separator="true">,</mo><mi>q</mi></mrow></mrow><annotation encoding="application/x-tex">\theta = {\pi, p, q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">p</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span></span></span>（待估、未知的），定义<strong>隐变量</strong>：表示第一步我们随机抽取的袋子是1号袋子还是2号袋子（是不可观测的），定义<strong>观测变量</strong>：表示最后我们取出的是红球还是白球（可观测的）。从极大似然估计的角度出发怎么解决呢？假设试验独立重复n次，则似然函数为:</p>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mi>i</mi></msub><mi>p</mi><mo>(</mo><msub><mi>y</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>θ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_{i} p(y_i|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span> (全概率公式展开) = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mi>i</mi></msub><msub><mi mathvariant="normal">Σ</mi><mi>z</mi></msub><mi>p</mi><mo>(</mo><msub><mi>y</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>z</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo>)</mo><mi>p</mi><mo>(</mo><mi>z</mi><mi mathvariant="normal">∣</mi><mi>θ</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\Pi_{i} \Sigma_{z} p(y_i, z | \theta) p(z|\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.04398em;">z</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span> = <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="normal">Π</mi><mi>i</mi></msub><mo>[</mo><mi>π</mi><msup><mi>p</mi><msub><mi>y</mi><mi>i</mi></msub></msup><mo>(</mo><mn>1</mn><mo>−</mo><mi>p</mi><msup><mo>)</mo><msub><mi>y</mi><mi>i</mi></msub></msup><mo>+</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>π</mi><mo>)</mo><msup><mi>q</mi><mrow><mn>1</mn><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub></mrow></msup><mo>(</mo><mn>1</mn><mo>−</mo><mi>q</mi><msup><mo>)</mo><mrow><mn>1</mn><mo>−</mo><msub><mi>y</mi><mi>i</mi></msub></mrow></msup><mo>]</mo></mrow><annotation encoding="application/x-tex">\Pi_{i} [\pi p^{y_i} (1-p)^{y_i} + (1-\pi) q^{1- y_i} (1-q)^{1- y_i} ]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord">Π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mclose">)</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></p>
<p>参数的极大似然估计值为 =  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>arg</mi><mo>⁡</mo><msub><mi>max</mi><mo>⁡</mo><mi>θ</mi></msub><msub><mi mathvariant="normal">Σ</mi><mi>i</mi></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo>(</mo><mi>p</mi><mo>(</mo><msub><mi>y</mi><mi>i</mi></msub><mi mathvariant="normal">∣</mi><mi>θ</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">\arg\max\limits_{\theta} \Sigma_{i} log(p(y_i|\theta))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.502108em;vertical-align:-0.752108em;"></span><span class="mop">ar<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.43055999999999994em;"><span style="top:-2.047892em;margin-left:0em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span><span style="top:-2.7em;"><span class="pstrut" style="height:2.7em;"></span><span><span class="mop">max</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.752108em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
<h3 id="3-鸡生蛋蛋生鸡问题">3. 鸡生蛋蛋生鸡问题</h3>
<p>针对这种包含隐变量的参数估计问题，我们想要解决的问题其实是“鸡生蛋蛋生鸡”的相互依赖问题</p>
<ul>
<li>问题一，我们想要估计参数，首先要确定每个球到底来自哪个袋子（即确定隐变量的取值）才能写出似然函数的表达式</li>
<li>问题二，隐变量是不可观测的，需要根据参数和观测变量来判断 Z 的取值概率（什么意思呢？比如1号袋子红球多而2号袋子白球多，当我们取到白球时可以认为该球来自2号袋子，或者说“Z=2号袋子”的概率更大）</li>
</ul>
<p>EM算法的求解思想认为：两个问题相互依赖，转化为一个动态求解过程。随机化给定参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span>初始值，根据参数初始值可以算出每个样本来自1号或者2号袋子的条件概率（E步），然后据此用极大似然调整参数估计值（M步），见下图所示。</p>
<figure data-type="image" tabindex="1"><img src="https://yangggshuyi.github.io/post-images/1607933419776.jpg" alt="" loading="lazy"></figure>
<p>通过不断动态迭代调整，直到满足终止条件，输出参数估计（局部最优值）</p>
<h3 id="4-取红球问题的模拟">4. 取红球问题的模拟</h3>
<p>假设取到一号袋子的概率是0.4，取到二号袋子的概率是0.6，一号袋子里红球比例为0.6，二号袋子里红球比例为0.4。</p>
<pre><code class="language-python">import numpy as np

# 初始化参数
pi = 0.8; p = 0.2; q = 0.9;n = 200
theta_true = np.array([pi, p, q])
thetas = np.array([0.8 ,0.9, 0.5])

for i in range(5):
    # 1.生成观测数据
    observed_y = []
    for _ in range(n):
        bags = np.random.binomial(1, theta_true[0])
        yi= np.random.binomial(1, theta_true[1]) if bags else np.random.binomial(1, theta_true[2])
        observed_y.append(yi)
    observed_y = np.array(observed_y)

    # E步
    ai = observed_y * (thetas[0] *  thetas[1])  / (thetas[0] *  thetas[1] + (1- thetas[0]) * thetas[2] )
    ci = observed_y * (1- thetas[0]) * thetas[2] / (thetas[0] *  thetas[1] + (1- thetas[0]) * thetas[2] )
    bi = (1 - observed_y) * (thetas[0] *  (1- thetas[1])) /  (thetas[0] * (1- thetas[1]) + (1 - thetas[0] ) * (1- thetas[2]))
    di = (1 - observed_y) * ((1 - thetas[0] ) * (1- thetas[2])) /  (thetas[0] * (1- thetas[1]) + (1 - thetas[0] ) * (1- thetas[2]))
    # M步
    pi_new = np.mean(ai + bi) 
    p_new = np.sum(ai)  / np.sum(ai + bi)
    q_new = np.sum(ci)  / np.sum(ci + di)
    thetas = np.array([pi_new, p_new, q_new])
    # print
    print(&quot;times: %d&quot; % ( i +1))
    print(&quot;π = %.3f, p = %.2f, q = %.2f&quot; 
                  % (thetas[0], thetas[1], thetas[2]))
</code></pre>
<pre><code>times: 1
π = 0.564, p = 0.43, q = 0.08
times: 2
π = 0.588, p = 0.49, q = 0.10
times: 3
π = 0.603, p = 0.53, q = 0.11
times: 4
π = 0.590, p = 0.50, q = 0.10
times: 5
π = 0.598, p = 0.52, q = 0.11
</code></pre>
<p>看起来结果不是很ok？如何验证呢，由大数定律可知应该有 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi><mi>p</mi><mo>+</mo><mo>(</mo><mn>1</mn><mo>−</mo><mi>π</mi><mo>)</mo><mi>q</mi><mo>=</mo><mfrac><mi>k</mi><mi>n</mi></mfrac></mrow><annotation encoding="application/x-tex">\pi p + (1-\pi) q = \frac{k}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>（观测数据中红球的比例）,最终只要我们的三个参数满足这一个方程就是合理的，可见解不唯一，主要原因是参数数&gt;方程的个数，当数据更高维时就不一定是这样了。</p>
<pre><code class="language-python">print(theta_true[0] * theta_true[1] + (1-theta_true[0]) * theta_true[2],  thetas[0] * thetas[1] + (1-thetas[0]) * thetas[2])
</code></pre>
<pre><code>0.3499999997 0.355
</code></pre>
<h2 id="why-em算法">why EM算法</h2>
<p>通常情况下我们对似然函数或者对数似然求偏导，然后求出偏导=0且二阶导&lt;0的极值点。然而由于隐变量的存在，我们发现这个问题复杂了起来，变成了一个非凸问题，没有全局最优解析解。</p>
<blockquote>
<p>如何求解一个非凸问题？梯度下降、EM算法等等来求出局部最优解</p>
</blockquote>
<p>梯度下降 v.s. EM算法</p>
<ul>
<li>梯度下降时是通用方法</li>
<li>EM算法 不用调参 收敛 代码简单 但只适用于部分非凸问题</li>
</ul>
<h1 id="算法内容">算法内容</h1>
<h2 id="算法的一般流程">算法的一般流程</h2>
<figure data-type="image" tabindex="2"><img src="https://yangggshuyi.github.io/post-images/1607932098398.jpg" alt="" loading="lazy"></figure>
<h2 id="高斯混合模型下em算法的流程">高斯混合模型下EM算法的流程</h2>
<p>高斯混合模型的参数估计是EM算法的一个重要应用。下面看起来很长，其实是根据EM算法一般流程进行“公式套用”哈~ 主要步骤为：</p>
<ul>
<li>写出对数似然函数</li>
<li>E步求期望，利用全概率公式，得到隐变量取值的条件概率</li>
<li>M步，带入E步的值，再极大化对数似然函数，更新参数估计值（其实就是对参数求极大似然估计）</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://yangggshuyi.github.io/post-images/1607937884554.jpg" alt="" loading="lazy"></figure>
<h2 id="k均值与em算法的关系">K均值与EM算法的关系</h2>
<ol>
<li>
<p>联系<br>
K均值算法其实利用了EM算法的思想，E步时把每个点归入某类，M步时候重新计算类中心点。</p>
</li>
<li>
<p>区别：<br>
EM算法的E步中，我们用上一次参数迭代值和观测值，求出观测样本的隐变量取值的条件概率。注意！我们不是每个点归入某个总体，而是给出它来自某个总体的概率值，这个概率值在0-1之间，这就做<strong>软分配</strong>。<br>
而 k-means 不同于此，它把每个点直接归入某类。求隐变量取值的条件概率时候，先找出某个观测点与各中心点距离最小的那一类，直接令属于这一类概率=1，其他类=0，而不是以一定概率来自某类，这就叫做<strong>硬分配</strong>。</p>
</li>
</ol>
<h2 id="似然函数下界的推导">似然函数下界的推导</h2>
<p>心塞之前看完立马忘光光，现在只能看着笔记本发愣，感觉有一步奇奇怪怪（裂开）</p>
<figure data-type="image" tabindex="4"><img src="https://yangggshuyi.github.io/post-images/1607933993802.jpg" alt="" loading="lazy"></figure>
<p>蛮奇怪的一点，就是如何理解EM算法通过提升下界，使得对数似然函数不断提升的。下面这张图或许可以说明白：</p>
<figure data-type="image" tabindex="5"><img src="https://yangggshuyi.github.io/post-images/1607933504316.jpg" alt="" loading="lazy"></figure>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      shuyi
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://yangggshuyi.github.io/post/em-suan-fa/" title="EM算法">https://yangggshuyi.github.io/post/em-suan-fa/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://yangggshuyi.github.io/tag/hFVVfPh4o/"># 机器学习</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="回家日常" href="https://yangggshuyi.github.io/post/hui-jia-ri-chang/">回家日常</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="回家日常" href="https://yangggshuyi.github.io/post/hui-jia-ri-chang/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="我算个什么" href="https://yangggshuyi.github.io/post/wo-suan-ge-shi-me/">我算个什么</a>
        <a class="nav-mobile-next" title="我算个什么" href="https://yangggshuyi.github.io/post/wo-suan-ge-shi-me/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  <script src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script>
<div id="vcomments" style="padding: 10px 0px 0px 0px"></div>

<style>
  .v .veditor {
    min-height: 10rem;
    background-image: url('');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
    background-color: rgba(255, 255, 255, 0);
    resize: none;
  }

  .v .vwrap {
    border: 1px solid #000 !important;
  }

  .v .vbtn {
    padding: .4rem 1.2rem !important;
    border-color: #fff !important;
    background-color: #49b1f5 !important;
    color: #fff !important;
    font-size: .7rem !important;
  }

  .v .vcards .vcard .vh .vmeta .vat {
    padding: 0 .8rem !important;
    border: 1px solid #00c4b6 !important;
    border-radius: 5px !important;
    color: #00c4b6 !important;
  }
</style>
<script>
  new Valine({
    el: '#vcomments',
    appId: 'YfBvVcinuBCgYHKkn2GQUctQ-gzGzoHsz',
    appKey: 'X4YcFKssCMxNzozbcYldfn4c',
    avatar: 'identicon',
    placeholder: '',
    pageSize: '',
    lang: 'zh-cn',
    enableQQ: 'true' === 'true',
    visitor: 'true' === 'true',
    highlight: 'true' === 'true',
    avatarForce: 'true' === 'false',
  });
</script>

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      学习笔记 & 日常生活
    </div>
  </footer>
  
  
  <div class="drawer-box left" id="drawer_box">
    <span class="muse-line muse-line-first"></span>
    <span class="muse-line muse-line-middle"></span>
    <span class="muse-line muse-line-last"></span>
  </div>
  
  <div class="muse back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'true'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script>
  let images = document.querySelectorAll('.section img');
  console.log(images);
  images.forEach(image => {
    var parent = image.parentElement;
    var next = image.nextElementSibling;
    parent.removeChild(image);
    var aelem = document.createElement('a');
    aelem.href = image.src;
    aelem.dataset['fancybox'] = 'images';
    aelem.dataset['rel'] = 'fancybox-button';
    aelem.classList.add('fancybox');
    aelem.appendChild(image);
    parent.insertBefore(aelem, next);
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/ji-ju-fei-hua/"" data-c="
          &lt;p&gt;面腾讯面出了恋爱的心得，以为喜欢上却开始疏远接着又接近。果然，无论是恋爱还是面试，我都表现出应接不暇，捉襟见肘。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;退步的开始&lt;/p&gt;
&lt;p&gt;自我感觉良好，是退步的开始吗？答：不一定在退步，但一定没在进步呢&lt;/p&gt;
&lt;p&gt;忘乎所以&lt;/p&gt;
&lt;p&gt;即使最高明的人也很容易自高自大：给他某些特权，他就忘乎所以，声称这些是他不可剥夺的权利；予他少许权威，他就变成暴君。给傻瓜一套制服，上面缝一两个标签，他就以为自己的话即是法律&lt;/p&gt;
&lt;p&gt;求安慰&lt;/p&gt;
&lt;p&gt;7天5面+github崩溃，可我怎么跟着一起崩溃了。每天四处求安慰，这一点好像真的很讨厌。&lt;/p&gt;
&lt;p&gt;期待&lt;/p&gt;
&lt;p&gt;靠着那些对明天的期待，畅想未来，也让我想要继续生活下去&lt;/p&gt;
">几句废话</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/teng-xun-shu-fen-mian-jing-wen-ti-hui-zong-geng-xin-zhong/"" data-c="
          &lt;p&gt;停止内耗，减少焦虑。。。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;实习项目&#34;&gt;实习&amp;amp;项目&lt;/h1&gt;
&lt;p&gt;1.监控哪些指标？&lt;/p&gt;
&lt;p&gt;2.最重要的指标是那几个？&lt;/p&gt;
&lt;p&gt;3.如何做异动指标分析？&lt;/p&gt;
&lt;p&gt;4.模型构建了哪些特征？&lt;/p&gt;
&lt;p&gt;5.最后发现哪些特征比较有意义？&lt;/p&gt;
&lt;p&gt;6.数据处理问题：类不平衡怎么处理的？欠/过采样&lt;/p&gt;
&lt;p&gt;8.为什么GBDT精度比决策树高？&lt;/p&gt;
&lt;h1 id=&#34;sql-python&#34;&gt;sql &amp;amp; python&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;on作和where有什么区别？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各种类型的join有什么区别&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;where和having有什么区别？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://yangshuyi.xyz/post/sql-li-jie-lei-mian-shi-ti/&#34;&gt;上面的回答在这里&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;不用 distinct 语法怎么实现 去重功能？&lt;/p&gt;
&lt;p&gt;group by &lt;strong&gt;补充 distinct  和 group by 在去重时的区别&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;①distinct 是把内容存储在hash结构，然后把 key 拿出来，空间换取时间 ；&lt;/p&gt;
&lt;p&gt;② group by 是分组统计，时间换取空间；&lt;/p&gt;
&lt;p&gt;③数据越离散，DISTINCT 需要消耗的空间越大，效率也就越低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式问题&lt;/p&gt;
&lt;p&gt;有了解过hadoop么？&lt;strong&gt;数据倾斜&lt;/strong&gt;时如何发生的？&lt;/p&gt;
&lt;p&gt;spark为啥比hive快？所有条件下都成立么？&lt;/p&gt;
&lt;p&gt;比较spark、hive、MySQL查询的区别&lt;/p&gt;
&lt;p&gt;分布式了解多少，做过的分布式或多线程相关的吗&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python&lt;/p&gt;
&lt;p&gt;Python里一般用什么包&lt;/p&gt;
&lt;p&gt;pandas: value_counts/duplicated/dropna/shape/apply/&lt;strong&gt;df.groupby(by = 按某列分组).agg({&amp;quot;列名&amp;quot;:&amp;quot;函数&amp;quot;})&lt;/strong&gt;/merge&lt;/p&gt;
&lt;p&gt;PyODPS: python执行sql任务读取数据&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;统计理论机器学习&#34;&gt;统计理论&amp;amp;机器学习&lt;/h1&gt;
&lt;h2 id=&#34;ab实验&#34;&gt;AB实验&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;·    1为啥用t检验？知道哪些统计学检验？
·    2如何理解p值
·    3哪些指标？服从什么分布？为什么服从？
·    4样本量怎么确定
·    5实验对照组样本怎么选择
·    6.维度爆炸怎么解决（正交/互斥）
·    7.如果实际情况和实验结果不符，为什么？
·    8.一般流程总结
·    9.实验中遇到过什么困难，怎么解决的
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Z T 卡方 F检验&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;出现样本观察结果或者更极端的概率&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指标包括 gmv 交易额 gaap 毛利额 ctr 点击率。每位用户周期内的 gmv 呈现右偏分布；原因是部分用户（比如大药店）的极端行为，如大金额订单，给实验的评价指标带来决定性的变化，所以有必要对异常用户的数据进行过滤。分布可以画直方图箱线图/看分位点/等距分箱算比例/分布检验&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显著性水平0.05，需要提升的gmv比例1% 利用区间估计里计算样本量的公式 —— 可用来计算实验周期数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户登录次序划分ABABAB...，从而分为AB两组作为实验组和对照组。注意必须保证一个用户仅处于一个组，需要处理同一用户拥有不同账号的问题（利用IP地址，设备等检测）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实验和实验之间交叉，用户同时数据多个实验，要求实验和实验之间不会相互影响，可以缩小实验周期（我的简单分流不涉及到这里）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;①分流不均衡，需要进行有效性检验 AA test/ DID ②样本量问题不足以显著  ③新奇效应，可以只看新增用户 ④试验周期选择，考虑用户活跃间隔期（连续两次购买的时间间隔），以保证实验组用户都被策略触达&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确定实验目的-关键指标和辅助指标-确定样本量-时间周期-分流-有效性检验-开展试验-异常处理-检验-分析结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;困难&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;①同一用户的不同账号问题，包括连锁店问题，这些用户之间是相互联系的，可能导致实验组和对照组不独立，并且我们不希望他们看到不同的价格，涉及到分流的处理；&lt;/li&gt;
&lt;li&gt;②试验周期的选择，按照什么周期去加总，考虑连续两次购买的时间间隔，按照周来加总；&lt;/li&gt;
&lt;li&gt;③异常用户/大金额订单的过滤；&lt;/li&gt;
&lt;li&gt;④利用DID方法减少趋势性和周期性波动影响，即用试验后的数据-试验前的数据的差值作为数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;预处理&#34;&gt;预处理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;偏态数据如何处理：变换/离散化/异常值筛选&lt;a href=&#34;https://yangshuyi.xyz/post/di-er-ci-mian-shi-zong-jie/#5-%E5%81%8F%E6%80%81&#34;&gt;之前写过&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺失值如何处理：删除/插补/离散化/random生成 &lt;a href=&#34;https://yangshuyi.xyz/post/di-er-ci-mian-shi-zong-jie/#1%E7%BC%BA%E5%A4%B1%E5%80%BC&#34;&gt;之前写过&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;机器学习&#34;&gt;机器学习&lt;/h2&gt;
&lt;p&gt;MAE 和 RMSE 作为metric的应用场景是什么？&lt;/p&gt;
&lt;p&gt;知道哪些正则化？&lt;/p&gt;
&lt;p&gt;知道哪些损失函数？&lt;/p&gt;
&lt;p&gt;K-means聚类过程&lt;/p&gt;
&lt;p&gt;随机森林的随机性体现在？&lt;/p&gt;
&lt;p&gt;SVM的核函数的定义和作用？&lt;/p&gt;
&lt;p&gt;LR回归公式的推导&lt;/p&gt;
&lt;p&gt;LDA？&lt;/p&gt;
&lt;p&gt;向量间的相似性计算方法&lt;/p&gt;
&lt;p&gt;朴素贝叶斯?&lt;/p&gt;
&lt;h1 id=&#34;业务分析&#34;&gt;业务分析&lt;/h1&gt;
&lt;h2 id=&#34;1评估某个改版&#34;&gt;1.评估某个改版&lt;/h2&gt;
&lt;p&gt;有在微信内看过公众号文章么？微信订阅号改版，文章底部有相关文章推荐，你会怎么评估？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心点：数据分析（转化率、核心指标的变动情况）+ A/B test&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、是推荐的效果。需要文章的曝光log，文章曝光后的点击log，简单计算转化率。&lt;/p&gt;
&lt;p&gt;2、是大盘阅读效果。需要有A/B test，对比无推荐/有推荐的用户，最终的阅读量是否有明显差异。需要有用户阅读文章的log。&lt;/p&gt;
&lt;h2 id=&#34;2-常见模型&#34;&gt;2. 常见模型&lt;/h2&gt;
&lt;p&gt;AARRR模型？ 获取-激活（活跃起来？）- 留存 - 转化收益 - 推荐传播&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;http://image.woshipm.com/wp-files/2021/01/DfJRcfxc4mpb0oUqJTT9.png&#34; alt=&#34;img&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-指标变动分析&#34;&gt;3. 指标变动分析&lt;/h2&gt;
&lt;p&gt;3.1 微信支付某天的支付总量同比发生5%的下降，你会怎么查找原因？&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://yangshuyi.xyz/post/ye-wu-or-zhi-biao-yi-dong-wen-ti/&#34;&gt;之前写过&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.2 文章推荐转化率高，大盘阅读量没有提升或者有提升，你觉得原因是什么？&lt;/p&gt;
&lt;p&gt;指标拆解，阅读量来自：订阅公众号点击量+朋友圈或者群聊分享点击量+推荐点击量，如果推荐的转化率高，可能是用户减少了看订阅列表和朋友圈的文章，毕竟用户日常阅读时间有限。&lt;/p&gt;
&lt;h2 id=&#34;4-费米问题&#34;&gt;4. 费米问题&lt;/h2&gt;
&lt;p&gt;如何估计白天某个小时深圳空中有多少飞机？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假设深圳一千万，每天旅客流量大概10万，假设每架飞机载客100人，则每天机场起飞降落1000架飞机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;航班时间早6-晚10点（每天16个小时），假设飞机起飞或者降落在深圳停留半小时&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;那么每个小时空中应该有 1000 * 0.5 / 16 架飞机&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://yangshuyi.xyz/post/fei-mi-wen-ti/&#34;&gt;之前写过&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-类似产品经理的app评价-分析类问题&#34;&gt;5. 类似产品经理的app评价、分析类问题&lt;/h2&gt;
&lt;p&gt;有使用过短视频么**？从哪里可以获得抖音、快手、微信视频号的数据？怎么评价3者的竞争？**&lt;/p&gt;
&lt;p&gt;常用APP？如何优化？如何看结果？&lt;/p&gt;
&lt;p&gt;如何搭建核心指标&lt;/p&gt;
&lt;h2 id=&#34;6数据分析了解-转行-书籍推荐等&#34;&gt;6.数据分析了解、转行、书籍推荐等&lt;/h2&gt;
&lt;p&gt;有看什么&lt;a href=&#34;https://www.nowcoder.com/jump/super-jump/word?word=%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90&#34;&gt;数据分析&lt;/a&gt;的书籍么？&lt;/p&gt;
&lt;p&gt;利用 python 进行数据分析 R语言可视化 ggplolt2 机器学习&lt;/p&gt;
">腾讯数分面经问题汇总（更新中）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/sql-li-kou-su-cheng-xia/"" data-c="
          &lt;p&gt;力扣 sql 中等&amp;amp;困难完成打卡 ~ 简单题还剩一些有缘再看叭😗&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;困难&#34;&gt;困难&lt;/h1&gt;
&lt;h2 id=&#34;1384按年度列出销售总额&#34;&gt;1384.按年度列出销售总额&lt;/h2&gt;
&lt;p&gt;每个产品&lt;strong&gt;每年的总销售额&lt;/strong&gt;，并包含 product_id, product_name 以及 report_year total_amount&lt;/p&gt;
&lt;p&gt;销售年份的日期介于 2018 年到 2020 年之间。你返回的结果需要按 product_id 和 report_year 排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select tmp.product_id, product_name, report_year, average_daily_sales * days as total_amount
from(
    select product_id,
    &amp;quot;2018&amp;quot; as report_year,
    average_daily_sales,
    (case when period_end &amp;gt; &amp;quot;2019-01-01&amp;quot;  
    then datediff(&amp;quot;2019-01-01&amp;quot;, period_start) 
    else datediff(period_end, period_start)+1 end) as days
from sales
where period_start&amp;lt;=&amp;quot;2018-12-31&amp;quot; 
union all
select  product_id,
     &amp;quot;2019&amp;quot; as report_year,
     average_daily_sales,
     (case when period_end&amp;gt;=&amp;quot;2020-01-01&amp;quot; and period_start&amp;lt;&amp;quot;2019-01-01&amp;quot;
     then  datediff(&amp;quot;2020-01-01&amp;quot;, &amp;quot;2019-01-01&amp;quot;) 
     when period_end&amp;gt;=&amp;quot;2020-01-01&amp;quot; and period_start&amp;gt;&amp;quot;2019-01-01&amp;quot;
     then  datediff(&amp;quot;2020-01-01&amp;quot;, period_start) 
     when period_end&amp;lt;&amp;quot;2020-01-01&amp;quot; and period_start&amp;lt;&amp;quot;2019-01-01&amp;quot;
     then  datediff(period_end, &amp;quot;2018-12-31&amp;quot;) 
     when period_end&amp;lt;&amp;quot;2020-01-01&amp;quot; and period_start&amp;gt;&amp;quot;2019-01-01&amp;quot;
     then datediff(period_end, period_start)+1
     else 0 end 
     ) as days
from sales
where period_start&amp;lt;=&amp;quot;2019-12-31&amp;quot; and period_end&amp;gt;=&amp;quot;2019-01-01&amp;quot;
union all
select  product_id,
     &amp;quot;2020&amp;quot; as report_year,
     average_daily_sales,
     (
         case when period_start&amp;lt;&amp;quot;2020-01-01&amp;quot; 
         then datediff(period_end, &amp;quot;2019-12-31&amp;quot;)
         else datediff(period_end, period_start)+1 end
     )as days
from sales
where period_end&amp;gt;=&amp;quot;2020-01-01&amp;quot; 
) tmp
left join Product
on tmp.product_id = Product.product_id
order by tmp.product_id asc, report_year asc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1412-查找成绩处于中游的学生&#34;&gt;1412. 查找成绩处于中游的学生&lt;/h2&gt;
&lt;p&gt;成绩处于中游的学生是指至少参加了一次测验, 且得分既不是最高分也不是最低分的学生。&lt;/p&gt;
&lt;p&gt;写一个 SQL 语句，找出在 所有 测验中都处于中游的学生 (student_id, student_name)。&lt;/p&gt;
&lt;p&gt;不要返回从来没有参加过测验的学生。返回结果表按照 student_id 排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;with tmp as(
    select exam_id, student_id,
    rank() over(partition by exam_id order by score asc) rk1,
    rank() over(partition by exam_id order by score desc) rk2
    from Exam
)

select distinct tmp.student_id, student_name
from tmp
left join Student
on tmp.student_id = Student.student_id
where tmp.student_id not in (
    select distinct student_id
    from tmp
    where rk1=1 or rk2=1
)
order by tmp.student_id
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1479周内每天的销售情况&#34;&gt;1479.周内每天的销售情况&lt;/h2&gt;
&lt;p&gt;报告 周内每天 每个商品类别下订购了多少单位。返回结果表单 按商品类别排序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select item_category as Category,
    sum(case when date_format(order_date,&amp;quot;%W&amp;quot;)=&amp;quot;Monday&amp;quot;then quantity else 0 end) as Monday,
    sum(case when date_format(order_date,&amp;quot;%W&amp;quot;)=&amp;quot;Tuesday&amp;quot;then quantity else 0 end) as Tuesday,
    sum(case when date_format(order_date,&amp;quot;%W&amp;quot;)=&amp;quot;Wednesday&amp;quot;then quantity else 0 end) as Wednesday,
    sum(case when date_format(order_date,&amp;quot;%W&amp;quot;)=&amp;quot;Thursday&amp;quot;then quantity else 0 end) as Thursday,
    sum(case when date_format(order_date,&amp;quot;%W&amp;quot;)=&amp;quot;Friday&amp;quot;then quantity else 0 end) as Friday,
    sum(case when date_format(order_date,&amp;quot;%W&amp;quot;)=&amp;quot;Saturday&amp;quot;then quantity else 0 end) as Saturday,
    sum(case when date_format(order_date,&amp;quot;%W&amp;quot;)=&amp;quot;Sunday&amp;quot;then quantity else 0 end) as Sunday
from Orders
right join Items
on Orders.item_id = Items.item_id
group by Category
order by Category;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;中等&#34;&gt;中等&lt;/h1&gt;
&lt;h2 id=&#34;1440-计算布尔表达式的值&#34;&gt;1440. 计算布尔表达式的值&lt;/h2&gt;
&lt;p&gt;以计算表 &lt;code&gt;Expressions&lt;/code&gt; 中的布尔表达式.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.*, 
    if((case 
            when operator = &amp;quot;&amp;gt;&amp;quot; then t2.value&amp;gt;t3.value
            when operator = &amp;quot;&amp;lt;&amp;quot; then t2.value&amp;lt;t3.value
        else t2.value=t3.value end) = 1,&amp;quot;true&amp;quot;, &amp;quot;false&amp;quot;) as value
from Expressions t1
left join `Variables` t2 on t1.left_operand = t2.`name`
left join `Variables` t3 on t1.right_operand = t3.`name`
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1454至少连续-5-天登录的用户名&#34;&gt;1454.至少连续 5 天登录的用户名&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select  distinct t2.id, t3.name
from
(
    select id, login_date,
        date_sub(login_date, interval(row_number() over(partition by id order by login_date asc)) day) as date_rn
    from (
        select distinct id, login_date
        from Logins
    ) t1
) t2
left join Accounts t3 on t2.id = t3.id
group by t2.id, date_rn
having count(login_date)&amp;gt;=5
order by t2.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1459-矩形面积&#34;&gt;1459. 矩形面积&lt;/h2&gt;
&lt;p&gt;由表中任意两点可以形成的&lt;strong&gt;所有可能的矩形&lt;/strong&gt;（仅考虑边与 x 轴和 y 轴平行的情况）。&lt;/p&gt;
&lt;p&gt;结果表中的每一行包含三列 (p1, p2, area) 如下:&lt;/p&gt;
&lt;p&gt;p1 和 p2 是&lt;strong&gt;矩形两个对角的点的 id&lt;/strong&gt; 且 &lt;strong&gt;p1 &amp;lt; p2&lt;/strong&gt;&lt;br&gt;
矩形的面积由列 area 表示&lt;br&gt;
请按照面积大小降序排列，如果面积相同的话, 则按照 p1 和 p2 升序对结果表排序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.id as p1, t2.id as p2, abs(t1.x_value-t2.x_value) * abs(t1.y_value-t2.y_value)  as area
from points t1, points t2
where t1.id&amp;lt;t2.id
and  t1.x_value-t2.x_value&amp;lt;&amp;gt;0 
and  t1.y_value-t2.y_value&amp;lt;&amp;gt;0
order by area desc, p1 asc, p2 asc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1501可以放心投资的国家&#34;&gt;1501.可以放心投资的国家&lt;/h2&gt;
&lt;p&gt;想要投资的国家是: 该国的平均通话时长要严格地大于全球平均通话时长.&lt;/p&gt;
&lt;h3 id=&#34;回忆-字符串处理部分函数&#34;&gt;回忆: 字符串处理部分函数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select length(&#39;ysy&#39;),
		upper(&#39;ysy&#39;),lower(&#39;YSy&#39;),

    # 截取 切片(py) / substr(r)
    left(&#39;Kindergarten&#39;, 4),   # 前4个
    right(&#39;Kindergarten&#39;, 6),  # 后6个
    substring(&#39;Kindergarten&#39;, 3, 2),   # 从第3个（起始位置）往后的2个字母
    
    # 替换 replace(py) / gsub(r)
    replace(&#39;Kindergarten&#39;, &#39;garten&#39;,&#39;garden&#39;),
    
    # 连接 +(py) / paste (r)
    concat(&#39;aa&#39;,&#39;+&#39;,&#39;bb&#39;)   # 输出aa+bb
;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-mysql&#34;&gt;select distinct Country.`name` as country
from Calls
left join person
on (Calls.caller_id = Person.id or Calls.callee_id = Person.id)
left join Country on Country.country_code = left(person.phone_number,3)
group by left(phone_number,3)
having avg(duration)&amp;gt;(
    select avg(duration)
    from Calls
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1555银行账户概要&#34;&gt;1555.银行账户概要&lt;/h2&gt;
&lt;p&gt;查询每个用户的当前余额，并检查他们是否已透支（当前额度小于 0）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 
    t3.user_id, 
    user_name, credit1 + sum(ifnull(t4.amount,0)) as credit,
    if(credit1 + sum(ifnull(t4.amount,0))&amp;lt;0,&amp;quot;Yes&amp;quot;,&amp;quot;No&amp;quot;) as credit_limit_breached
from
(
    select t1.user_id, t1.user_name, 
        t1.credit - sum(ifnull(t2.amount,0)) as credit1
    from users t1
    left join transactions t2 on t1.user_id = t2.paid_by
    group by t1.user_id
) t3
left join transactions t4 
on t3.user_id = t4.paid_to
group by t3.user_id
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1613-找到遗失的id递归需复习&#34;&gt;1613. 找到遗失的ID——递归（需复习）&lt;/h2&gt;
&lt;p&gt;遗失的顾客id是指那些不在 Customers 表中, 值却处于 1 和表中最大 customer_id 之间的id.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 递归生成1到100
with recursive t1 as 
(
    select 1 as n
    union all 
    select n+1 from t1 where n &amp;lt; 100)
-- 按照条件筛选
select n as ids
from t1
where n &amp;gt;=1
and n &amp;lt;= (
    select max(customer_id)
    from Customers
)
and n not in (
    select distinct customer_id
    from Customers
)
order by ids
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1709-访问日期之间的最大空档期&#34;&gt;1709. 访问日期之间的最大空档期&lt;/h2&gt;
&lt;p&gt;假设今天的日期是 &#39;2021-1-1&#39; 。编写 SQL 语句，对于每个 user_id ，求出相邻访问（若该次访问是最后一次，则为今天【这里暗示要 left join 】）之间&lt;strong&gt;最大的空档期天数&lt;/strong&gt; window 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;with tmp as(
    select user_id, visit_date, 
        row_number() over(partition by user_id order by visit_date asc) as rn
    from UserVisits
)

select t1.user_id as user_id,
    max(datediff(ifnull(t2.visit_date,&amp;quot;2021-01-01&amp;quot;), t1.visit_date)) as biggest_window
from tmp t1
left join tmp t2
on t1.user_id = t2.user_id
and t1.visit_date&amp;lt;t2.visit_date
and t1.rn+1 = t2.rn
group by t1.user_id
order by user_id;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;中等且无聊&#34;&gt;中等且无聊&lt;/h1&gt;
&lt;p&gt;前面的感觉还不错，后面的是无聊的中等题：&lt;/p&gt;
&lt;h2 id=&#34;1468-税后工资&#34;&gt;1468. 税后工资&lt;/h2&gt;
&lt;p&gt;如果这个公司所有员工最高工资不到 1000 ，税率为 0%&lt;br&gt;
如果这个公司所有员工最高工资在 1000 到 10000 之间，税率为 24%&lt;br&gt;
如果这个公司所有员工最高工资大于 10000 ，税率为 49%&lt;br&gt;
按任意顺序返回结果，税后工资结果取整&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.company_id,employee_id, employee_name, round(salary*ratio,0) as salary
from Salaries t1
left join 
(
    select company_id,
        (case 
        when max(salary)&amp;lt;1000 then 1
        when max(salary) between 1000 and 10000 then 1-0.24
        when max(salary) &amp;gt; 10000 then 1-0.49
    else null end) as ratio
    from salaries
    group by company_id
) t2
on t1.company_id  = t2.company_id;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1532最近的三笔订单&#34;&gt;1532.最近的三笔订单&lt;/h2&gt;
&lt;p&gt;找到每个用户的最近三笔订单。如果用户的订单少于 3 笔，则返回他的全部订单。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select Customers.`name` as customer_name, t1.customer_id as customer_id, order_id, order_date
from
(
    select customer_id,  order_id, order_date, 
        row_number()over(partition by customer_id order by order_date desc) as rk
    from orders
) t1
left join Customers
on t1.customer_id = Customers.customer_id
where rk&amp;lt;=3
order by customer_name asc, customer_id asc, order_date desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1596-顾客最经常订购的商品&#34;&gt;1596. 顾客最经常订购的商品&lt;/h2&gt;
&lt;p&gt;找到每一个顾客最经常订购的商品（可能不止一种）。表单应该有每一位至少下过一次单的顾客 customer_id , 他最经常订购的商品的 product_id 和 product_name&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.customer_id, t1.product_id, t2.product_name
from
(
    select customer_id, product_id, count(order_id), 
        rank() over (partition by customer_id order by count(order_id) desc) as rk
    from orders
    group by customer_id, product_id
) t1
left join Products t2 on t1.product_id = t2.product_id
where rk = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;&#34;&gt;&lt;/h2&gt;
&lt;h2 id=&#34;1715-苹果和橘子的个数&#34;&gt;1715. 苹果和橘子的个数&lt;/h2&gt;
&lt;p&gt;查询每个大箱子中苹果和橘子的个数。如果大箱子中包含小盒子，还应当包含小盒子中苹果和橘子的个数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select sum(ifnull(boxes.apple_count,0))+sum(ifnull(chests.apple_count,0)) as apple_count,
    sum(ifnull(boxes.orange_count,0))+sum(ifnull(chests.orange_count,0)) as orange_count
from boxes 
left join chests
on boxes.chest_id = chests.chest_id
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1699两人的通话次数&#34;&gt;1699.两人的通话次数&lt;/h2&gt;
&lt;p&gt;查询每一对用户 &lt;code&gt;(person1, person2)&lt;/code&gt; 之间的通话次数和通话总时长，其中 &lt;code&gt;person1 &amp;lt; person2&lt;/code&gt; 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select person1, person2, count(1) as call_count, sum(duration) as total_duration
from (
    select 
        if(from_id&amp;lt;to_id, from_id, to_id) as person1,
        if(from_id&amp;lt;to_id, to_id, from_id) as person2,
        duration
    from Calls
) tmp 
group by person1, person2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1549-每件商品的最新订单&#34;&gt;1549. 每件商品的最新订单&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT product_name, t.product_id, order_id, order_date
FROM(
    SELECT *, rank() OVER(PARTITION BY product_id ORDER BY order_date DESC) AS rk 
    FROM Orders
) t LEFT JOIN Products p USING(product_id)
WHERE rk = 1
ORDER BY product_name, product_id, order_id
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1445-苹果-和-桔子&#34;&gt;1445. &lt;strong&gt;苹果&lt;/strong&gt; 和 桔子&lt;/h2&gt;
&lt;p&gt;报告每一天 &lt;strong&gt;苹果&lt;/strong&gt; 和 &lt;strong&gt;桔子&lt;/strong&gt; 销售的数目的差异.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select sale_date, 
    sum(case when fruit=&amp;quot;apples&amp;quot; then sold_num else 0 end) - sum(case when fruit=&amp;quot;oranges&amp;quot; then sold_num else 0 end) as diff
from Sales
group by sale_date
order by sale_date
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1398购买了-a-b-却没有买-c&#34;&gt;1398.购买了 A  B 却没有买 C&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;SELECT customer_id,customer_name 
FROM Customers 
WHERE 
customer_id IN(SELECT customer_id FROM Orders WHERE product_name=&#39;A&#39;) 
AND 
customer_id IN(SELECT customer_id FROM Orders WHERE product_name=&#39;B&#39;) 
AND 
customer_id NOT IN(SELECT customer_id FROM Orders WHERE product_name=&#39;C&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1393-股票损益&#34;&gt;1393. 股票损益&lt;/h2&gt;
&lt;p&gt;编写一个SQL查询来报告每支股票的资本损益。&lt;/p&gt;
&lt;p&gt;股票的资本损益是一次或多次买卖股票后的全部收益或损失。&lt;/p&gt;
&lt;p&gt;以任意顺序返回结果即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;with tmp as(
  select stock_name, operation, price,
		row_number()over(partition by stock_name order by operation_day) as rn
	from stocks
)
select t1.stock_name, sum(t2.price - t1.price) as capital_gain_loss
from tmp t1, tmp t2
where t1.stock_name = t2.stock_name
and t1.operation = &amp;quot;buy&amp;quot; 
and t2.operation = &amp;quot;sell&amp;quot;
and t1.rn+1 = t2.rn
group by t1.stock_name
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1421净现值查询&#34;&gt;1421.净现值查询&lt;/h2&gt;
&lt;p&gt;找到 Queries 表中每一次查询的净现值.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select q.id,q.year,ifnull(n.npv,0) npv 
from queries q left join npv n
on q.id=n.id and q.year=n.year
&lt;/code&gt;&lt;/pre&gt;
">sql 力扣速成（下）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/sql-li-kou-su-cheng-shang/"" data-c="
          &lt;p&gt;任务完成了但也真学到恶心了，难过🙃&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1615860345036.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;!-- more --&gt;
&lt;p&gt;附近日感受：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;觉得某人直男/直女癌/无法交流/不能理解的时候，其实对方有和他顺利交流的人，只不过不是你/没把你当他朋友/懒得考虑你/讨厌你罢了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;心里上放松和行动上认真有可能兼备&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是遇到的中等&amp;amp;困难题：&lt;/p&gt;
&lt;h1 id=&#34;262-行程和用户-需复习&#34;&gt;262. 行程和用户 （需复习）&lt;/h1&gt;
&lt;p&gt;写一段 SQL 语句查出 &amp;quot;2013-10-01&amp;quot; 至 &amp;quot;2013-10-03&amp;quot; 期间&lt;strong&gt;非禁止用户&lt;/strong&gt;（乘客和司机都必须未被禁止）的取消率。取消率的计算方式如下：&lt;strong&gt;(被司机或乘客取消的非禁止用户生成的订单数量) / (非禁止用户生成的订单总数)&lt;/strong&gt;。返回结果表中的数据可以按任意顺序组织。其中取消率 Cancellation Rate 需要四舍五入保留 两位小数 。&lt;/p&gt;
&lt;p&gt;注意乘客和司机都必须未被禁止，这里  Users.Banned = &amp;quot;no&amp;quot; 相当于处理了乘客或者司机未被禁止。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 错误解答
select trips.request_at as 日期, 
	count(distinct (case when Status in (&amp;quot;cancelled_by_driver&amp;quot;, &amp;quot;cancelled_by_client&amp;quot;) then trips.id else full end))/count(distinct trips.id) as 当日取消率
from Trips 
left join Users 
on (trips.Client_Id  = Users.Users_Id or trips.Driver_Id  = Users.Users_Id)
and Users.Banned = &amp;quot;no&amp;quot;
group by trips.request_at;

-- 正确解答：
-- 方法一需要两次join；方法二对cliend_id和driver_id都做剔除
select Request_at as `Day`, 
    round(count(distinct (case when Status in (&amp;quot;cancelled_by_driver&amp;quot;, &amp;quot;cancelled_by_client&amp;quot;) then t1.id else null end)) / count(distinct t1.id),2) as `Cancellation Rate`
from trips t1
inner join Users t2 on t1.Client_Id = t2.users_id
inner join users t3 on t1.driver_id = t3.users_id
and t1.Request_at between &amp;quot;2013-10-01&amp;quot; and &amp;quot;2013-10-03&amp;quot;
and t2.banned = &amp;quot;No&amp;quot; and t3.banned = &amp;quot;No&amp;quot; 
group by t1.Request_at;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;534游戏玩法分析&#34;&gt;534.游戏玩法分析&lt;/h1&gt;
&lt;p&gt;编写一个 SQL 查询，同时报告每组玩家和日期，以及玩家在此日期之前玩家所玩的游戏总数。&lt;/p&gt;
&lt;p&gt;-- 累计求和问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select player_id, event_date,
	sum(games_played) over(partition by player_id order by event_date asc) as games_played_so_far
from Activity
order by player_id asc, event_date asc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;550游戏玩法分析&#34;&gt;550.游戏玩法分析&lt;/h1&gt;
&lt;p&gt;编写一个 SQL 查询，报告在首次登录的&lt;strong&gt;第二天再次登录&lt;/strong&gt;的玩家的比率，四舍五入到小数点后两位。换句话说，您需要计算从首次登录日期开始至少连续两天登录的玩家的数量，然后除以玩家总数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select round(count(distinct t2.player_id) / count(distinct t1.player_id), 2) as fraction
from (
  select player_id, min(event_date) as event_date
  from Activity
  group by player_id
) t1
left join 
(
  select distinct player_id,event_date -- 习惯先去重
  from Activity
  group by player_id,event_date
)t2
on t1.player_id = t2.player_id
and datediff(t2.event_date, t1.event_date) = 1  -- t2-t1=1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;569-员工薪水中位数&#34;&gt;569. 员工薪水中位数&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Employee&lt;/code&gt; 表有三列：员工Id，公司名和薪水。请编写SQL查询来查找每个公司的薪水中位数。挑战点：你是否可以在不使用任何内置的SQL函数的情况下解决此问题。&lt;/p&gt;
&lt;p&gt;N 奇数：n+1/2，偶数 n/2 n/2+1 ——对所有n/2到n/2+1的数字求平均即可（实际这道题不需要求avg）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.company, avg(salary)
from(
  select company, salary, row_number() over (partition by company order by salary asc) as rk
	from employee
)t1
left join 
(
  select company, count(id) as num
	from employee
 	group by company
)t2
on t1.company = t2.company
where t1.rk between t2.num/2 and (t2.num/2 +1)
group by t1.company;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;570至少有5名直接下属的经理&#34;&gt;570.至少有5名直接下属的经理&lt;/h1&gt;
&lt;p&gt;给定 &lt;code&gt;Employee&lt;/code&gt; 表，请编写一个SQL查询来查找至少有5名直接下属的经理。对于上表，您的SQL查询应该返回：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select `name`
from(
  select t1.id as id, t1.`name` as `name`, count(distinct t2.id) as num
  from Employee t1
  left join Employee t2
  on t1.id = t2.ManagerId
  group by t1.id,t1.`name`
) tmp
where num&amp;gt;=5;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;571给定数字的频率查询中位数-需复习&#34;&gt;571.给定数字的频率查询中位数 （需复习）&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Numbers&lt;/code&gt; 表保存数字的值及其频率，请编写一个查询来查找所有数字的中位数并将结果命名为 &lt;code&gt;median&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当某一数字的 &lt;strong&gt;正序和逆序累计&lt;/strong&gt; 均大于 &lt;strong&gt;整个序列的数字个数的一半&lt;/strong&gt; 时即为中位数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select avg(number) as median
from (
  select number, 
    sum(frequency) over(order by number asc) as freq1,
    sum(frequency) over(order by number desc) as freq2
  from numbers
) t1,
(
  select sum(frequency)*0.5 as num
	from numbers
)  t2
where freq1&amp;gt;= num and freq2&amp;gt;= num ;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;574当选者&#34;&gt;574.当选者&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select Name from Candidate
where id = (
    select CandidateId from Vote
    group by CandidateId
    order by count(id) desc
    limit 1
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;578查询回答率最高的问题&#34;&gt;578.查询回答率最高的问题&lt;/h1&gt;
&lt;p&gt;回答率：回答数占显示数的比例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select question_id as survey_log
from(
    select question_id,
        count(case when action = &#39;answer&#39; then question_id else null end) / count(case when action = &#39;show&#39; then question_id else null end)  as 回答率
    from survey_log
    group by question_id
    order by 回答率 desc
    limit 1
) tmp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;579查询员工的累计薪水&#34;&gt;579.查询员工的累计薪水&lt;/h1&gt;
&lt;p&gt;请你编写 SQL 语句，对于每个员工，查询他除最近一个月（即最大月）之外，剩下每个月的近三个月的累计薪水（不足三个月也要计算）。&lt;/p&gt;
&lt;p&gt;结果请按 Id 升序，然后按 Month 降序显示。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select id, `month`, salary
from
(
  select t1.id,
		t2.`month`, 
  	sum(case when t1.`month` &amp;gt; t2.`month`-3 and t1.`month` &amp;lt;= t2.`month` then t1.salary else 0 end) as salary,
  	row_number() over(partition by t1.id order by t2.`month` desc) as rk
  from Employee t1
  left join  Employee t2
  on t1.id = t2.id 
  group by t1.id, t2.`month`
) tmp
where rk &amp;gt; 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;580-统计专业学生人数&#34;&gt;580. 统计专业学生人数&lt;/h1&gt;
&lt;p&gt;写一个查询语句，查询 &lt;em&gt;&lt;strong&gt;department&lt;/strong&gt;&lt;/em&gt; 表中每个专业的学生人数 （即使没有学生的专业也需列出）。查询结果按照学生人数降序排列。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.dept_name,
	(case when t2.num is null then 0 else t2.num end) as student_number
from department t1
left join 
(
  select dept_id, count(student_id) as num
  from student
  group by dept_id
) t2
on t1.dept_id = t2.dept_id
order by num desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;585-投资金额&#34;&gt;585. 投资金额&lt;/h1&gt;
&lt;p&gt;写一个查询语句，将 2016 年 (TIV_2016) 所有成功投资的金额加起来，保留 2 位小数。&lt;/p&gt;
&lt;p&gt;1.他在 2015 年的投保额 (TIV_2015) 至少跟一个其他投保人在 2015 年的投保额相同。2.他所在的城市必须与其他投保人都不同（也就是说维度和经度不能跟其他任何一个投保人完全相同）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;concat&lt;/strong&gt;(a,b) ，同时匹配经纬度更合理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select sum(TIV_2016) as TIV_2016
from insurance
where concat(lat,lon) in (
    select concat(lat,lon)
    from insurance
    group by concat(lat,lon)
    having count(pid)=1 
)
and TIV_2015 in (
    select distinct TIV_2015
    from insurance
    group by TIV_2015
    having count(pid)&amp;gt;1
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;601-体育馆的人流量&#34;&gt;601. 体育馆的人流量&lt;/h1&gt;
&lt;p&gt;编写一个 SQL 查询以找出每行的人数大于或等于 &lt;code&gt;100&lt;/code&gt; 且 &lt;code&gt;id&lt;/code&gt; 连续的三行或更多行记录。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.*
from Stadium t1
,
(
    select id as start_id, id+count(rk)-1 as end_id
    from(
        select row_number()over(order by visit_date asc) as rk, visit_date,id
        from Stadium
        where people&amp;gt;=100
    ) tmp
    group by id-rk
    having count(rk)&amp;gt;=3
) t2
where  (t1.id&amp;gt;=t2.start_id and  t1.id&amp;lt;=t2.end_id)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;602好友申请&#34;&gt;602.好友申请&lt;/h1&gt;
&lt;p&gt;表 &lt;code&gt;request_accepted&lt;/code&gt; 存储了所有好友申请通过的数据记录。写一个查询语句，求出谁拥有最多的好友和他拥有的好友数目。好友申请只会被接受一次，所以不会有 requester_id 和 accepter_id 值都相同的重复记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Union all 不合并重复行&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select id, sum(friend) as num
from
(
    select requester_id as id, count(requester_id) as friend
    from request_accepted
    group by requester_id
    union all
    select accepter_id as id, count(accepter_id) as friend
    from request_accepted
    group by accepter_id
) tmp
group by id
order by num desc
limit 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;608树节点&#34;&gt;608.树节点&lt;/h1&gt;
&lt;p&gt;给定一个表 &lt;code&gt;tree&lt;/code&gt;，id 是树节点的编号， p_id 是它父节点的 id 。树中每个节点属于以下三种类型之一：叶、根、内部节点。写一个查询语句，输出所有节点的编号和节点的类型，并将结果按照节点编号排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select distinct t1.id,
	(case 
   	when t2.id is null and t1.p_id is not null then &amp;quot;Leaf&amp;quot;
  	when t1.p_id is null then &amp;quot;Root&amp;quot;
  else &amp;quot;Inner&amp;quot; end) as `Type`
from tree t1
left join tree t2
on t2.p_id = t1.id;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;612平面上的最近距离&#34;&gt;612.平面上的最近距离&lt;/h1&gt;
&lt;p&gt;表 &lt;code&gt;point_2d&lt;/code&gt; 保存了所有点（多于 2 个点）的坐标 (x,y) ，这些点在平面上两两不重合。&lt;/p&gt;
&lt;p&gt;写一个查询语句找到两点之间的最近距离，保留 2 位小数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select round(sqrt(min(dist)),2) as shortest
from  
(
  select distinct (t1.x-t2.x)*(t1.x-t2.x)+(t1.y-t2.y)*(t1.y-t2.y) as dist
  from point_2d t1, point_2d t2
) tmp
where dist&amp;gt;0;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;614二级关注者&#34;&gt;614.二级关注者&lt;/h1&gt;
&lt;p&gt;表 &lt;code&gt;follow&lt;/code&gt; 会有 2 个字段： followee，follower。对每一个关注者，查询关注他的关注者的数目&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.follower, count(distinct t2.follower) as num
from follow t1
left join follow t2
on t1.follower = t2.followee
group by t1.follower
having count(distinct t2.follower) &amp;gt;0;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;615平均工资部门与公司比较&#34;&gt;615.平均工资：部门与公司比较&lt;/h1&gt;
&lt;p&gt;在每一个工资发放日，部门平均工资与公司平均工资的比较结果 （高 / 低 / 相同）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select a.pay_month, department_id,
    (case when avg_dep&amp;gt;avg_comp then &amp;quot;higher&amp;quot;
        when avg_dep=avg_comp then &amp;quot;same&amp;quot;
        else &amp;quot;lower&amp;quot; 
    end) as comparison
from
(
  select date_format(t1.pay_date, &amp;quot;%Y-%m&amp;quot;) as pay_month, t2.department_id, avg(t1.amount) as avg_dep
  from salary t1
  inner join employee t2
  on t1.employee_id = t2.employee_id
  group by date_format(t1.pay_date,&amp;quot;%Y-%m&amp;quot;), t2.department_id
) a
,
(
  select date_format(pay_date,&amp;quot;%Y-%m&amp;quot;) as pay_month, avg(amount) as avg_comp
  from salary 
  group by date_format(pay_date,&amp;quot;%Y-%m&amp;quot;) 
) b
where a.pay_month = b.pay_month;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;618学生地理信息报告需复习&#34;&gt;618.学生地理信息报告（需复习）&lt;/h1&gt;
&lt;p&gt;长表变宽表，实现列的透视表操作，使得每个学生按照姓名的字母顺序依次排列在对应的大洲下面。输出的标题应依次为美洲（America）、亚洲（Asia）和欧洲（Europe）:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;America&lt;/th&gt;
&lt;th&gt;Asia&lt;/th&gt;
&lt;th&gt;Europe&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Jack&lt;/td&gt;
&lt;td&gt;Xi&lt;/td&gt;
&lt;td&gt;Pascal&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Jane&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 错误解答
with tmp as(
select `name`, continent,
    row_number()over(partition by continent order by `name`) as rk
from student
)
select t1.name,t2.name,t3.name
from tmp t1, tmp t2, tmp t3
where t1.rk = t2.rk and t2.rk = t3.rk
and t1.continent = &amp;quot;America&amp;quot; 
and t2.continent = &amp;quot;Asia&amp;quot; 
and t3.continent = &amp;quot;Europe&amp;quot;;


-- 正确解答(max函数可以从null和非null中取出非Null)
SELECT
    MAX(IF(continent = &#39;America&#39;, name, NULL)) America,
    MAX(IF(continent = &#39;Asia&#39;, name, NULL)) Asia,
    MAX(IF(continent = &#39;Europe&#39;, name, NULL)) Europe
FROM 
(
  select `name`, continent,
  	row_number()over(partition by continent order by `name`) as rk
	from student
) tmp
GROUP BY rk;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;626换座位&#34;&gt;626.换座位&lt;/h1&gt;
&lt;p&gt;纵列的 &lt;strong&gt;id&lt;/strong&gt; 是连续递增的，想改变相邻俩学生的座位。即12交换 34交换。。。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select id,
    (case  
        when (id = max_id and id%2=1) then student
        when (id &amp;lt; max_id and id%2=1) then next_anme
        else last_name
    end) as student
from
(
    select id,student,
        lead(student)over(order by id) next_anme,
        lag(student)over(order by id) last_name
    from seat
) t1
,
(
    select max(id) as max_id
    from seat
) t2;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1045买下所有产品的客户&#34;&gt;1045.买下所有产品的客户&lt;/h1&gt;
&lt;p&gt;从 &lt;code&gt;Customer&lt;/code&gt; 表中查询购买了 &lt;code&gt;Product&lt;/code&gt; 表中所有产品的客户的 id。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select distinct customer_id
from(
  select customer_id, count(distinct Product_key) as type_num
  from Customer
  group by customer_id
) tmp
where type_num = (
  select count(distinct Product_key)
	from Product
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1070产品销售分析&#34;&gt;1070.产品销售分析&lt;/h1&gt;
&lt;p&gt;选出每个销售产品的 &lt;strong&gt;第一年&lt;/strong&gt; 的 &lt;strong&gt;产品 id&lt;/strong&gt;、&lt;strong&gt;年份&lt;/strong&gt;、&lt;strong&gt;数量&lt;/strong&gt; 和 &lt;strong&gt;价格&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select product_id, 
    year as first_year,
    quantity, 
    price
from sales
where (product_id, year) in (
  select product_id, min(year)
  from sales
  group by product_id
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1084销售分析&#34;&gt;1084.销售分析&lt;/h1&gt;
&lt;p&gt;报告&lt;strong&gt;仅&lt;/strong&gt;在&lt;strong&gt;2019-01-01&lt;/strong&gt;至&lt;strong&gt;2019-03-31&lt;/strong&gt;（含）之间出售的商品。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select product_id, product_name
from product
where product_id not in (
    select distinct product_id
    from sales
    where (sale_date&amp;gt;&amp;quot;2019-03-31&amp;quot; or sale_date&amp;lt;&amp;quot;2019-01-01&amp;quot;)
)
and product_id in (
    select distinct product_id
    from sales
    where (sale_date &amp;lt;=&amp;quot;2019-03-31&amp;quot; and sale_date&amp;gt;=&amp;quot;2019-01-01&amp;quot;)
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1097游戏玩法分析首登留存率&#34;&gt;1097.游戏玩法分析——首登留存率&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.event_date as install_dt,
    count(distinct t1.player_id) as installs, 
    round(count(distinct t2.player_id) / count(distinct t1.player_id),2) as Day1_retention
from (
  select player_id, min(event_date) as event_date
  from Activity
  group by player_id
) t1-- 第一天登录
left join Activity t2 
on t1.player_id = t2.player_id
and datediff(t2.event_date, t1.event_date)=1
group by t1.event_date
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里记得考虑使用on and而不是where&lt;/p&gt;
&lt;h1 id=&#34;1098小众书籍&#34;&gt;1098.小众书籍&lt;/h1&gt;
&lt;p&gt;筛选出过去一年中订单总量少于10本的书籍 。注意：不考虑 上架（available from）距今 不满一个月 的书籍。并且 假设今天是 2019-06-23 。&lt;/p&gt;
&lt;p&gt;date_SUB(&amp;quot;2019-06-23&amp;quot;, INTERVAL 365 DAY) = &amp;quot;2018-06-23&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.book_id,
    t1.name
    -- , (case when t2.订单总量 is null then 0 else t2.订单总量 end ) as 订单总量
from 
(
    select book_id, name
    from books
    where available_from &amp;lt;= date_sub(&amp;quot;2019-06-23&amp;quot;, INTERVAL 1 month)
) t1
left join
(
    select book_id, sum(quantity) as &amp;quot;订单总量&amp;quot;
    from Orders
    where dispatch_date &amp;gt;= date_sub(&amp;quot;2019-06-23&amp;quot;, INTERVAL 365 DAY)  
    and dispatch_date &amp;lt;= &amp;quot;2019-06-23&amp;quot;
    group by book_id
) t2
on t1.book_id = t2.book_id
where (t2.订单总量 is null or t2.订单总量&amp;lt;10)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一定注意 on 和 where 的区别！&lt;/p&gt;
&lt;h1 id=&#34;1107每日新用户统计&#34;&gt;1107.每日新用户统计&lt;/h1&gt;
&lt;p&gt;从今天起最多 90 天内，每个日期该日期首次登录的用户数，今天是 &lt;strong&gt;2019-06-30&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select first_login as login_date,
	count(distinct user_id) as user_count
from
(
  select user_id, min(activity_date) as first_login
  from traffic
  where activity = &amp;quot;login&amp;quot;
  group by user_id
) tmp
where first_login&amp;lt;=&amp;quot;2019-06-30&amp;quot; 
and first_login &amp;gt;= date_sub(&amp;quot;2019-06-30&amp;quot;,interval 90 day)
group by first_login;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1126-查询活跃业务&#34;&gt;1126. 查询活跃业务&lt;/h1&gt;
&lt;p&gt;如果一个业务的某个事件类型的发生次数&lt;strong&gt;大于&lt;/strong&gt;此事件类型在所有业务中的平均发生次数，并且该业务至少有两个这样的事件类型，那么该业务就可被看做是活跃业务。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select business_id
    -- , count(distinct(case when occurences &amp;gt; avg_occr then events.event_type else null end)) 
from events
left join
(
    select event_type, avg(occurences) as avg_occr
    from events
    group by event_type
) t1
on events.event_type = t1.event_type
group by business_id
having count(distinct(case when occurences &amp;gt; avg_occr then events.event_type else null end))&amp;gt;=2
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1127-用户购买平台需复习&#34;&gt;1127. 用户购买平台（需复习）&lt;/h1&gt;
&lt;p&gt;每天 &lt;strong&gt;仅&lt;/strong&gt; 使用手机端用户、&lt;strong&gt;仅&lt;/strong&gt; 使用桌面端用户和 &lt;strong&gt;同时&lt;/strong&gt; 使用桌面端和手机端的用户人数和总支出金额，null的时候需要记作0&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 构造日期*platform的笛卡尔积
with table_2 as(
    select t4.spend_date, t3.platform
    from 
	(
    select &#39;mobile&#39; as platform
    union
    select &#39;desktop&#39; as platform
    union
    select &#39;both&#39; as platform
	) t3,
	(
    select distinct spend_date
    from Spending
    order by spend_date
	) t4
)
-- left join 
select table_2.spend_date as spend_date, 
    table_2.platform as platform, 
    ifnull(sum(table_1.amount),0) as total_amount,
    count(table_1.user_id) as total_users
from table_2
left join 
(
    select t1.spend_date, t1.user_id, sum(t1.amount) as amount,
        (case when t2.num=1 then t1.platform else &amp;quot;both&amp;quot; end) as platform
    from spending t1
  	inner join (
            select spend_date, user_id, 
                count(distinct platform) as num
            from Spending
            group by spend_date, user_id
      ) t2
    on t1.spend_date = t2.spend_date
    and t1.user_id = t2.user_id
    group by t1.spend_date, t1.user_id
) table_1
on table_1.spend_date = table_2.spend_date
and  table_1.platform = table_2.platform
group by table_2.spend_date, table_2.platform
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1132报告的记录2&#34;&gt;1132.报告的记录2&lt;/h1&gt;
&lt;p&gt;在被报告为垃圾帖子（spam）中，被移除的帖子的比例的每日平均值，小数点后 2 位。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select round(avg(ratio)*100,2) as average_daily_percent
from 
(
    select action_date,
        avg(case when t2.remove_date is null then 0 else 1 end) as ratio
    from
    (
      select distinct action_date, post_id
      from Actions
      where extra = &amp;quot;spam&amp;quot;
    ) t1
    left join Removals t2
    on t1.post_id = t2.post_id
    group by action_date
) t2
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1149-文章浏览&#34;&gt;1149. 文章浏览&lt;/h1&gt;
&lt;p&gt;找出在同一天阅读至少两篇文章的人，结果按照 id 升序排序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select distinct viewer_id as id
from views
group by view_date, viewer_id
having count(distinct article_id)&amp;gt;=2
order by id asc
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1158-市场分析1&#34;&gt;1158. 市场分析1&lt;/h1&gt;
&lt;p&gt;用户 buyer_id  |注册日期 join_date  |  2019 年作为买家的订单总数orders_in_2019&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.user_id as buyer_id, t1.join_date, ifnull(t2.orders_num,0) as orders_in_2019
from users t1
left join
(
  select buyer_id, count(distinct order_id) as orders_num
  from orders
  where order_date between &amp;quot;2019-01-01&amp;quot; and &amp;quot;2019-12-31&amp;quot;
  group by buyer_id
) t2
on t1.user_id = t2.buyer_id
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1159市场分析2&#34;&gt;1159.市场分析2&lt;/h1&gt;
&lt;p&gt;确定每个用户按日期顺序&lt;strong&gt;卖出的第二件商品的品牌是否是他们最喜爱的品牌&lt;/strong&gt;。如果一个用户卖出少于两件商品，查询的结果是 no。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.user_id as seller_id,
     (case when t1.favorite_brand=t3.item_brand then &amp;quot;yes&amp;quot;
else &amp;quot;no&amp;quot; end) as 2nd_item_fav_brand
from Users t1
left join 
(
    select seller_id, item_id
    from(
        select seller_id, item_id, 
            row_number() over(partition by seller_id order by order_date asc) as rn
        from orders
    ) tmp
    where rn=2
) t2
on t1.user_id = t2.seller_id
left join Items t3
on t3.item_id = t2.item_id
order by seller_id
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1164指定日期的产品价格&#34;&gt;1164.指定日期的产品价格&lt;/h1&gt;
&lt;p&gt;Products 记录了 某产品 在某个日期 更改后 的新价格。查找在 &lt;strong&gt;2019-08-16&lt;/strong&gt; 时全部产品的价格，假设所有产品在修改前的价格都是 &lt;strong&gt;10。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小于0816的所有日期里的最大值对应的价格，没有改过的话就是10&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.product_id, ifnull(t2.new_price,10) as price
from 
(
  select distinct product_id
  from Products
) t1
left join 
(
  -- 修改过价格的
  select product_id, new_price
  from(
        select product_id
          , row_number() over(partition by product_id order by change_date desc) as rn
          , new_price
      from Products
      where change_date&amp;lt;=&amp;quot;2019-08-16&amp;quot;
  ) tmp
  where rn = 1
) t2
on t1.product_id = t2.product_id
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1174即时实物配送2&#34;&gt;1174.即时实物配送2&lt;/h1&gt;
&lt;p&gt;如果顾客期望&lt;strong&gt;配送日期和下单日期相同&lt;/strong&gt;，则该订单 「即时订单」，否则「计划订单」。&lt;/p&gt;
&lt;p&gt;「首次订单」是顾客最早创建的订单。我们保证一个顾客只会有一个「首次订单」。&lt;/p&gt;
&lt;p&gt;所有用户的首次订单中即时订单的比例。保留两位小数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select round(avg(case when customer_pref_delivery_date=order_date then 1 else 0 end)*100, 2) as immediate_percentage 
from 
(
    select * ,
        row_number() over(partition by customer_id order by order_date) as rk
    from Delivery
) tmp
where rk = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1193-每月交易1&#34;&gt;1193. 每月交易1&lt;/h1&gt;
&lt;p&gt;每个月和每个国家的事务数及其总金额、已批准的事务数及其总金额&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select date_format(trans_date, &amp;quot;%Y-%m&amp;quot;) as `month`,
	country,
	count(id) as trans_count,
    count(case when state = &amp;quot;approved&amp;quot; then id else null end) as approved_count,
	sum(amount) as trans_total_amount,
	sum(case when state = &amp;quot;approved&amp;quot; then amount else 0 end) as approved_total_amount
from Transactions
group by date_format(trans_date, &amp;quot;%Y-%m&amp;quot;), country;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1194-锦标赛优胜者&#34;&gt;1194. 锦标赛优胜者&lt;/h1&gt;
&lt;p&gt;每组的获胜者是在组内&lt;strong&gt;累积得分最高的选手&lt;/strong&gt;。如果平局，&lt;code&gt;player_id&lt;/code&gt; &lt;strong&gt;最小&lt;/strong&gt; 的选手获胜。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select group_id,player_id
from 
(
    select  t1.group_id, t1.player_id, 
        row_number() over(partition by t1.group_id order by ifnull(total_score,0) desc) as rn
    from Players t1
    left join
    (
        select player_id, sum(first_score)+sum(second_score) as total_score
        from(
            select first_player as player_id, sum(first_score) as first_score, 0 as second_score
            from matches 
            group by first_player
            union all
            select second_player as player_id, 0 as first_score, sum(second_score) as second_score
            from matches 
            group by second_player
        ) tmp
        group by player_id
    ) t2
    on t1.player_id = t2.player_id
) t3
where rn = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1204最后进入电梯的&#34;&gt;1204.最后进入电梯的&lt;/h1&gt;
&lt;p&gt;电梯最大载重量为 &lt;strong&gt;1000&lt;/strong&gt;。查找最后一个能进入电梯且不超过重量限制的 &lt;code&gt;person_name&lt;/code&gt; 。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select person_name
from(
  select person_name, 
    sum(weight) over(order by turn asc) as weight_sum
  from queue
) tmp
where weight_sum &amp;lt;= 1000
order by weight_sum desc
limit 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1205-每月交易2&#34;&gt;1205. 每月交易2&lt;/h1&gt;
&lt;p&gt;以查找每个月和每个国家/地区的已批准交易的数量及其总金额、退单的数量及其总金额。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select `month`,country,
    sum(approved_count) as approved_count,
    sum(approved_amount) as approved_amount,
    sum(chargeback_count) as chargeback_count,
    sum(chargeback_amount) as chargeback_amount
from
(
  	-- 批准交易的
    select date_format(trans_date, &amp;quot;%Y-%m&amp;quot;) as `month`, country,
        count(id) as  approved_count,
        sum(amount) as approved_amount,
        0 as chargeback_count,
        0 as chargeback_amount
    from Transactions
    where state = &amp;quot;approved&amp;quot;
    group by date_format(trans_date, &amp;quot;%Y-%m&amp;quot;), country
    
  	union all
    -- 退单的
  	select 
        date_format(t1.trans_date, &amp;quot;%Y-%m&amp;quot;) as `month`,
        t2.country,
        0 as approved_count,
        0 as approved_amount,
        count(t2.id) as chargeback_count,
        sum(t2.amount) as chargeback_amount
    from Chargebacks t1
    inner join Transactions t2
    on t1.trans_id = t2.id
    group by date_format(t1.trans_date, &amp;quot;%Y-%m&amp;quot;), t2.country
) tmp
group by `month`,country
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1212-查询球队积分&#34;&gt;1212. 查询球队积分&lt;/h1&gt;
&lt;p&gt;赢一场得三分；平一场得一分；输一场不得分。&lt;br&gt;
查询每个队的 team_id，team_name 和 num_points。结果根据 num_points 降序排序，如果有两队积分相同，那么这两队按 team_id  升序排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- my answer
select 
    Teams.team_id,
    Teams.team_name,
    ifnull(sum(tmp.host_goals),0) + ifnull(sum(tmp.guest_goals),0) as num_points
from Teams
left join
(
  select host_team as team_id, 
    sum(case when host_goals&amp;gt;guest_goals then 3 
      when  host_goals=guest_goals then 1
    else 0 end) as host_goals,
    0 as guest_goals
  from matches
  group by host_team
  union all
  select guest_team as team_id, 
    0 as host_goals,
    sum(case when host_goals&amp;lt;guest_goals then 3 
      when  host_goals=guest_goals then 1
    else 0 end) as guest_goals
  from matches
  group by guest_team
) tmp
on Teams.team_id = tmp.team_id
group by team_id
order by num_points desc, team_id asc;

-- 写的有点复杂，参考题解
-- 不用 union 用 复杂的 or 
select t1.team_id,t1.team_name,
	sum((case when (t1.team_id = t2.host_team and host_goals&amp;gt;guest_goals) or (t1.team_id = t2.guest_team and host_goals&amp;lt;guest_goals)  then 3
   when host_goals=guest_goals then 1
   else 0
  end)) as num_points
from teams t1
left join matches t2
on (t1.team_id = t2.host_team or t1.team_id = t2.guest_team)
group by t1.team_id, t1.team_name
order by num_points desc, team_id asc
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1225-报告系统状态的连续日期需复习&#34;&gt;1225. 报告系统状态的连续日期（需复习）&lt;/h1&gt;
&lt;p&gt;系统 每天 运行一个任务。每个任务都独立于先前的任务。任务的状态可以是失败或是成功。&lt;/p&gt;
&lt;p&gt;编写一个 SQL 查询 2019-01-01 到 2019-12-31 期间任务&lt;strong&gt;连续同状态 period_state 的起止日期&lt;/strong&gt;（start_date 和 end_date）。即如果任务失败了，就是失败状态的起止日期，如果任务成功了，就是成功状态的起止日期。&lt;/p&gt;
&lt;p&gt;最后结果按照起始日期 start_date 排序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;with tmp as(
    select fail_date as date_day,
  -- 用datediff 而不是原本日期，以避免判定1.31和2.1不是连续的这种情况
        datediff(fail_date, &amp;quot;2019-01-01&amp;quot;)+1 as date_day2,
         &amp;quot;failed&amp;quot; as period_state
    from Failed
    union 
    select success_date as date_day,
        datediff(success_date, &amp;quot;2019-01-01&amp;quot;)+1 as date_day2,
        &amp;quot;succeeded&amp;quot; as period_state
    from Succeeded
) -- 先union
-- 连续按照day - row_number 计算
select period_state,
      min(date_day) as start_date,
      max(date_day) as end_date
from(
    select date_day, period_state, 
        row_number() over(partition by period_state order by date_day2 asc) as rn,
        date_day2 - row_number() over(partition by period_state order by date_day2 asc) as date_rn
    from tmp
    where date_day&amp;gt;=&amp;quot;2019-01-01&amp;quot; and date_day&amp;lt;=&amp;quot;2019-12-31&amp;quot;
) tmp2
group by period_state, date_rn 
order by start_date asc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1264页面推荐&#34;&gt;1264.页面推荐&lt;/h1&gt;
&lt;p&gt;写一段 SQL  向&lt;code&gt;user_id&lt;/code&gt; = 1 的用户，推荐其朋友们喜欢的页面。不要推荐该用户已经喜欢的页面。你返回的结果中不应当包含重复项。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select distinct page_id as recommended_page
from likes
where user_id in (
    select distinct (case when user1_id = 1 then user2_id else user1_id end) as friend_id
    from Friendship
    where (user1_id = 1 or user2_id = 1)
)
and page_id not in (
    select distinct page_id
    from likes
    where user_id = 1
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1270向公司ceo汇报工作的所有人&#34;&gt;1270.向公司CEO汇报工作的所有人&lt;/h1&gt;
&lt;p&gt;用 SQL 查询出所有直接或间接向公司 CEO 汇报工作的职工的 employee_id 。由于公司规模较小，经理之间的间接关系不超过 3 个经理。可以以任何顺序返回的结果，不需要去重。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select distinct employee_id
from Employees
where manager_id  in (
    select distinct employee_id
    from Employees
    where manager_id  in (
        select distinct employee_id
        from Employees
        where manager_id = 1
    )
)
and employee_id != 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1285-连续区间的开始和结束数字&#34;&gt;1285. 连续区间的开始和结束数字&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Logs&lt;/code&gt; 表中的连续区间的开始数字和结束数字。按照 &lt;code&gt;start_id&lt;/code&gt; 排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select min(log_id) as start_id, max(log_id) as end_id
from(
  select log_id,log_id - row_number()over(order by log_id asc) as log_rk
	from logs
) tmp
group by log_rk;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1308-不同性别的每日分数统计&#34;&gt;1308. 不同性别的每日分数统计&lt;/h1&gt;
&lt;p&gt;查询每种性别在每一天的总分，并按性别和日期对查询结果排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select gender, day, 
    sum(score_points) over(partition by gender order by day) total
from scores
order by gender, day
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1321-餐馆营业额变化增长连续求和&#34;&gt;1321. 餐馆营业额变化增长—连续求和&lt;/h1&gt;
&lt;p&gt;写一条 SQL 查询计算以 7 天（某日期 + 该日期前的 6 天）为一个时间段的顾客消费平均值。输出按照日期排序。&lt;/p&gt;
&lt;p&gt;连续求和：&lt;strong&gt;sum&lt;/strong&gt;(amount) over(&lt;strong&gt;order by&lt;/strong&gt; visited_on &lt;strong&gt;rows 6 preceding&lt;/strong&gt;) 对当前和后6行连续求和&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 普通解法
select 
    c1.visited_on, 
    sum(c2.amount) as amount,
    round(sum(c2.amount) / 7, 2) as average_amount
from 
(
    select distinct visited_on
    from Customer
    where datediff(visited_on,(select min(visited_on) from Customer))&amp;gt;=6
) c1,
Customer c2
where datediff(c1.visited_on, c2.visited_on)&amp;lt;=6
and c2.visited_on &amp;lt;= c1.visited_on
group by c1.visited_on
order by c1.visited_on asc


-- 窗口函数新解法
select * from
(
    select visited_on,
        sum(amount) over(order by visited_on rows 6 preceding) as amount,
        round(avg(amount) over(order by visited_on rows 6 preceding),2) as average_amount
    from(
         select visited_on, sum(amount) as amount 
         from Customer
         group by visited_on
    )t1
)t2 
where datediff(visited_on, (select min(visited_on)from Customer))&amp;gt;=6
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1336每次访问的交易次数&#34;&gt;1336.每次访问的交易次数&lt;/h1&gt;
&lt;p&gt;多少客户访问了银行但没有进行任何交易，多少客户访问了银行进行了一次交易等等&lt;/p&gt;
&lt;p&gt;结果包含两列：&lt;/p&gt;
&lt;p&gt;transactions_count： 客户在一次访问中的交易次数&lt;br&gt;
visits_count： 在 transactions_count 交易次数下&lt;strong&gt;相应的客户数量&lt;/strong&gt;&lt;br&gt;
transactions_count 的值从 0 到所有用户一次访问中的 max(transactions_count)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 
from visits t1
left join Transactions t2
on t1.user_id=t2.user_id
and 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1341-电影评分&#34;&gt;1341. 电影评分&lt;/h1&gt;
&lt;p&gt;请你编写一组 SQL 查询：&lt;/p&gt;
&lt;p&gt;查找评论电影数量最多的用户名。&lt;br&gt;
如果出现平局，返回字典序较小的用户名。&lt;/p&gt;
&lt;p&gt;查找在 2020 年 2 月 平均评分最高 的电影名称。&lt;br&gt;
如果出现平局，返回字典序较小的电影名称。&lt;/p&gt;
&lt;p&gt;查询分两行返回，查询结果格式如下例所示：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select `name` as results
from
(
    select `name`,
        count(1) as num
    from Movie_Rating
    left join Users on Movie_Rating.user_id = Users.user_id
    group by `name`
    order by num desc, `name` asc
    limit 1
) t1
union all
select title as results
from 
(
    select title,
        avg(case when date_format(created_at, &amp;quot;%Y-%m&amp;quot;)=&amp;quot;2020-02&amp;quot; then rating else null end ) as rating
    from Movie_Rating
    inner join Movies on Movie_Rating.movie_id = Movies.movie_id
    group by title
    order by rating desc, title asc
    limit 1
) t2
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1355活动参与者&#34;&gt;1355.活动参与者&lt;/h1&gt;
&lt;p&gt;写一条 SQL 查询那些既没有最多，也没有最少参与者的活动的名字。注意名称相同 id 不同的参与者算作两个人。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select activity
from
(
    select activity, num,
    rank() over(order by num asc ) as rk1,
    rank() over(order by num desc ) as rk2
    from (
        select activity, count(distinct id) as num
        from Friends
        group by activity
    ) t1
) t2
where rk1&amp;gt;1 and rk2&amp;gt;1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1364顾客的可信联系人数&#34;&gt;1364.顾客的可信联系人数&lt;/h1&gt;
&lt;p&gt;为每张发票 invoice_id 编写一个SQL查询以查找以下内容：&lt;/p&gt;
&lt;p&gt;customer_name：与发票相关的顾客名称。&lt;br&gt;
price：发票的价格。&lt;br&gt;
contacts_cnt：该顾客的联系人数量。&lt;br&gt;
trusted_contacts_cnt：可信联系人的数量：既是该顾客的联系人又是商店顾客的联系人数量（即：可信联系人的电子邮件存在于客户表中）。&lt;br&gt;
将查询的结果按照 invoice_id 排序。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.invoice_id,t3.customer_name,
    t1.price as price, 
    count(distinct t2.contact_email) as contacts_cnt,
    ifnull(t4.trusted_contacts_cnt,0) as trusted_contacts_cnt
from Invoices t1
left join Contacts t2
on t1.user_id = t2.user_id
left join Customers t3
on t3.customer_id = t1.user_id
left join (
    select Contacts.user_id, count(distinct Customers.customer_id) as trusted_contacts_cnt
    from Contacts
    inner join Customers
    on Contacts.contact_name = Customers.customer_name
    group by Contacts.user_id
) t4
on t4.user_id = t1.user_id
group by t1.invoice_id
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1369-获取第二次的活动&#34;&gt;1369. 获取第二次的活动&lt;/h1&gt;
&lt;p&gt;展示每一位用户 &lt;strong&gt;最近第二次&lt;/strong&gt; 的活动，如果用户仅有一次活动，返回该活动&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select username, activity,startDate,endDate
from (
    select *,
        row_number() over(partition by username order by startDate desc) as rk1,
        row_number() over(partition by username order by startDate asc) as rk2
    from UserActivity
) tmp
where (rk1 = rk2 and rk1 = 1)  or rk1=2
&lt;/code&gt;&lt;/pre&gt;
">sql 力扣速成（上）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/xgboost-yuan-li-yu-mian-shi-wen-ti/"" data-c="
          &lt;h1 id=&#34;原理推导&#34;&gt;原理推导：&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1615543724318.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;xgboost常见面试题&#34;&gt;xgboost常见面试题&lt;/h1&gt;
&lt;h2 id=&#34;1boosting的思想&#34;&gt;1.Boosting的思想&lt;/h2&gt;
&lt;p&gt;（直接讲adaboost）初始化训练一个弱学习器，每次依照训练结果调整样本权重，增大错分样本的权重并基于此训练下一个学习器，预测时串联各学习器的加权结果。&lt;/p&gt;
&lt;h2 id=&#34;2xgboost和gbdt的区别&#34;&gt;2.XGBoost和GBDT的区别：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;损失函数上：对于Loss部分是一阶还是二阶展开（二阶更准确）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;正则项上：XGBoost加上树模型复杂度的正则项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特征选择上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;加入近似算法（不是遍历所有可能取值，而是有间隔的选取候选拆分点/分桶），默认tree_method = “auto”将在中小数据上沿用贪心算法，大数据集上使用近似算法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XGBoost引入随机森林在特征集合抽样的思想，帮助降低过拟合&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基学习器上：gbdt 只能用cart算法的回归树，而xgboost 支持线性分类器 gblinear。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺失值处理上：XGBoost在训练时缺失值会被分到左子树和右子树，分别计算目标函数，对比选择较优的分配方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算速度上——pre_sorted预排序、分箱的近似算法、分布式计算等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3xgboost-计算速度上的提升点&#34;&gt;3.XGBoost 计算速度上的提升点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;决策树最耗时的步骤是对特征的值排序，XGBoost在迭代之前，先进行预排序，存为block结构，每次迭代重复使用该结构，降低计算，同时各个特征的增益计算可以&lt;strong&gt;开多线程进行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（这里也有一个考点，&lt;strong&gt;xgb 的并行和Rf不同，是在选择分割方式时，并行计算各个特征的最佳分割点，而不是并行构造tree&lt;/strong&gt;，所有 boosting 算法都是additive training 无法并行构造tree）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分箱 / 近似直方图算法，不是遍历所有可能取值，而是有间隔的选取候选拆分点/分桶，比如连续值直接取分位数。（LightGBM方法采用histogram算法，复杂度更低）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4目标函数-mae-二阶不可导问题&#34;&gt;4.目标函数 MAE 二阶不可导问题&lt;/h2&gt;
&lt;p&gt;有绝对值的目标函数 MAE MAPE 二阶不可导，主流方法是用利用可导函数逼近，比如MSE或者&lt;strong&gt;Pseudo-Huber loss function&lt;/strong&gt;：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://www.zhihu.com/equation?tex=L_%5Cdelta%28y_i%2C%5Ctilde%7By%7D_i%29%3D%5Cdelta%5E%7B2%7D%28%5Csqrt%7B1%2B%28%5Cfrac%7B%5Ctilde%7By%7D_i-y_i%7D%7B%5Cdelta%7D%29%5E%7B2%7D%7D-1%29&#34; alt=&#34;[公式]&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;5xgboost-如何调参&#34;&gt;5.XGBoost 如何调参？&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://xgboost.readthedocs.io/en/latest/parameter.html&#34;&gt;所有参数介绍地址&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确定 eta（学习率）和 n_estimators（迭代次数=树的个数）&lt;/li&gt;
&lt;li&gt;再确定每棵树的基本信息，max_depth 和 min_child_weight（即节点大H值）&lt;/li&gt;
&lt;li&gt;再确定全局信息：比如最小分裂增益，采样参数（样本采样 subsample、特征采样colsample_bytree），正则参数（L1-alpha和L2-lambda）&lt;/li&gt;
&lt;li&gt;重新降低 eta（学习率），得到最优解&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6xgboost-过拟合怎么办&#34;&gt;6.XGBoost 过拟合怎么办？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对树的剪枝：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;降低树的深度 max_depth&lt;/li&gt;
&lt;li&gt;增大 min_child_weight（即节点大H值）&lt;/li&gt;
&lt;li&gt;增大惩罚系数alpha和lambda&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;subsample 力度变大，降低异常点影响&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;减小 learning rate，提高 n_estimators&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">XGBoost 原理与面试问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/yin-guo-tui-duan-jian-jie/"" data-c="
          &lt;p&gt;今日收获就是没有收获，跟风感谢日文和涛总的陪伴~&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;问题引入源自两方面：&lt;/p&gt;
&lt;p&gt;1.老板提问：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了对比ab两组流量的ctr差别，在给点显著性水平和期望误差1%内的条件下，可以计算出所需最小的样本量。随后根据流量顺序划分AB两组作为实验组和对照组。在该分组的基础上，评价使用核心指标变为gmv（每个人在周期内的总购买金额）。空跑4天，结果发现AB两组gmv差异已经存在，甚至有些时间区间上显著。如果仍坚持开始实验，如何通过数据分析的方法，说明最终结果差异显著是由于实验处理而不只是分组本身差异或者其他因素？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.面试问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Simpson 悖论在第一次面字节时被问到了，当时懵了一会才意识过来~ Simpson 悖论（总体和部分表现出相反结论，比如&lt;a href=&#34;https://baike.baidu.com/item/%E8%BE%9B%E6%99%AE%E6%A3%AE%E6%82%96%E8%AE%BA/4475862?fr=aladdin&#34;&gt;男女录取率在总体和不同专业分层的结果之间矛盾&lt;/a&gt;）本质上属于内生性问题（解释变量和误差项存在相关关系），常见的原因是遗漏变量（比如男女比例差异）。这说明，有时是无法从相关性推导出因果关系的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;1rubin-causal-model&#34;&gt;1.Rubin Causal Model&lt;/h1&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Z_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 表示个体i是否接受处理，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Y_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示结果变量，则个体i的观测结果是：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Y_i = Z_iY_i(1) +  (1-Z_i) Y_i(0)
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;11-causal-effect&#34;&gt;1.1 Causal effect&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;不可观测的 个体因果作用 (ICE)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ICE: individual Causal effect，个体i的因果作用 causal effect :&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;ICE = Y_i(1) -Y_i(0)
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而实验中的个体要么接受处理，要么接受对照，我们只能观测&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Y_i(1)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 或者&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Y_i(0)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，便无法计算其因果作用，这是因果推断的基本问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可识别的 平均因果作用 (ACE)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ACE: average Causal effect， 定义为个体因果作用的期望：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;I&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;−&lt;/mi&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;ACE = E(ICE) = E(Y1 −Y0) = E(Y_1) - E(Y_0) 
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;I&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Y_1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;表示个体接受处理之后的潜在结果，其期望可以由&lt;em&gt;所有个体都接受处理的潜在结果的均值&lt;/em&gt;来估计。&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Y_0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;同理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是在实际中，我们不可能让所有的个体都接受处理。我们分配实验组和对照组，而当 Z 做随机化的前提下有 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;E(Y_1)  = E(Y|Z =1 ) ,E(Y_0)  = E(Y|Z = 0)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。此时个体是否处理与潜在结果无关，总体的平均因果作用可识别（可识别表示因果作用可以用&lt;strong&gt;观测数据的分布唯一的表示&lt;/strong&gt;）:&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mi&gt;C&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;随&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;机&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;化&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;试&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;验&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;下&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;−&lt;/mi&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;ACE  (随机化试验下) = E(Y |Z = 1) − E(Y |Z= 0)
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;随&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;机&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;化&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;试&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;验&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;下&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;12-随机化试验的理想与现实&#34;&gt;1.2 随机化试验的理想与现实&lt;/h2&gt;
&lt;h3 id=&#34;理想可忽略的分配机制&#34;&gt;理想：可忽略的分配机制&lt;/h3&gt;
&lt;p&gt;随机化试验对于平均因果作用的识别起着至关重要的作用。在有协变量的随机化试验中，平均因果作用是可识别的要求：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;⊥&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Z⊥{Y(1),Y(0)} | X
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;⊥&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;即给定协变量X 后，处理的分配机制是完全随机化的，这被叫做“可忽略性”。这里引出了因果推断问题最重要的一步，就是对对照组和实验组的平衡进行检测。&lt;/p&gt;
&lt;h3 id=&#34;现实混杂偏倚&#34;&gt;现实：混杂偏倚&lt;/h3&gt;
&lt;p&gt;当协变量的分布在处理组和对照组均衡时，则我们在协变量取值的每一层， 都能得到该层平均因果作用的相合估计。当协变量的分布在处理组和对照组均衡时，就会出现不同层结果不一致甚至截然相反的矛盾。为了消除协变量的分布在处理组与对照组之间的差异，最基础的方法就是：&lt;/p&gt;
&lt;h2 id=&#34;13-matching-与-倾向得分&#34;&gt;1.3 Matching  与 倾向得分&lt;/h2&gt;
&lt;p&gt;简单的想法就是从对照组中找到和处理组中比较“接近” 的个体进行匹配，这样得出的作用，可以近似平均因果作用，“接近”的标准是基于观测协变量的。如果观测协变量的维数较高，匹配就很难实现了。&lt;/p&gt;
&lt;p&gt;此时可以使用倾向得分匹配。倾向得分 ( propensity score ) 定义为条件概率:&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;p(Z = 1|X)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，不难看出可以用 logistic 回归算出倾向得分。随后可以根据它分层/加权，得到各层/总体加权平均因果效应的估计。&lt;/p&gt;
&lt;p&gt;这里，用一个性别协变量不平衡导致的&lt;strong&gt;辛普森悖论&lt;/strong&gt;作为例子：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://uploads.cosx.org/2012/03/simpson.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;Y：结果变量，survive / die（则 E(Y) = P(Y=1) = survive rate ）
Z：随机分组变量，treatment / control
X：协变量，male / female
--
1.如果不考虑协变量性别的在分组中的不平衡问题，直接对男女总体进行估计：
ACE = E(y|z=1) - E(y|z=0) =  p(y=1|z=1) - p(y=1|z=0) = 0.5-0.4 = 0.1
-- 
2.如果考虑分组不平衡，按照协变量性别进行加权调整：
ACE = (p(y=1|z=1, x=1) - p(y=1|z=0, x=1))*p(x=1) + 
			(p(y=1|z=1, x=0) - p(y=1|z=0, x=0))*p(x=0) 
		= (0.6-0.7)*0.5 + (0.2-0.3)*0.5
		= -0.1
-- 
是否根据性别进行调整，得到的结果完全相反
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2-因果图-causal-diagram&#34;&gt;2. 因果图 (Causal Diagram)&lt;/h1&gt;
&lt;h2 id=&#34;21-图模型基本概念&#34;&gt;2.1 图模型基本概念&lt;/h2&gt;
&lt;p&gt;图模型的概念这部分在数据结构有所接触，&lt;a href=&#34;http://localhost:4000/post/py1015-2/&#34;&gt;这里回顾一下&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中重点在于DAG（有向无环图）/图模型/贝叶斯网络&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/18478302/25562044/03151afa-2dad-11e7-94c8-c5826f17d063.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在这张图中，x1...xj的联合分布可以根据全概率公式做如下的递归分解：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;P&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;4&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;5&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mn&gt;6&lt;/mn&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;P(X_1, X_2, X_3, X_4, X_5, X_6, X_i, X_j) = P(X_1)(X_2)P(X_3|X_1) P(X_5|X_2)P(X_4| X_1, X_2)P(X_|X_3, X_4)  P(X_6|X_i) P(X_j|X_4, X_5, X_6)
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.036108em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.1052em;vertical-align:-0.3551999999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.34480000000000005em;&#34;&gt;&lt;span style=&#34;top:-2.5198em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;∣&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3551999999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.13889em;&#34;&gt;P&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;6&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;【注意点】一个有向无环图唯一地决定了一个联合分布；反过来，一个联合分布不能唯一地决定有向无环图（因为乘法公式的不唯一）&lt;/p&gt;
&lt;h2 id=&#34;22-结构方程模型&#34;&gt;2.2 结构方程模型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;structural equation model: SEM&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SEM 是因果图的先驱。具体来说结构方程模型和图模型之间的关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原因Z——父节点，结果Y——子节点，间接原因X——Z的父节&lt;/li&gt;
&lt;li&gt;外生变量：根节点&lt;/li&gt;
&lt;li&gt;内生变量：子节点&lt;/li&gt;
&lt;li&gt;边：函数关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;e.g. U = {X 教育程度，Y 经验}  ，  V = {Z 工资}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【注意点】因果关系&amp;amp;统计相关性：互相都不能推出另一方&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-v-structure&#34;&gt;2.3 V structure&lt;/h2&gt;
&lt;p&gt;不同结构下，如何快速判断条件独立性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;链式结构&lt;/strong&gt;（chain）&lt;/p&gt;
&lt;p&gt;X 和 Z之间通过Y相连——则给定Y时，Z和X独立。condition 在哪儿相当于切断此处和周围的所有的连接。可以利用这个来&lt;strong&gt;解释辛普森悖论&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1615037603717.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;X是针对某一种疾病的药物，可以促进Y的恢复。具体来说，使用X可以帮助调节血压Z，从而促进Y的恢复&lt;u&gt;。但当我们控制/condition on Z时，相当于切断此处的所有连接&lt;/u&gt;，只看X对Y的直接影响（副作用），结果则是抑制恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;叉状结构（fork）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;X是的导致Y和Z的共同原因，Y 和 Z 是相关的——conditional在X上，Y和Z独立。可以利用这个来&lt;strong&gt;解释辛普森悖论&lt;/strong&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1615037607834.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
比如X：age，Y：exercie，Z：胆固醇含量。直接看Y和Z之间的关系，exercise 提高胆固醇含量增加。而加上 condition X 时，每个年龄段内 exercise 提高胆固醇含量降低。（why，年龄X对exercise Y 和 胆固醇含量 Z 都有影响，年龄增加exercise 增多，胆固醇也增多）&lt;/p&gt;
&lt;p&gt;另一个夸张的例子，穿着鞋睡觉和醒来头痛之间有强烈相关关系，而condition on 宿醉时，两者独立。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对撞结构（collider）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;X 和 Y 是导致 Z 的共同原因。则 X 和 Y 独立，但当 &lt;strong&gt;condition 在 Z 或者 Z的后继节点上&lt;/strong&gt;，则 原本独立的 X 和 Y 变为相关。&lt;/p&gt;
&lt;p&gt;比如智力和试题难度共同决定成绩高低，首先智力和难度是独立的，但当 condition 成绩时，两者出现相关。已知成绩低，如果智力高则说明试题难度高。已知成绩高，如果难度高说明智力也高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;d 分离 (d - separation)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义（&lt;strong&gt;d 分离&lt;/strong&gt;）: 设 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;X&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Y&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Z&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 是 DAG 中不相交的节点集合，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;π&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\pi&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;π&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 为一条连接 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;X&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 中某节点到 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Y&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 中某节点的路径 （不管方向）。如果路径 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;π&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\pi&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;π&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 上某节点满足如下的条件：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1）在路径&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;π&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\pi&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;π&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; ，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;w&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 点处为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;V&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;V&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 结构 （或称冲撞点，collider），且 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;w&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 及其后代不在 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Z&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 中；&lt;/p&gt;
&lt;p&gt;（2）在路径 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;π&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\pi&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;π&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 上，&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;w&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 点处不是 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;V&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;V&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;V&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 结构，且 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;w&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 在 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Z&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 中,&lt;/p&gt;
&lt;p&gt;那么称 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Z&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 阻断 (block) 了路径 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;π&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\pi&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;π&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。进一步，如果 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Z&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 阻断了 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;X&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 到 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Y&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 的所有路径，那么称 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Z&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;strong&gt;d分离&lt;/strong&gt; &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;X&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 和 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Y&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，记为 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;⊥&lt;/mi&gt;&lt;mi&gt;Y&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;Z&lt;/mi&gt;&lt;msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;G&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(X\bot Y|Z)_{G}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;⊥&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.22222em;&#34;&gt;Y&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07153em;&#34;&gt;Z&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32833099999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;G&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何直观理解d分离？用一个例子：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1615037481472.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;在这样的一个DAG中，观察到上方是 fork 结构，中间是 chain 结构，下方是 collider 结构。
找到能够 block 从 T 到 Y 所有路径的方式如下：
- M1 + W1/W2/W3（阻断fork&amp;amp;chain, collider 不动，对于（2）的情况）
- M1 + W1/W2/W3 + X2 + X1/X3（只有 X2 让下方的collider 父节点相关，加上X1或X3之后 T 和 Y 独立了。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;24-从dag到因果图&#34;&gt;2.4 从DAG到因果图&lt;/h2&gt;
&lt;h3 id=&#34;do-operator&#34;&gt;do-operator&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;“干预” vs “条件”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;理解Do算子，从&lt;strong&gt;干预&lt;/strong&gt;（intervening) 和&lt;strong&gt;条件&lt;/strong&gt; (conditioning) 的概念关系来理解。两个概念非常非常接近，在图模型中都相当于切断某处的所有连接，并且将其取值看做常数。但是区别在于，当我们引入“因果”的概念后，&lt;u&gt;&lt;strong&gt;当我们干预“结果”，并不会影响“原因”的分布，但是当 condition on “结果”的时候，“原因”的条件分布会改变&lt;/strong&gt;&lt;/u&gt;。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://cloud.githubusercontent.com/assets/18478302/25562057/8e81e640-2dad-11e7-8a97-c79ef34f169e.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在上图的例子中，看条件和干预的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A.条件 p(X1|x2)
&lt;ul&gt;
&lt;li&gt;无论X1和X2的因果关系如何，p(X1|X2)不变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B.干预  p(X1|do(X2))
&lt;ul&gt;
&lt;li&gt;在（1）的情况下，X1是原因X2是结果，则p(X1|do(X2))  = p(X1)【上面划线句】&lt;/li&gt;
&lt;li&gt;在（2）的情况下，X1是结果X2是原因，则p(X1|do(X2))  = p(X1|X2)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;backdoor-frontdoor-criterion&#34;&gt;backdoor / frontdoor criterion&lt;/h3&gt;
&lt;p&gt;。。。（没理解但是累了，so下周继续~&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1nZ4y1K78i?p=1&#34;&gt;爱可可老师在B站上推荐的因果推理导论课&lt;/a&gt;&lt;/p&gt;
">因果推断基本概念</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/ha-fo-da-xue-xing-fu-ke-bi-ji-shang-p1-p8/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;热评: “兜兜转转这么多年，完美主义，过犹不及，all or nothing，归咎他人，这些“问题”戴上各式面具继续困扰着我。一失败就手足无措，一努力就急于求成，我几乎翻遍所有写焦虑，抑郁，消极的帖子，却总是鬼打墙一般地恶性循环。今年卡在人生转变的关口，越来越深刻地感受到积极主动的重要性，于是重新打开这门课，认认真真地从头看完。&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;01-02-make-your-life-better&#34;&gt;01-02 make your life better&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;No one is coming to make your life better for you. You&#39;re resposible for your life,for  your self-confidence, for your happiness.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们现在的时间大多花在 time-out，花在look into yourself 的 time-in 太少了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Question create reality：多问问自己积极问题，比如我的优点是什么（心理暗示）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;slightly happy if you lower my levels of expectation, but not in the long term.（对最近的我来说很重要）。财富、升职等等都 make very little difference.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;03-05-the-cause-of-unhappiness&#34;&gt;03-05 the cause of unhappiness&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;弗洛依德：“人们在舒适地麻木”。人类的适应性，但这种适应性带来的对美好事物的习以为常，让我们对事情麻木，这是负面的（想起王小波关于挑粪生活的那句话了）。我们如果对消极可适应，但对幸福的日常生活不习以为常。就好了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或许相信某件事能基于精神上慰藉和充实，但长期会产生愧疚感和沮丧感。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有正确的 expectation 才能让我们 happier 。错误的 expectation 比如：找到工作/理想伴侣，而 right expectation is to believe in change——相信事情会完美解决&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;认为生活有意义。意义感从哪里来？Goal setting，role model，social support，courage of admit weakness。真正感觉幸福的人的 leading question: how can I make this world a better place?&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No.1 cause of unhappiness—people feel guilty about pursuing their own happiness. 怎么解决：the permission to be human: rejecting our nature leads to suboptimal performance. 比如，&lt;strong&gt;嫉妒是一种情感，我们 accept&amp;amp;承认，但是不代表屈从这种想法&lt;/strong&gt;，e.g. i can still experience envy toward my best friend, and choose to behave generously toward him.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;悲观和乐观区别不在于是否快乐，而是多快能从不快乐中恢复过来——积极主动地去处理这些情况。重点在于：more generous, more accepting of other people, more tolerant of other people as well as ourselves.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;具体来说，尝试&lt;strong&gt;一天内多做五件好事&lt;/strong&gt;，每日冥想（今天1/1）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;06-08-learn-to-fail-or-fail-to-learn&#34;&gt;06-08  learn to fail, or fail to learn&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;焦虑的成因便是意识到理想与现实的gap。解决焦虑：
&lt;ul&gt;
&lt;li&gt;要么改变理想，墙头草又如何&lt;/li&gt;
&lt;li&gt;要么改变现实：①改变主观对现实的认知：选择性看待现实，逃避总是比改变简单呢；②改变客观现实&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;人生的起伏改变的不过是暂时的幸福与自尊，那么怎样提升 base level happniess？幸福和什么关系最大？答案是自尊 self-concept is destiny.  &lt;strong&gt;怎样提升自尊？&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;【行动起来】&lt;strong&gt;解决而不是逃避问题，把自己置于风险之上&lt;/strong&gt;，尝试那些重要的事情，自尊会螺旋式上升。why? ——Self-perception theory。多经历失败，成长的途径只有这一条。&lt;em&gt;learn to fail, or fail to learn&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;【想象成功】大脑无法区别真实的事物和想象的事物，反复想象成功&lt;/li&gt;
&lt;li&gt;【认知疗法】避免放大，归纳过度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;自我认知理论&lt;/strong&gt;: 如果看到别人主动交流、发言、尝试，我会觉得他很自信有勇气，于是便会用同样的方式判断自己的自尊、宽容程度、豁达程度。比如自己也大胆主动交流，那么我也会认为”我一定很勇敢“。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;归纳过度&lt;/strong&gt;：他拒绝了我，因此大家都会拒绝我，把失败当做一次机遇、一个跳板，而是视之为世界末日，永远找不到工作，全有或全无。要么全是A，要么就是彻底的失败，阻止我们投入进去。它的另一面，同一个硬币的另一面，是极小化。&lt;/p&gt;
&lt;/blockquote&gt;
">哈佛大学幸福课笔记 （上）p1-p8</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/ye-wu-or-zhi-biao-yi-dong-wen-ti/"" data-c="
          &lt;p&gt;常见问题：GMV\日活\转化率\客单价\用户流失率的变化原因分析。分析基本流程：明确问题——定位问题——原因假设——提出建议/数据支撑假设。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;基本流程&#34;&gt;基本流程&lt;/h1&gt;
&lt;p&gt;明确问题——定位问题——原因假设和建议&lt;/p&gt;
&lt;p&gt;1.明确问题：确认数据真实性，是相对什么而言的下降&lt;/p&gt;
&lt;p&gt;2.定位问题：指标拆解+漏斗分析&lt;/p&gt;
&lt;p&gt;3.原因假设，内部（运营、开发）+外部（pest）&lt;/p&gt;
&lt;p&gt;4.提出建议：针对不同的原因假设&lt;/p&gt;
&lt;h1 id=&#34;具体分析&#34;&gt;具体分析&lt;/h1&gt;
&lt;h2 id=&#34;单一类指标dau&#34;&gt;单一类指标——DAU&lt;/h2&gt;
&lt;p&gt;DAU 下降，如何分析？直接套用上面的基本流程：&lt;/p&gt;
&lt;h3 id=&#34;1明确问题&#34;&gt;1.明确问题&lt;/h3&gt;
&lt;p&gt;确认数据真实性，计算bug；确认是相对什么而言的下降（横比还是总比？）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;环比数据：平稳下降还是骤跌？排查突发性事件还是累积性事件。&lt;/li&gt;
&lt;li&gt;近年同比数据：是否有同级别的下降？排查是否收到周期性、节日、重大赛事的分析&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2定位问题&#34;&gt;2.定位问题&lt;/h3&gt;
&lt;p&gt;指标拆解定位问题，越细越好——定位具体群体&lt;/p&gt;
&lt;p&gt;常见分析顺序：新 or 老用户，用户来源渠道（质量，定位问题，帮助分析各个渠道投放ROI，从而改变渠道投放比例或者内容），登录入口（手机端和pc段），机型（不同档次的机型，用户质量不同）等等。具体可以计算指标变化率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户分群
&lt;ul&gt;
&lt;li&gt;基本：新老用户、渠道、机型、登录入口&lt;/li&gt;
&lt;li&gt;画像：男女、地区、职业等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;访问时段&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3原因假设&#34;&gt;3.原因假设&lt;/h3&gt;
&lt;p&gt;提出原因假设，为什么会出现问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部原因
&lt;ul&gt;
&lt;li&gt;产品：功能变动、推荐策略调整、UI设计改动&lt;/li&gt;
&lt;li&gt;开发：bug？耗电，加载过慢&lt;/li&gt;
&lt;li&gt;运营：推送活动，推广效果不佳&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;外部原因：
&lt;ul&gt;
&lt;li&gt;时间因素，比如开学或者假期&lt;/li&gt;
&lt;li&gt;政府政策、社会事件（舆论）&lt;/li&gt;
&lt;li&gt;市场价格、竞品&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4提出建议&#34;&gt;4.提出建议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;比如某渠道用户转化率/留存低，考虑ROI，减少渠道投放或者修改投放内容。&lt;/li&gt;
&lt;li&gt;用户体验不佳，更新版本，进行abtest&lt;/li&gt;
&lt;li&gt;老用户流失，调查问卷进一步优化+挽回&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（当然，这是比较模板式的解答，面试官可能会觉得没有亮点~&lt;/p&gt;
&lt;h2 id=&#34;复合类指标gmv&#34;&gt;复合类指标——GMV&lt;/h2&gt;
&lt;p&gt;GMV 下降，如何拆解分析？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;gmv = 访客数 * 转化率 * 订单均价&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进行&lt;strong&gt;指标拆解&lt;/strong&gt;，随后按照单一指标分析，拆解为以下三个指标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;访客数：分析同单一指标，定位具体用户群体问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;转化率：&lt;strong&gt;漏斗分析&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户从点开APP到最终完成购买的过程中经历了那些步骤，分析每个子环节所产生的用户流失率，从而定位到具体子环节的功能或者界面等问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比如拆解为：广告点击、商品浏览、放入购物车、交易成功，检查每一步转化率是否有显著变化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;订单均价：考虑政府政策，市场价格等外部因素&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;真题思路&#34;&gt;真题思路&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;抖音日活下降20%，如何分析？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1）20% 过大，暗示需要确定数据的准确性。（2）问题拆解，从用户、产品、运营、内容四个角度进行了分析，然后继续细分各个维度，在用户角度可以拆分处不同入口、不同时间段等指标，对这些指标进行详细的计算和分析，我们便知道是否其影响了日活的变化。外部因素主要从竞品，政策，社会环境三个方面进行了拆分，比如某国下架抖音APP。（3）做出假设+解决，比如①发现新用户下降多，按照渠道划分，如果发现某渠道有问题，分析是流量还是转化率低，从而定制渠道优化策略；②近期有重要产品迭代，abtest的结果表现如何。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;每年夏天北京的滴滴呼叫量增加，为什么？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;（1）明确问题，夏天北京呼叫量增加是针对春天，还是针对上海。（2）进行问题定位（套路）。（3）原因假设，&lt;strong&gt;由于是每年夏天都增加，强调周期季节因素&lt;/strong&gt;，如果分析内部原因或者突发事件显得强行。题目“夏天”暗示明显，可以分析暑期旅游人数增加，或者夏季雨天增加。（4）这里由于是增加，不需要分析改进建议，转而可以给出假设的数据支撑，比如分析原因认为：①“暑期旅游人数增加导致的”——给出用户数变化+政府游客数据；②“夏季雨天增加导致的”——给出夏季雨天数量+雨天和晴天打车人数对比，&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;618后拼多多成交量下降，分析原因并说明需要用哪些数据作支撑、、、&lt;/li&gt;
&lt;/ol&gt;
">业务题 | 指标异动问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/sql-li-jie-lei-mian-shi-ti/"" data-c="
          &lt;p&gt;sql必背问题 ：各种 join 的区别，执行顺序，on 和 where  having 的区别，笛卡尔积与效率。附近期我和花花的两场面试真题。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;sql&#34;&gt;sql&lt;/h1&gt;
&lt;h2 id=&#34;1各种-join-的区别&#34;&gt;1.各种 join 的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;inner join：返回两个表中具有匹配值的记录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;left (outer) join：返回左表中的所有记录以及右表中的匹配记录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;right (outer) join：从右表返回所有记录，并从左表返回匹配的记录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Full (outer) join：当左表或右表中存在匹配项时，返回所有记录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cross join：结果是笛卡尔积&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2执行顺序&#34;&gt;2.执行顺序&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;(5)SELECT DISTINCT TOP(&amp;lt;top_specification&amp;gt;) &amp;lt;select_list&amp;gt;                     
(1)FROM &amp;lt;left_table&amp;gt; &amp;lt;join_type&amp;gt; JOIN &amp;lt;right_table&amp;gt; ON &amp;lt;on_predicate&amp;gt;
(2)WHERE &amp;lt;where_predicate&amp;gt;
(3)GROUP BY &amp;lt;group_by_specification&amp;gt;
(4)HAVING &amp;lt;having_predicate&amp;gt;
(6)ORDER BY &amp;lt;order_by_list&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;FROM ：不论是什么join，先求笛卡尔积，生成虚拟表VT1-J1&lt;/li&gt;
&lt;li&gt;ON：对VT1-J1根据ON子句进行筛选，插入到VT1-J2&lt;/li&gt;
&lt;li&gt;JOIN：如果是outer join，要将中没有找到匹配的行，作为外部行添加进VT1-J2生成VT1-J3。&lt;/li&gt;
&lt;li&gt;WHERE：对得到的VT1进行行筛选，插入到VT2&lt;/li&gt;
&lt;li&gt;GROUP BY：将VT2中的行进行分组，生成VT3&lt;/li&gt;
&lt;li&gt;AVG/SUM/MEAN&lt;/li&gt;
&lt;li&gt;HAVING：对VT3的分组进行筛选，并将符合条件的组插入到VT4中。&lt;/li&gt;
&lt;li&gt;SELECT&lt;/li&gt;
&lt;li&gt;DISTINCT&lt;/li&gt;
&lt;li&gt;ORDER BY&lt;/li&gt;
&lt;li&gt;LIMIT, OFFSET&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里引出2个细节，比如计算班里女生的平均成绩，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;where 和 having 的区别&lt;/strong&gt;：求女生平均成绩，用 where 过滤掉男生因为其执行在求mean之前。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**having 是在 select  之前执行的步骤，不可以引用别名。**比如select mean(gpa) as &amp;quot;平均成绩&amp;quot;from... + having mean(gpa)&amp;gt;3.5 。同理 order by 可以引用别名。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3on-和-where-的区别&#34;&gt;3.on 和 where 的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;执行上的区别，见上一题。&lt;/p&gt;
&lt;p&gt;首先两个表做一个笛卡尔积，on后面的条件对该笛卡尔积做过滤形成临时表，如果没有where就直接返回结果，如果有where就对上一步的临时表再进行过滤。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行顺序差异导致的结果就是，条件放在 on/where &lt;strong&gt;返回结果集可能不一致&lt;/strong&gt;，具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在inner join 时，条件放在on中和where中，返回的结果集是相同的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但在left/right/full join时，返回的结果集可能不同。比如 left join 筛选条件为右表的某列取值，①使用on时无论左边表取值多少，左边表中的所有记录都会返回；②where是在求出笛卡尔积之后筛选，这时已经没有left join的含义，即使来自左边的记录在不满足条件时也会被筛掉，&lt;a href=&#34;https://www.cnblogs.com/Jessy/p/3525419.html&#34;&gt;具体例子见这里&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4笛卡尔积及其解决&#34;&gt;4.笛卡尔积及其解决&lt;/h2&gt;
&lt;p&gt;笛卡尔积，即集合A中元素和集合B中元素相结合的所有可能性，两张表的数据量都比较大的话，笛卡尔积会占用很大的内存空间。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select ... from table1 cross join table2;
select ... from table1, table2; --当join不用on条件时，就会返回笛卡尔积。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;延伸问题，如何避免出现庞大冗余的数据。当表与表之间的关联不是一对一的，由于笛卡尔积的乘法关系，会导致sql效率大大降低。比如使用包含大量重复值的 id 列作为on的条件——如何解决，先select distinct再join，比如有复合主键要用全。&lt;/p&gt;
&lt;p&gt;（待补充）&lt;/p&gt;
&lt;h3 id=&#34;附录-完整面试题目&#34;&gt;附录-完整面试题目&lt;/h3&gt;
&lt;p&gt;【京东健康-数据科学】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sql 各种join, left join 和 left outer join&lt;/li&gt;
&lt;li&gt;执行顺序 from on where group by having&lt;/li&gt;
&lt;li&gt;on和where的区别&lt;/li&gt;
&lt;li&gt;窗口函数应用题，简单&lt;/li&gt;
&lt;li&gt;是否用过spark / hive&lt;/li&gt;
&lt;li&gt;什么时候出现笛卡尔积，怎么避免&lt;/li&gt;
&lt;li&gt;机器学习原理：决策树的分割思想，常见损失函数，gbdt xgb区别 gbdt rf区别，梯度消失及其解决&lt;/li&gt;
&lt;li&gt;10个箱子放苹果，1~1000任给一个数都能找到k个箱子苹果数之和对应，怎么放？（二进制）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【罗森-数据分析】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;业务题：一个公司要发行一款低糖的运动饮料 ，问需要考虑哪些因素&lt;/li&gt;
&lt;li&gt;低糖的运动饮料在哪里更好卖&lt;/li&gt;
&lt;li&gt;你的优势是什么？&lt;/li&gt;
&lt;li&gt;数据分析最重要的是什么&lt;/li&gt;
&lt;li&gt;你理解的数据分析是干嘛的&lt;/li&gt;
&lt;li&gt;各种 join 的区别&lt;/li&gt;
&lt;li&gt;执行的一般逻辑&lt;/li&gt;
&lt;/ol&gt;
"> sql 概念理解题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/sql-mian-shi-ti-xi-lie-san/"" data-c="
          &lt;p&gt;24-40, 涉及RFM分类，累计问题，异常值，多行合并concat，表的加法UNOIN，having 用法补充，lead窗口函数，sql执行顺序等&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;【补充】&lt;/p&gt;
&lt;p&gt;HAVING 语法与 WHERE 语法类似，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HAVING 可以包含聚合函数&lt;/li&gt;
&lt;li&gt;HAVING 子句可以引用选择列表中显示的任意项&lt;/li&gt;
&lt;li&gt;HAVING 不可以使用聚合函数之后的别名（orderby可以）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;24rfm用户分类&#34;&gt;24.RFM用户分类&lt;/h2&gt;
&lt;p&gt;是2020年1月份某电商平台的用户行为记录表（用户编号，商品编号，产品分类编号，用户行为类型，用户活跃日期，消费金额）。&lt;/p&gt;
&lt;p&gt;RFM-最近一次消费时间间隔(R)、消费频率(F)、消费金额(M)。定义&lt;/p&gt;
&lt;p&gt;R：最近一次购买的时间到现在（1.31日）间隔&lt;/p&gt;
&lt;p&gt;F：一月购买次数&lt;/p&gt;
&lt;p&gt;M：一月购买总金额&lt;/p&gt;
&lt;p&gt;根据RFM得分制定打分规则， 比如R很小, F和M很大认为是好的用户&lt;/p&gt;
&lt;p&gt;if(分数&amp;gt;60, &amp;quot;及格&amp;quot;, &amp;quot;不及格&amp;quot;)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 计算RFM+打分
insert into t_RFM
select 用户编号,
	(case
   	when R&amp;gt;15 then 1
   	when R&amp;gt;5 and R&amp;lt;=15 then 2
   	when R&amp;lt;=5 then 3
   end) as R分,
........
.... -- FM同理
....
from 
(
  select 用户编号, 
    min(datediff(&amp;quot;2020-01-31&amp;quot;,用户活跃日期)) as R
    count(1) AS F,
    sum(购买金额) as M
  from 用户行为表
  where 用户行为类型 = &amp;quot;购买&amp;quot;
  and 用户活跃日期&amp;gt;=&amp;quot;2020-01-01&amp;quot;
  group by 用户编号
);

-- 计算平均值，并比较用户相对于平均值的高低
select 用户id,(case
            when r_type = &amp;quot;高&amp;quot; and f_type = &amp;quot;高&amp;quot; and m_type = &amp;quot;高&amp;quot; then &amp;quot;重要价值用户&amp;quot;
            when r_type = &amp;quot;高&amp;quot; and f_type = &amp;quot;低&amp;quot; and m_type = &amp;quot;高&amp;quot; then &amp;quot;重要发展用户&amp;quot;
           	when r_type = &amp;quot;低&amp;quot; and f_type = &amp;quot;高&amp;quot; and m_type = &amp;quot;高&amp;quot; then &amp;quot;重要保持用户&amp;quot;
            when r_type = &amp;quot;低&amp;quot; and f_type = &amp;quot;低&amp;quot; and m_type = &amp;quot;高&amp;quot; then &amp;quot;重要挽留用户&amp;quot;
            ...
            ...
            end
            ) as rfm分类结果
from
(
  select 用户id, 
    if(R分 &amp;gt; r_mean, &amp;quot;高&amp;quot;, &amp;quot;低&amp;quot;) as r_type,
    if(f分 &amp;gt; f_mean, &amp;quot;高&amp;quot;, &amp;quot;低&amp;quot;) as f_type,
    if(m分 &amp;gt; m_mean, &amp;quot;高&amp;quot;, &amp;quot;低&amp;quot;) as m_type,
  from 
  t_RFM t1
  left join (
    select avg(R分) r_mean,avg(f分) f_mean ,avg(m分) m_mean
    from t_RFM
  ) t2 --可以没有on的筛选条件 
) tmp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;28在职员工发放奖金&#34;&gt;28.在职员工发放奖金&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;雇员奖金表&lt;/strong&gt;是给员工发放奖金的记录：雇员编号，接收日期，奖金类型。其中奖金有3种类型：奖金类型的值是1，表示奖金金额为薪水salary的10%，奖金类型的值是2，表示奖金金额为薪水salary的20%，奖金类型的值是3，表示奖金金额为薪水salary的30%&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;雇员表&lt;/strong&gt;：编号，出生日期，名，姓，性别，雇用日期&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;薪水表&lt;/strong&gt;：编号，薪水，起始日期，结束日期（薪水变动的记录都在，最新的薪水结束日期为&#39;9999-01-01&#39;）&lt;/p&gt;
&lt;p&gt;问题：查找雇员编号、名、姓、奖金类型、对应的&lt;strong&gt;当前&lt;/strong&gt;薪水以及奖金金额。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select *, 
  (case 
    when c.奖金类型 = &amp;quot;1&amp;quot; then 0.1*当前薪水
    when c.奖金类型 = &amp;quot;2&amp;quot; then 0.3*当前薪水
    when c.奖金类型 = &amp;quot;3&amp;quot; then 0.3*当前薪水
  else null
  end) as 奖金金额
from
(
  select a.雇员编号,a.名,a.姓,b.薪水 as 当前薪水,c.奖金类型
  from 雇员表 a
  left join 薪水表 b
  on a.编号 = b.编号 and b.结束日期 = &#39;9999-01-01&#39;
  left join 奖金表 c
  on a.编号 = c.编号
) tmp
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;29-贝壳找房成交分析&#34;&gt;29. 贝壳找房—成交分析&lt;/h2&gt;
&lt;p&gt;“成交订单表”里记录了某房产平台（类似链家、贝壳等）每日房屋成交的明细。（贝壳面试题）字段“成交客源渠道”中的值是“客源角色人”、“业主线上委托”、“”表示线下渠道，其余的成交客源渠道是线上。字段“房屋用途”中的值有“住房”、”车位”、”车库”等。&lt;/p&gt;
&lt;p&gt;1．&lt;strong&gt;当月截止昨天&lt;/strong&gt;二手线上成交占比（含车位）&amp;gt;=50%的&lt;strong&gt;门店&lt;/strong&gt;可获奖；&lt;/p&gt;
&lt;p&gt;（线上成交占比=线上成交单量/总成交单量）&lt;/p&gt;
&lt;p&gt;2．符合获奖条件的门店的第1单线上成交的，&lt;strong&gt;经纪人&lt;/strong&gt;可获得800贝壳币（可以用于兑换奖金），第2单可获400贝壳币，第3单及以上可获200贝壳币，但车库不奖励（字段“房屋用途”中的值是”车位”、”车库”认为是车库）；&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;在一个连续的SQL中实现以上需求&lt;/strong&gt;，不能拆分成多个SQL，必须输出奖励发放表格字段如下（可增加）；&lt;/p&gt;
&lt;p&gt;（价格，经纪人，客源，时间，用途）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;datediff(start, end) mysql&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;datediff(end, start) hive sql / sql server&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 输出奖励发放表(输出表格中增加了3个字段，分别是：是否线上、经纪人所在门店的线上占比、该单应发的贝壳币)
select from t3.成交价........., t3.是否线上,t3.线上成交占比,
	(case 
   	when 是否获奖门店 = &amp;quot;获奖门店&amp;quot; and 线上房屋成交时间排序 = 1 then 800 --符合获奖条件的门店的第1单线上成交的，经纪人可获得800贝壳币
   	when 是否获奖门店 = &amp;quot;获奖门店&amp;quot; and 线上房屋成交时间排序 = 2 then 400
   	when 是否获奖门店 = &amp;quot;获奖门店&amp;quot; and 线上房屋成交时间排序 = 3 then 200
   else 0
   end 
   )  as 应发放贝壳币
from
(
  select 
    t1.*,t2.线上成交占比,
    (case when 成交客源渠道 in (“客源角色人”,“业主线上委托”,“”) then &amp;quot;非线上&amp;quot; else &amp;quot;线上&amp;quot; end) as 是否线上,
    row_number() over(partition by 签约经纪人门店 order by (case when (房屋用途 in (&amp;quot;车位&amp;quot;,&amp;quot;车库&amp;quot;))or(成交客源渠道 in (“客源角色人”,“业主线上委托”,“”)) then null else 签约时间) asc) as 线上房屋成交时间排序,
    (case when t2.线上成交占比&amp;lt;0.5 then &amp;quot;非获奖门店&amp;quot; else &amp;quot;获奖门店&amp;quot;) as 是否获奖门店--二手线上成交占比（含车位）&amp;gt;=50%的门店
  from 成交订单表 t1
  left join
  (
      select 
        签约经纪人门店
        count(distinct (case when 成交客源渠道 in (“客源角色人”,“业主线上委托”,“”) then null else 协议id end)) / count(distinct 协议id) as 线上成交占比
    from 成交订单表
    where datediff(d, 签约时间, getdate())&amp;gt;0 and datediff(m,签约时间, getdate()) = 0-- 当月截止昨天
    group by 签约经纪人门店;
  ) t2
  on t1.签约经纪人门店 = t2.签约经纪人门店
  where datediff(d, 签约时间, getdate())&amp;gt;0 and datediff(m, 签约时间, getdate()) = 0
) t3;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;30累计求和问题&#34;&gt;30.累计求和问题&lt;/h2&gt;
&lt;p&gt;“薪水表”中记录了员工发放的薪水。包含雇员编号，薪水、起始日期、结束日期。其中，薪水是指该雇员在起始日期到结束日期这段时间内的薪水。当前员工是指结束日期 = &#39;9999-01-01&#39;的员工。&lt;/p&gt;
&lt;p&gt;业务问题：&lt;strong&gt;按照雇员编号升序排列，查找薪水的累计和&lt;/strong&gt;（累计薪水）。其中累计薪水是前N个&lt;strong&gt;当前员工&lt;/strong&gt;( 结束日期 = &#39;9999-01-01&#39;)的薪水的累计和，其他以此类推。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 雇员编号, 薪水
	sum() over(order by 雇员编号 asc) as 累计薪水
from 薪水表
where 结束日期 = &amp;quot;9999-01-01&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;31复购用户&#34;&gt;31.复购用户&lt;/h2&gt;
&lt;p&gt;&amp;quot;课程订单表”里记录了某在线教育App的用户购买课程的信息：用户id, 购买时间, 课程类型, 消费金额。&lt;/p&gt;
&lt;p&gt;请使用sql将购买记录表中的信息，提取为复购分析表的格式，并用一条sql语句写出。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;日期&lt;/th&gt;
&lt;th&gt;当日首次购买用户数&lt;/th&gt;
&lt;th&gt;当月复购用户数&lt;/th&gt;
&lt;th&gt;次月复购用户数&lt;/th&gt;
&lt;th&gt;第三月.....&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;复购用户：如果一个用户的首次购买日期是a，且该用户在a之后的第n月内，也有购买行为，这个用户被算做第n月复购用户。&lt;/p&gt;
&lt;p&gt;datediff(m, 购买时间, 复购时间) = n：第n月复购用户&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 
 a.日期, 
 count(distinct (case when b.购买时间 is null then a.用户id else null end)) 当日首次购买用户数,
 count(distinct (case when datediff(m, b.购买时间, a.购买时间)=0 then a.用户id else null end)) as 当月复购用户数,-- b.购买时间 就是复购时间
 count(distinct (case when datediff(m, b.购买时间, a.购买时间)=1 then a.用户id else null end)) as 次月复购用户数,
 count(distinct (case when datediff(m, b.购买时间, a.购买时间)=2 then a.用户id else null end)) as 第三月复购用户数,
 .......
from 订单表 a
left join b
on a.用户id = b.用户id
and a.购买时间&amp;lt;b.购买时间
group by a.日期;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;32-金融行业实战&#34;&gt;32. 金融行业实战&lt;/h2&gt;
&lt;p&gt;下表是某金融App的原始数据表：用户id,投资金额，年龄，性别，省份，城市等等&lt;/p&gt;
&lt;p&gt;为方便后期分析，我们对数据进行分类。数据通常分为3类：用户数据、行为数据、产品数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户数据：年龄、性别、手机省份、手机城市、注册时间、用户注册终端、用户注册渠道、会员级别等&lt;/li&gt;
&lt;li&gt;最近登录数据：用户id，省份，城市，终端，ip，设备，时间&lt;/li&gt;
&lt;li&gt;活跃数据：用户id+是否...7天内...类的问题&lt;/li&gt;
&lt;li&gt;行为数据：用户id，投资金额，托管，开通日期，首次充值时间，首投时间，等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.理解数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果将该数据建立一个数据库，有哪些表，各表之间的关系是什么？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.数据整理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设该Excel数据是一个数据表（Datatable），请用SQL写出：&lt;/p&gt;
&lt;p&gt;（1）最近一次登录，各城市各有多少用户在表中？&lt;/p&gt;
&lt;p&gt;（2）“用户ID”之间的可能关系？（比如家庭成员，情侣等）【解法】&lt;strong&gt;ip地址相同但是uid不同，连接用户表看看差异&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（3）请找出数据表中的异常值，并以此阐述你如何控制数据质量并以本数据为例设计数据质量报表。&lt;/p&gt;
&lt;p&gt;【回答】&lt;/p&gt;
&lt;p&gt;1.首先分析业务流程：访问-&amp;gt;注册-&amp;gt;浏览商品-&amp;gt;充值 投资托管 ，日常登录-浏览商品&lt;/p&gt;
&lt;p&gt;各个表按照用户id链接，用户数据-行为数据-登录数据-活跃数据&lt;/p&gt;
&lt;p&gt;2.定义变量&amp;amp;赋值（mysql中不用先声明）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 除了set select 也可以：
select @变量名:= 字段名 from 表名 where 过滤语句;
select @num:=value;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- (1)
select 省份,城市,count(用户id)
from 最近登录表
group by 省份,城市
-- (2)家庭成员，情侣，特点：ip地址一致id不同，
select *
from 用户表
where 用户ID in (
  select distinct 用户id
  from 最近登录表
  group by ip地址
  having count(distinct 用户id)&amp;gt;1
);
-- (3)异常值
select 
	用户id
from 用户表
left join
(
  select 
    mean(年龄)+ 3*stdev(年龄) as 异常值2,
    mean(年龄)- 3*stdev(年龄) as 异常值1
  from 用户表
) tmp
where 年龄&amp;lt;异常值1 or 年龄&amp;gt;异常值2;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;33交易记录分析&#34;&gt;33.交易记录分析&lt;/h2&gt;
&lt;p&gt;某商场为了分析用户购买渠道。表1是用户交易记录表，记录了用户id、交易日期、交易类型和交易金额。表2是用户类型表，记录了用户支付类型（微信、支付宝、信用卡等），分别有type1、type2。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要求：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.请在 type1的用户类型中，找出总交易金额最大的用户。&lt;/p&gt;
&lt;p&gt;2.筛选每个用户的&lt;strong&gt;第2笔&lt;/strong&gt;交易记录。&lt;/p&gt;
&lt;p&gt;3.如下表：如何实现表3的数据格式？【&lt;strong&gt;group_concat&lt;/strong&gt;】&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;用户id&lt;/th&gt;
&lt;th&gt;交易日期&lt;/th&gt;
&lt;th&gt;交易类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;A1&lt;/td&gt;
&lt;td&gt;2017-06-01,2018-01-01...&lt;/td&gt;
&lt;td&gt;抽奖,游戏,.....&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- （1）总交易金额最大的用户
select t1.用户id, 总交易金额 
from 用户类型表 t1
left join 
(
  select 用户id, sum(交易金额) as 总交易金额
  from 用户交易记录表
  group by 用户id
) t2
on t1.用户id = t2.用户id
and t1.用户类型 = &amp;quot;type1&amp;quot;
order by 总交易金额
limit ,1;  -- 返回第一行记录
-- (2)每个用户的第2笔交易记录
select *
from(
  select *,row_number()over(partition by 用户id order by 交易日期 asc) as rk
	from 用户交易记录表
) tmp
where rk =2;
--（3）实现表3的数据格式
select 用户id,
  group_concat(日期) as 交易日期,
  group_concat(交易类型) as 交易类型
from 用户交易记录表
group by 用户id;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;34月消费分析&#34;&gt;34.月消费分析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;交易表&lt;/strong&gt;记录了每天交易的客户交易时间、客户号、消费类型和消费金额。其中，交易类型有两种值：消费和转账。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户表&lt;/strong&gt;记录了客户信息，包括客户号，客户名称和客户所属的银行分行号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分行表&lt;/strong&gt;记录每个分行的信息，包括分行号、分行名称及对应上级分行。&lt;/p&gt;
&lt;p&gt;【问题】该理财银行要求对客户及销售额分析报告，要求如下：&lt;/p&gt;
&lt;p&gt;1.计算2016年1-3月的消费总金额&lt;/p&gt;
&lt;p&gt;2.2016年3月消费金额&amp;gt;=1288的客户信息，及其3月内&lt;strong&gt;首次达到1288的时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3.汇总各省分行（省分行&lt;strong&gt;下属支行也需要汇总至省分行&lt;/strong&gt;）的2016年3月的总消费金额&lt;/p&gt;
&lt;p&gt;总行对应分行号=1，省分行=上级分行为1的分行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;--(1)
select 
	sum(case when 交易时间 between &amp;quot;2016-01-01&amp;quot; and &amp;quot;2016-01-31&amp;quot; then 消费金额 else 0) as 2016年1月,....
from 交易表

--(2)
select t1.客户号, t2.客户名称, 
	min(交易时间) as 首次达到1288的时间, 
	max(累计消费金额) as 总消费金额
from
(
  select 客户号, 交易时间,
    sum(消费金额) over (partition by 客户号 order by 交易时间 asc) as 累计消费金额
  from 交易表
  where 交易时间 between &amp;quot;2016-03-01&amp;quot; and &amp;quot;2016-03-31&amp;quot;
  order by 客户号, 累计消费金额 asc
) t1
left join 客户表 t2 on t1.客户号 = t2.客户号
where t1.累计消费金额&amp;gt;1288
group by t1.客户号；

-- （3）交易表-客户号-分行号-分行表
-- 傻逼题目
select 分行号, sum(消费金额) as 客户总消费
from 客户表 t1
left join 交易表 t2
on t1.客户号 = t2.客户号
where t2.交易时间 between &amp;quot;2016-03-01&amp;quot; and &amp;quot;2016-03-31&amp;quot;
group by 分行号;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;36中位数&#34;&gt;36.中位数&lt;/h2&gt;
&lt;p&gt;成绩表：用户编号，岗位，成绩&lt;/p&gt;
&lt;p&gt;问题：写一个sql语句查询每个岗位的成绩中位数位置&lt;strong&gt;的范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;C++岗位的中位数位置范围为[2,2]，也就是2。因为C++岗位总共3个人，是奇数，所以中位数位置为2。Java岗位的中位数位置范围为[1,2]。因为Java岗位总共2个人，是偶数，所以要知道中位数，需要知道2个位置的数字，而因为只有2个人，所以中位数位置为[1,2]。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;求余数： % 或者 mod&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 岗位
    (case when 人数%2=0 then 人数/2 else (人数-1)/2)as 起始位置,
    (case when 人数%2=0 then 人数/2+1 else (人数+1)/2)as 终止位置
from
(
 select 岗位,
   count(用户编号) as 人数,
 from 成绩表
 group by 岗位
) tmp;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;37平均薪水&#34;&gt;37.平均薪水&lt;/h2&gt;
&lt;p&gt;薪水表中记录了员工的编号，所在部门编号，和薪水。查询出每个部门除去最高、最低薪水后的平均薪水，并&lt;strong&gt;保留整数&lt;/strong&gt;。（字节跳动面试题）&lt;/p&gt;
&lt;p&gt;保留整数：&lt;strong&gt;format(数字, 小数位数)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 部门编号, format(avg(薪水),0) as 平均薪水
from
(
select *,
	dense_rank() over(partition by 部门编号 order by 薪水 desc) as rk1
	dense_rank() over(partition by 部门编号 order by 薪水 asc) as rk2
from 薪水表
) tmp
where rk1&amp;gt;1 and rk2&amp;gt;2
group by 部门编号;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;38课程续费分析&#34;&gt;38.课程续费分析&lt;/h2&gt;
&lt;p&gt;新学员购买50节课为一个学习阶段，学习完想要进入下个阶段必须再次购买，即续费（假设所有学员只能续费一次）并且每个学员可选择不同老师进行学习。表一：学员上课表，表二：续费表&lt;/p&gt;
&lt;p&gt;1.现求出续费学员在续费前3个月内的总课量，3个月给学员上课老师数量&lt;/p&gt;
&lt;p&gt;2.现求出每个续费学员在续费前的最后一节课的时间，以及对应的上课老师。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;--(1)
select 学员id , count(上课时间) as 总课量, count distinct(老师id) as 老师数
from 学院上课表 t1 
left join 购买表 t2
on t1.学生id = t2.学生id
and t2.订单类型 = 2
and datediff(m, t2.续费时间, t1.上课时间)&amp;lt;3 --续费前3个月内
group by 学员id;
--（2）
select 学员id ,上课时间, 老师id
from
(
select 学员id ,上课时间, 老师id, row_number()over(partition by 学员id order by 上课时间) as rk
from 学院上课表 t1 
left join 购买表 t2
on t1.学生id = t2.学生id
and t2.订单类型 = 2
and datediff(d, t2.续费时间, t1.上课时间)&amp;gt;0 --在续费之前
group by 学员id
) tmp
where rk = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;39小红书用户行为&#34;&gt;39.小红书用户行为&lt;/h2&gt;
&lt;p&gt;用户订单表：记录用户id、购买的商品id、用户下单的时间及商品的种类。&lt;/p&gt;
&lt;p&gt;用户收藏商品表：记录用户id、用户收藏的商品id及收藏时间。&lt;/p&gt;
&lt;p&gt;问题：请用一句sql语句得出以下查询结果，得到所有用户的商品行为特征，其中用户行为分类为4种：已购买、购买未收藏、收藏未购买、收藏且购买。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;(
select t1.用户id, t1.商品id
	1 as &amp;quot;已购买&amp;quot;
	(case when t2.商品id is null then 1 else 0 end) as &amp;quot;购买未收藏&amp;quot;
	0 as &amp;quot;收藏未购买&amp;quot;
	(case when t2.商品id is not null then 1 else 0 end) as &amp;quot;收藏且购买&amp;quot;
from 
(
  select distinct 用户id, 商品id
  from 用户订单表
  group by 用户id, 商品id
) t1
left join 
(
  select distinct 用户id, 商品id
  from 用户收藏表
  group by 用户id, 商品id
) t2
on t1.用户id = t2.用户id and t1.商品id = t2.商品id
order by t1.用户id
)
-- 上面是所有购买的，考虑是否有过收藏
union 
-- 下面补充没购买的，但是有收藏的
(
select  t2.用户id, t2.商品id
	0  as &amp;quot;已购买&amp;quot;
	0 as &amp;quot;购买未收藏&amp;quot;
	1  as &amp;quot;收藏未购买&amp;quot;
	0 &amp;quot;收藏且购买&amp;quot;
from 
(
  select distinct 用户id, 商品id
  from 用户订单表
  group by 用户id, 商品id
) t1
right join 
(
  select distinct 用户id, 商品id
  from 用户收藏表
  group by 用户id, 商品id
) t2
on t1.用户id = t2.用户id and t1.商品id = t2.商品id
order by t1.用户id
where t1.用户id is null -- 未购买
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;40连续得分的球员&#34;&gt;40.连续得分的球员&lt;/h2&gt;
&lt;p&gt;两只篮球队进行了激烈的比赛，比分交替上升。比赛结束后，你有一张两队分数的明细表：球队、球员号码、球员姓名、得分分数以及得分时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：每个球队里为该球队连续三次（及以上）得分的球员&lt;/p&gt;
&lt;p&gt;窗口函数  **lead(想查询的列, 向下n行)**over (....)，一般用于计算差值，例如：&lt;/p&gt;
&lt;p&gt;1）计算花费时间。例如：某数据是每个用户浏览网页的时间记录，将记录的时间错位之后，进行两列相减就可以得到每个用户浏览每个网页实际花费的时间。&lt;/p&gt;
&lt;p&gt;2）计算与上次相比薪水涨幅。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 首先按照球队和得分时间排序，再找到连续出现三次的球员姓名
-- 用一个lead作窗口函数就可以解决
select distinct 球员姓名
from
(
  select 球员姓名,
       lead(球员姓名,1) over(partition by 球队 order by 得分时间) as 姓名1,
       lead(球员姓名,2) over(partition by 球队 order by 得分时间) as 姓名2
	from 分数表
) tmp
where 球员姓名 = 姓名1 and 姓名1 = 姓名2;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【补充】&lt;strong&gt;SQL运行顺序&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;from join on where group by  avg/sum having select distinct order by&lt;/p&gt;
">sql面试题系列（三）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/yue-du-or-20212-qi-xing-bie-shi-jie-de-can-chai/"" data-c="
          &lt;p&gt;2月是想谈恋爱的2月，刚读完的这几本书或多或少都涉及亲密关系&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;她身之欲&#34;&gt;《她身之欲》&lt;/h3&gt;
&lt;p&gt;1.女性的欲望表达常常会突破既存的道德、性别等社会规范，带来颠覆和逾越的力量。&lt;/p&gt;
&lt;p&gt;2.性工作者用性劳动换取金钱报酬，这表面上看起来如同合同工作一样是相互的、平等的，但实际上双方的这种权力关系只是被掩盖起来了。性是不能从个人身上分离出来的，被交换的不是性劳动本身，而是一种权力关系——控制权。从更广阔的意义上说，也是被压迫的工人。&lt;/p&gt;
&lt;p&gt;3.社会主义女性主义把女性压迫归结于男权压迫（机会不平等，比如获得教育途径有限）与阶级压迫的共同作用，认为妓女是这个社会系统的受害者。当剥削的经济制度消失、性别不平等问题解决后，娼妓就会随之消失。&lt;/p&gt;
&lt;p&gt;4.“男人就是觉得打女人很正常”。爱和暴力本身就是一体两面，暴力不代表不爱，恰恰可能越暴力越爱，爱也不代表不暴力，可能爱就是暴力。哪里有软弱，哪里就有谎言。暴力以爱的名义出现，女人们要么忍受，要么用自己的方式还击。&lt;/p&gt;
&lt;p&gt;5.如果我们要批判娼妓制度，指责其是对女性的剥削，那么我们不如把矛头转向婚姻制度。恩格斯指出，一夫一妻制度在男权社会中实质上就是一种合法化了的卖淫行为，相当于丈夫一次性买断妻子的性服务。在很多情况下，对女性的剥削与压迫并非发生在人人唾弃的卖淫制度中，而是人们最习以为常和不愿相信的婚姻家庭领域。&lt;/p&gt;
&lt;p&gt;6.进入性产业的主要驱动力（总结）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物质利益、成为现代化/都市化主体（表面上的）&lt;/li&gt;
&lt;li&gt;成为性主体的欲望：性欲望和情感欲望。性欲望：尝试别种亲密关系，感受身体的愉悦等。情感欲望：挣脱传统性别角色定位，保有生活中的安全感，有选择或者重新选择的机会。（实质上的）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;“性工作者”，是道德败坏好逸恶劳？是父权社会的受害者？抑或是合法劳动力？没有一个确切的答案，而我更倾向于社会主义女性主义者的观点。关于女权与女拳，女权是女性作为弱势群体联合起来争取权利的力量，这种联合代表着同仇敌忾，有革命友谊的味道。但有时候，也会忽视差异化的诉求，有危险演变为另一种集体暴力。希望理解每个人对女权主义有不同的定义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;单恋&#34;&gt;《单恋》&lt;/h3&gt;
&lt;p&gt;这一切都是我的自我满足，是我一个人的相扑游戏。永远的单恋，这对我来说也很重要，某些东西，明明知道没有意义，但依然很在意——谁都会有这样的东西。&lt;/p&gt;
&lt;p&gt;不能剥夺她们想解放自我的权利。可悲的是当今的社会满是关于男人该如何女人又该如何的规矩。外貌上也是，讨厌大而圆的乳房也情有可原。我认为不存在性别认同障碍这样的疾病，该治疗的是想消灭少数派的社会。…人类总是惧怕未知事物，因为恐惧，就要想办法消灭它。&lt;/p&gt;
&lt;p&gt;要证明女人和男人一样能干，可能还要花相当长的时间——不是女人胜过男人的个别事件，而是当男人输给女人也不觉得羞耻的时候。&lt;/p&gt;
&lt;h3 id=&#34;亲密关系这本书不大对口味看不下去只读了前15&#34;&gt;《亲密关系》（这本书不大对口味，看不下去只读了前1/5）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;工具性特质：自信、独立、有抱负、领导力、果敢&lt;/li&gt;
&lt;li&gt;表达性特质：温柔、热情、有同情心、敏感、仁慈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实际上，两性对亲密关系的期望差异很小，都希望自己的亲密伴侣富有爱心和温情。即使性别角色的刻板印象限制了我们的潜能，甚至有时候还是错误的，但它仍将持续地存在。今天，我们仍期望和鼓励男人具有工具性，女人具有表达性。这些性别角色期望正是使亲密关系变得错综复杂的重要原因。&lt;/p&gt;
&lt;p&gt;自我感觉良好有益身心健康。我们人类是高度社会化的动物，如果他人不喜欢我们，我们要喜欢自己非常困难。我们都需要在与他人的联系和自我保护间保持平衡，但低自尊的人总把他们脆弱的自尊心置于亲密关系之上。低自尊的人有时低估伴侣对他们的爱。&lt;/p&gt;
&lt;h3 id=&#34;被讨厌的勇气&#34;&gt;《被讨厌的勇气》&lt;/h3&gt;
&lt;p&gt;当人能够感觉到“与这个人在一起可以无拘无束”的时候，才能够体会到爱，既没有自卑感也不必炫耀优越性，能够保持一种平和而自然的状态，真正的爱应该是这样的。&lt;/p&gt;
&lt;p&gt;如果是因为你的反对就能崩塌的关系，那么这种关系从一开始就没有必要缔结，由自己主动舍弃也无所谓。活在害怕关系破裂的恐惧之中，那是为他人而活的一种不自由的生活方式。&lt;/p&gt;
&lt;p&gt;你现在无法体会到幸福，因为你不爱你自己，而且为了能够爱自己，你希望“变成别人”。因为很怕别他人否定，害怕被别人轻视或拒绝，害怕心灵受伤，认为与其陷入那种窘境不如 一开始就不与任何人有关联。还可以以此为借口安慰自己：因为我有这样的缺点才会遭人拒绝，只要我没有这个缺点也会很讨人喜欢。&lt;/p&gt;
">月读 | 2021.2期，性别，世界的参差</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/jie-zhi-kuai-le-gai-bian-de-yong-qi/"" data-c="
          &lt;p&gt;负面情绪也不是一蹴而就，逃避换来的不过是自我欺骗的谎言。就像在被掩埋的骸骨之上种花种树，只要看到花看到树，心里想的确是那骸骨。努力让一切看起来”没问题“，不如对自己诚实些，找找负面情绪的来源积极应对。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;价值与快乐&#34;&gt;价值与快乐&lt;/h1&gt;
&lt;p&gt;“作为朋友我的价值是什么，真的会有人很需要我吗？”&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1614181129281.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;今天有些闷闷不乐，打开备忘录打算记录情绪时，突然发现上一条还是在去年。三个月过去了，在寻找这个问题答案的道路上，我依旧是停滞不前。负面情绪也不是一蹴而就，逃避换来的不过是自我欺骗的谎言。就像在被掩埋的骸骨之上种花种树，只要看到花看到树，心里想的确是那骸骨。努力让一切看起来”没问题“，不如对自己诚实些，找找负面情绪的来源积极应对。&lt;/p&gt;
&lt;p&gt;快乐到底来自什么？幻想一辈子打游戏可以吗。这个问题，或许我也算是身边朋友之中最拥有发言权的人了。花费了一整年的时间，我才慢慢看清。对我来说，游戏的快乐一方面来自逗乐朋友自己也开心，另一方面来自逃避现了实压力，仿佛把握着自由的人生，在游戏世界享受成功享受夸赞。而尝试真正长期放纵游戏或者段子，一段时间之后突然发觉已经坠入深渊。&lt;/p&gt;
&lt;p&gt;真正的快乐来自感受到的自我价值，我会因为获得让朋友开心而满意，因为获得别人肯定获得表扬而感到喜悦，就是感受到了自己有价值，想想这便是生活的spark吧。&lt;/p&gt;
&lt;h1 id=&#34;价值与勇气&#34;&gt;价值与勇气&lt;/h1&gt;
&lt;p&gt;为什么我常常讨厌自己，讨厌我的懦弱，讨厌我的脆弱，讨厌我的懒惰，讨厌很多很多。可要我列出自己值得喜欢的点，我似乎根本看不到。经常挂在嘴边的，就是”谁都不愿意和这样的我做朋友/谈恋爱吧？“。这样厌恶自己的答案不过是自我保护，躲在安全区里的自我安慰。隐含在其中的，还有一层以自我为中心。&lt;/p&gt;
&lt;p&gt;你说安于现状也没事，放轻松一些，不谈恋爱也没事，单身有朋友也可以很开心，不努力也没事，养活自己就行。但我还是觉得，这不过是躺在舒适区里缺少了那获得幸福的勇气。年初读到王小波说，“生活方式像一个曲折漫长的故事，或者像一座使人迷失的迷宫。很不幸的是，任何一种负面的生活都能产生很多烂七八糟的细节，使它变得蛮有趣的。人就在这种趣味中沉沦下去，从根本上忘记了这种生活需要改进。&#39;&#39;就像虽然我们心底清楚，我们是因为无法获得理想中的爱情而被迫单身，却仍然不愿积极面对，偏要装作主动单身的模样。&lt;/p&gt;
&lt;p&gt;怎么样才能获得改变的勇气？只有感受到自己的价值才能获得勇气。就像今晚读的书里谈到，”把对自己的执着转变为对他人的关心帮助，从而拥有我对他人有用的贡献感，而获得贡献感的常见手段就是寻求他人认可。”当然，一旦我们追求”被他人认可“，我们不得不失去自由去按照他人的期望生活。&lt;/p&gt;
">价值、快乐、改变的勇气</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/fei-mi-wen-ti/"" data-c="
          &lt;p&gt;第一篇，就谈谈我也没想到人生中第一次面试就被问到的费米问题，主要涉及的分析方法为逻辑树拆解。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;费米问题&#34;&gt;费米问题&lt;/h1&gt;
&lt;h2 id=&#34;1什么是费米问题&#34;&gt;1.什么是费米问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;估算出星巴克一个月的销售额&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;北京地铁口一家煎饼摊一年的收入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;今年的新生儿出生数量？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;估算全市有多少辆公交车？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;北京市有多少个加油站？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些问题乍一看懵逼，如果学会从一些角度分析并解释清楚你的逻辑思路，应该会给面试加分。涉及思考方式：供需关系、收入分析、空间分析，逻辑树拆解，上下界分析。&lt;/p&gt;
&lt;h2 id=&#34;2前置知识&#34;&gt;2.前置知识&lt;/h2&gt;
&lt;p&gt;常用数据:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;城市&lt;/th&gt;
&lt;th&gt;人口&lt;/th&gt;
&lt;th&gt;面积&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;北京&lt;/td&gt;
&lt;td&gt;2100w&lt;/td&gt;
&lt;td&gt;16000平方千米&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;上海&lt;/td&gt;
&lt;td&gt;2400w&lt;/td&gt;
&lt;td&gt;6300&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;3实例分析加油站数经典&#34;&gt;3.实例分析——加油站数（经典）&lt;/h2&gt;
&lt;h3 id=&#34;31-供需关系&#34;&gt;3.1 供需关系&lt;/h3&gt;
&lt;p&gt;题目要求北京有多少加油站。从需求端考虑，北京有多少车辆需要加油？从供给端考虑，所有的加油站能给多少车辆加油？接着利用逻辑树分析方法进行问题拆解。&lt;/p&gt;
&lt;p&gt;需求端：北京每天需要加油次数 = 300w辆车/10（假设300w辆车，平均每台车每10天加一次油）&lt;/p&gt;
&lt;p&gt;供给端：北京每天提供的加油次数 = 加油站数量 * 每个加油站每日加油次数 =  营业14小时 / 5分钟加油 * 50%利用率 * 2个加油桩 * &lt;strong&gt;加油站数&lt;/strong&gt;（假设加一次油5分钟，一个加油站两个加油桩，利用率50%，每天营业14小时）&lt;/p&gt;
&lt;p&gt;从而利于&lt;strong&gt;供需平衡&lt;/strong&gt;建立等式，其中包含待求参数，从而求出加油站数量。车辆总数可以利用政府公开数据得到，也可以进行估计：车辆数量 = 2100w人口 / 3人之家 * 50%车辆拥有率。&lt;/p&gt;
&lt;h3 id=&#34;32-收入分析&#34;&gt;3.2 收入分析&lt;/h3&gt;
&lt;p&gt;&lt;u&gt;一个加油站月收入&lt;/u&gt; = 500万辆车 / 每月3次 / &lt;strong&gt;加油站数&lt;/strong&gt; * 200元&lt;/p&gt;
&lt;p&gt;一个加油站的工资支出 =&lt;u&gt;一个加油站月收入&lt;/u&gt; * 10% 的毛利率 * 50%工资占比&lt;/p&gt;
&lt;p&gt;​                                       = 每个加油站5名员工 * 5000月薪&lt;/p&gt;
&lt;p&gt;从而建立方程式，其中包含待求参数，从而求出加油站数量。&lt;/p&gt;
&lt;h2 id=&#34;4实例分析煎饼摊收入&#34;&gt;4.实例分析——煎饼摊收入&lt;/h2&gt;
&lt;h3 id=&#34;41-逻辑树拆解&#34;&gt;4.1 逻辑树拆解&lt;/h3&gt;
&lt;p&gt;直接逻辑树拆解，比如一个地铁口的煎饼摊一年收入 = 365天 * 每天卖出煎饼量 * 每个煎饼8元  =  365天 * 单价8元 * 每天工作8个小时（比如早7-10，中午12-1，晚上6-9)  * 每小时12个煎饼(假设 每5分钟卖出一个煎饼，一个小时卖出12个）&lt;/p&gt;
&lt;h3 id=&#34;42-确定上下限方法&#34;&gt;4.2 确定上下限方法&lt;/h3&gt;
&lt;p&gt;【上限】煎饼是一个需要现做现卖的商品。制作一个煎饼大约需要30秒，也就是说，在供不应求的情况下，每小时能售出120个，一天就是 8 *120个（供给分析）&lt;/p&gt;
&lt;p&gt;【下限】煎饼摊不缴纳税收，不负担房租，要维持煎饼摊的存在**，煎饼摊的毛利润应当大于等于摊主一个人在北京的生活成本**；那么假定一个人在北京的生活成本为每天150元，煎饼毛利润3元，则平均每天最少售出50个煎饼才能维持煎饼摊。（最低收入分析）&lt;/p&gt;
&lt;h3 id=&#34;43-补充考虑&#34;&gt;4.3 补充考虑&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;多久售出一个煎饼需要&lt;strong&gt;分时段观察采样&lt;/strong&gt;。煎饼通常在早餐时段售出，其他时间考虑分开计算，比如考虑早餐时段可以认为收入=上限。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果煎饼摊开在住宅区&lt;/strong&gt;，节假日的需求应当与工作日相仿。&lt;strong&gt;如果在通勤地铁口&lt;/strong&gt;，节假日的销售另行计算。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5实例分析星巴克月销售额&#34;&gt;5.实例分析——星巴克月销售额&lt;/h2&gt;
&lt;h3 id=&#34;高峰期供给分析&#34;&gt;高峰期——供给分析&lt;/h3&gt;
&lt;p&gt;一家星巴克通常营业时间7-22点共15小时，通常一人收银两个人制作，假设点单时间0.5min，每杯饮品制作5min，客单价35元。首先考虑工作日和周末的销售差异，假定&lt;strong&gt;星巴克周末全天高峰期，在供不应求的情况下，收入接近最大供给时的情况&lt;/strong&gt;（供给分析）。每天按最大供给计算的收入上限为 = 15小时营业 * 每小时两人一起制作20 杯 * 每杯均价35元 = 10500元。&lt;/p&gt;
&lt;h3 id=&#34;闲时需求分析&#34;&gt;闲时——需求分析&lt;/h3&gt;
&lt;p&gt;工作日客流高峰期为中午和晚上，将&lt;strong&gt;营业时间15小时划分为高峰期4小时+闲时11小时&lt;/strong&gt;。其中高峰期按照上面供给分析计算，等于4小时 * 20杯 * 35 = 2800。假定闲时每10分钟一个客人，则闲时收入 = 11小时 * 每小时 6位客人 * 客单价 35元 = 2310元。则工作日期间的总收入 = 5110元。&lt;/p&gt;
&lt;p&gt;最后，假定一个月8天周末22天工作日，即可算出每月卖出饮品收入。进一步考虑，星巴克产品不止咖啡饮品，还包括蛋糕+杯子+咖啡豆。假定这些非饮品销售额占营业额5%，可求出所有产品总收入 = 饮品收入/饮品收入占比0.95。&lt;/p&gt;
">业务题 | 费米问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/sql-mian-shi-ti-xi-lie-er/"" data-c="
          &lt;p&gt;涉及单一和关联子查询，日期格式化等处理，排名top20%，滴滴真题、电商真题等。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;13红包领取情况&#34;&gt;13.红包领取情况&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【题目】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“用户活跃表”记录了用户的登录信息，包括用户标识、用户登录日期，以及是否是新用户（如果是新注册的用户值为1；如果是老用户，值为0）。&lt;/p&gt;
&lt;p&gt;“领取红包表”里记录了用户领取红包的信息，包括抢红包日期、抢红包时间、用户ID、领取红包金额。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在业务部门需要分析出以下问题：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.计算2019年6月1日至今，每日DAU（活跃用户是指有登陆的用户）&lt;/p&gt;
&lt;p&gt;2.分析每天领取红包的用户数、人均领取金额、人均领取次数，要考虑用户属性及领取红包未登录情况。&lt;/p&gt;
&lt;p&gt;3.分析每个月按领红包取天数为1、2、3……30、31天区分，计算取每个月领取红包的用户数，人均领取金额，人均领取次数。&lt;/p&gt;
&lt;p&gt;4.分析每个月领过红包用户和未领红包用户的数量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 1.
select login_date, count(用户id)
from 用户活跃表
where login_date &amp;gt; 20190601
group by login_date;

-- 2.
select a.抢红包日期,
	count(distinct a.用户id) 领取红包的用户数,
	count(distinct (case when b.用户 = 1 then a.用户id else null end)) 领取红包的新用户数,
	count(distinct (case when b.用户 = 0 then a.用户id else null end)) 领取红包的新用户数,
	count(distinct (case when b.登录日期 is null then a.用户id else null end)) 领取红包的未登录用户数,
	sum(a.领取红包金额) / count(distinct a.用户id),
	count(a.*) / count(distinct a.用户id)
from 领取红包表 a 
left join 用户活跃表 b 
on a.用户id = b.用户id
and a.抢红包日期 = b.登录日期
group by a.抢红包日期;

-- 3.
select month(抢红包日期) as 月份,
  count(distinct 抢红包日期) as 领取天数,
  count(distinct 用户ID) as 每个月领取红包的用户数,
  sum(金额)/count(distinct 用户ID), as 人均领取金额,
  count(*)/count(distinct 用户ID) as 人均领取次数
from 领取红包表
group by month(抢红包日期);

-- 4.每个月领过红包用户和未领红包用户的数量
select count(t2.用户id) ,
	count(t1.用户id) - 
from 
(
    select month(抢红包日期) as 月份，distinct 用户id
    from 用户活跃表
    group by month(抢红包日期), 用户id
) t1
left join
(
    select month(抢红包日期) as 月份，distinct 用户id
    from 抢红包表
    group by month(抢红包日期), 用户id
) t2
on t1.用户id = t2.用户id
and t1.月份 = t2.月份
group by t1.月份;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;14查找前20&#34;&gt;14.查找前20%&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【题目】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户访问次数表，列名包括用户编号、用户类型、访问量。要求在剔除访问次数前20%的用户后，每类用户的平均访问次数。（拼多多、网易面试题）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 用户类型, avg(访问量) 
from(
  select *,
    row_number()over(order by 访问量 desc) rk
  from 用户访问次数表
) tmp
-- where rk &amp;gt; max(rk)*0.2 -- 错误原因：max()不是数值！需要select再做计算
where rk &amp;gt; (select max(rk) from tmp) * 0.2
group by 用户类型;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;15查找前三名&#34;&gt;15.查找前三名&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【题目】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“成绩表”记录了学生的学号，课程，成绩。为了对学生成绩进行考核，现需要查询每门课程的前3高成绩。注意：如果出现并列第一的情况，则同为第一名。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 学号，课程，成绩
from
(
  select *, dense_rank()over(partition by 课程 order by 成绩 desc) as rk
  from 成绩表
) as tmp
where rk &amp;lt;=3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;16用户登录表&#34;&gt;16.用户登录表&lt;/h2&gt;
&lt;p&gt;现有用户登录时间表——id，姓名，邮箱地址和用户最后登录时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：生成一张临时表（表名：用户登录表），表中呈现四列数据分别为：姓名，最后登录时间，个人登录时间排名&lt;sub&gt;row_number，个人登录日期排名（同一天登录多次算一次&lt;/sub&gt;dense_rank）&lt;/p&gt;
&lt;p&gt;考点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Row_number碰到相同数据时，排名按照记录集中记录的顺序依次递增&lt;/li&gt;
&lt;li&gt;Dense_rank：所有相同数据的排名都是一样的，并且连续。&lt;/li&gt;
&lt;li&gt;Rank：相同数据的排名是一样的，同时会在最后一条相同记录和下一条不同记录的排名之间&lt;strong&gt;空出排名&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 姓名,最后登录时间,
       row_number() over (partition by 姓名
                          order by 最后登录时间 asc) as 登录时间排名,
       dense_rank() over (partition by 姓名
                          order by date_format( 最后登录时间,&#39;%Y%m&amp;amp;d&#39; ) asc) as 登录天数排名
from  用户登录表;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;【题目】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下表是双十一客户购买清单表（客户id，购买时间，商品名称，金额）。双十一当天，商家为每位客户购买的第一个商品免单，请找出商品名称，客户姓名及购买金额。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 客户id，商品名称，金额
(select *,
	row_number() over(partition by 客户id order by 购买时间 asc) as rk
 from 双十一客户购买清单表
 where 购买时间 is &amp;quot;2020-11-11&amp;quot; 
) tmp
where rk=1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;17分组比较子查询&#34;&gt;17.分组比较，子查询&lt;/h2&gt;
&lt;p&gt;现在有三个表，“学生表”，“课程表”，“成绩表”。&lt;/p&gt;
&lt;p&gt;“学生表”记录了学生的基本信息，有“学号”、“姓名”、“出生日期”、“性别”。“成绩表”记录了学生选修课程的成绩，包括“学号”，选修的“课程号”以及对应课程的“成绩”。“课程表”记录了学生选修的课程信息，包括课程号、课程及其对应的“老师号”。“学生表”和“成绩表”通过“学号”联结，“成绩表”和“课程表”通过“课程编号”联结。&lt;/p&gt;
&lt;p&gt;现在要查找出每门课程中成绩最好的学生的姓名和该学生的课程及成绩。&lt;/p&gt;
&lt;p&gt;需要注意：可能出现并列第一的情况。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 解答1
select a.课程,b.学号,b.成绩,c.姓名
from 课程表 a
left join
(
  select * , rank() over(partition by 课程号 order by 成绩 desc) as 排名
  from 成绩表
) as b
on a.课程号 = b.课程号
left join 学生表 c
on b.学号 = c.学号
and b.排名=1;

-- 解答2
select b.课程,a.学号,a.成绩,c.姓名
from 成绩表 a 
left join 课程表 b on a.课程号 = b.课程号
left join 学生表 c on a.学号 = c.学号
where (a.课程号, a.成绩) in ( -- 注意这种写法，比较陌生但好用
	select 课程号, max(成绩)
	from 课程表
	group by 课程号
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;【举一反三】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有两个表，Employee 表用于记录员工的薪水和在哪个部门，包括员工的Id、员工的姓名（Name）、薪水（Salary） 和 员工所在部门Id（Department Id）。Department 表用于记录公司所有部门的信息，包括部门Id，部门名称（Name）。&lt;/p&gt;
&lt;p&gt;1.找出每个部门工资最高的员工&lt;/p&gt;
&lt;p&gt;2.检索工资大于部门平均工资的员工信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 1：单一值的子查询 ~in
select t1.名称, t2.员工姓名,t2.薪水
from Department t1
left join Employee t2
on t1.部门Id = t2.部门Id
where (t2.部门Id, t2.薪水) in (
  select 部门Id, max(薪水)
  from Employee 
  group by 部门Id
)

-- 2；关联子查询
select t1.员工姓名,t1.薪水
from Employee t1
where 薪水 &amp;gt; 
(
  select avg(薪水)
  from Employee
  where 部门Id = t1.部门Id  -- 子查询和父查询用where关联
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;子查询：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;多行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单一值：in any all between&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在每个组里比较（&lt;strong&gt;关联子查询&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;19滴滴2020年笔试题&#34;&gt;19.滴滴2020年笔试题&lt;/h1&gt;
&lt;p&gt;“订单信息表”里记录了巴西乘客使用打车软件的信息，包括订单id，乘客id，订单呼叫、接单、取消、完单时间。（滴滴2020年笔试题）&lt;/p&gt;
&lt;p&gt;（1）表中的时间是北京时间，巴西比中国慢11小时。&lt;/p&gt;
&lt;p&gt;（2）应答时间列的数据值如果是“1971”年，表示该订单&lt;strong&gt;没有司机应答&lt;/strong&gt;，属于无效订单。&lt;/p&gt;
&lt;p&gt;应答率 = 呼叫订单中被应答的比例&lt;/p&gt;
&lt;p&gt;完单率= 呼叫订单中完单的比例&lt;/p&gt;
&lt;p&gt;呼叫应答时间=  被应答订单的，从呼叫到应答的平均时长&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;订单的应答率，完单率分别是多少？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;呼叫应答时间有多长？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从这一周的数据来看，呼叫量最高的是哪一个小时（当地时间）？呼叫量最少的是哪一个小时（当地时间）？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;呼叫订单第二天继续呼叫的比例有多少？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（选做）如果要对乘客进行分类，你认为需要参考哪一些因素？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;日期处理函数总结&#34;&gt;日期处理函数总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;cast+datetime：e.g. cast(&amp;quot;2020-01-01 8:00&amp;quot; as datetime)，可以搭配update 表 set 新列 = cast(旧列 as 格式)&lt;/li&gt;
&lt;li&gt;date_format：日期数据格式化，如date_format(call_time,&#39;%k&#39;) &lt;em&gt;%k表示提取24小时制中的小时数值&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;date_sub：从日期减去指定的时间间隔，如date_sub(date, interval 10 day) 表示减去10天之后&lt;/li&gt;
&lt;li&gt;timestampdiff：计算两个日期的差值，timestampdiff(unit, begin, end)，unit可以是second,minute, hour, day, week, month, year等等&lt;/li&gt;
&lt;li&gt;curdate():获取当前时间，取最近一周的数据用date&amp;gt;date_sub(curdate(), interval 7 day)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解答&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 预处理
update 订单信息表
set  应答时间 = date_sub(cast(&amp;quot;应答时间&amp;quot; as datetime),
                     interval -11 hour) ; -- 应答时间列处理为巴西时间，其他列同理

-- 1.应答率，完单率
select 
	sum(case when 应答时间=1970 then 0 else 1) / count(订单呼叫) as 应答率,
	sum(case when 完单时间=1970 then 0 else 1) / count(订单呼叫) as 完单率
from 订单信息表;

-- 2.呼叫平均应答时间
select avg(timestampdiff(minute, 呼叫时间,应答时间)) as 呼叫平均应答时间
from 订单信息表
where 应答时间 &amp;lt;&amp;gt; 1970;

-- 3.呼叫量最高的是哪个小时（注意七天用datesub interval -11hour处理为巴西时间）
select date_format(呼叫时间,&amp;quot;%k&amp;quot;) as 小时,
	count(呼叫时间) as 每小时呼叫量
from 订单信息表
where 呼叫时间 &amp;gt; date_sub(curdate(), interval 7 day) -- 最近7天内
group by 小时
order by desc;

-- 4.第二天继续呼叫的比例
select t1.呼叫时间,
	count(distinct t2.用户id) / count(distinct t1.用户id)
from 订单信息表 t1
left join 订单信息表 t2
on t1.用户id = t2.用户id
and timestampdiff(d,t1.呼叫时间, t2.呼叫时间) = 1
group by t1.呼叫时间
-- 注意不做SELECT DISTINCT直接JOIN会产生笛卡尔积
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5.乘客分类方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户行为分类&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​		1) 根据完成时间和接单时间，判断长途/中途/短途，分析乘车习惯。&lt;/p&gt;
&lt;p&gt;​		2) 根据呼叫时间可以判断乘客是在时间点发单的，&lt;strong&gt;乘客需求是如何产生的&lt;/strong&gt;，可分析用户在哪些场景有乘车需求，上班、下班、就餐、出游、临时等场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;用户价值分类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;利用RFM模型，具体定义：&lt;/p&gt;
&lt;p&gt;R：最近一次乘客的完单时间。&lt;/p&gt;
&lt;p&gt;F：乘客打车的频率。&lt;/p&gt;
&lt;p&gt;M：打车消费的金额。此处可以用乘车过程消耗的时长来代替等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;20电商销量分析&#34;&gt;20.电商销量分析&lt;/h1&gt;
&lt;p&gt;某公司在不同的电商平台上都有店铺，下面是该公司的&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzAxMTMwNTMxMQ==&amp;amp;mid=2649248480&amp;amp;idx=1&amp;amp;sn=a33d035eb7ff20c742eb8b7f4be75b58&amp;amp;chksm=835fdad0b42853c6a419e7df84f598fad8b5af911faf70f786e9562d92f74060494366f4e570&amp;amp;cur_album_id=1398781984763428865&amp;amp;scene=189#rd&#34;&gt;销售数据表&lt;/a&gt;(每个表有一行示例数据)。略&lt;/p&gt;
&lt;p&gt;问题1.对于指定品类号范围（品类号列表：12，33，45，99，1001），查询2019年每个电商平台上每个品牌号对应每个品类号的累计销售额&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select a.品牌号,c.品牌名, a.品类号,b.品类名,a.电商平台,sum(销售额)
from 月销售统计表 a
left join 品类表 b
on a.品类号 = b.品类号 
left join 品牌表 c
on a.品牌号 = c.品牌号
where 品类号 in (12, 33, 45, 99, 1001)
and year(月份)=2019;
group by a.电商平台, a.品牌号, a.品类号,a.电商平台
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;问题2:查询2019年有5个以上(含5个)不同品类号的&lt;strong&gt;单月单平台&lt;/strong&gt;销售额大于等于10000的&lt;strong&gt;品牌列表&lt;/strong&gt;，及对应的不同品类号数量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 品牌名 count(distinct (case when 销售额 &amp;gt;= 10000 then 品类号 else null))  as 品类数
from 月销售统计表 a 
left join 品牌表 b 
on a.品牌号 = b.品牌号
where year(月份) = 2019
group by a.品牌号
having count(distinct (case when 销售额 &amp;gt;= 10000 then 品类号 else null))  &amp;gt;= 5;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;问题3:查询2019年只在平台1上有销售额的&lt;strong&gt;品牌&lt;/strong&gt;中，累计销售额最大的Top30个品牌及对应的销售额&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 筛选放入子查询
select 品牌号, sum(销售额) as 总销售额
from 月销售统计表
where year(月份) = 2019 
and 品牌号 in (
    select 品牌号, sum(销售额) as 总销售额
    from 月销售统计表
    where year(月份) = 2019 and 平台 = &amp;quot;平台2&amp;quot;
    group by 品牌号
    having 总销售额=0
  )
group by 品牌号
order by 总销售额 desc 
limit 30;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;问题4:查询2019年在两个电商平台中分别&lt;strong&gt;同时都能进入销售额Top 50&lt;/strong&gt;的品牌及对应的全电商平台累计销售额&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 品牌号, sum(总销售额)
from(
	select 
    平台,品牌号,总销售额
    dense_rank() over(partition by 平台 order by 总销售额 desc) 销量排名
  from(
    select 品牌号, 平台, sum(销售额) as 总销售额
    from 月销售统计表
    where year(月份) = 2019
    group by 品牌号,平台
  ) tmp
) tmp2
where 销量排名 &amp;lt;=50
group by 品牌号
having count(平台)=2;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;21滴滴业务统计&#34;&gt;21.滴滴业务统计&lt;/h1&gt;
&lt;p&gt;现有四张表，分别是“司机数据”表，“订单数据”表，“在线时长数据”表，“城市匹配数据”表。（滴滴面试题）&lt;/p&gt;
&lt;p&gt;业务问题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分析出2020年8月&lt;strong&gt;各城市每天&lt;/strong&gt;的司机数、快车订单量和快车流水数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select
	c.城市名,
	a.日期,
	count(distinct a.司机id) as 司机数,
	count(a.订单id) as 快车订单量,
	sum(a.流水) as 快车流水数据
from 订单数据 a
inner join 司机数据 b on a.司机id = b.司机id 
and a.日期 between &amp;quot;2020-08-01&amp;quot; and &amp;quot;2020-08-31&amp;quot;
and a.产品线id = 3
inner join 城市匹配数据 c on b.城市id = c.城市id
group by c.城市名, a.日期;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;提取2020年&lt;strong&gt;8月和9月&lt;/strong&gt;，每个月的北京市&lt;strong&gt;新老司机&lt;/strong&gt;（首单日期在当月为新司机）的司机数、在线时长和TPH（订单量/在线时长）数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- （看错题意了）group by 新老司机
select 月份, 新老司机,
	count(新老司机),
	sum(在线时长),
	sum(订单量) / sum(在线时长）
(
	select month(b.订单日期) as 月份,a.司机id,b.订单量,c.在线时长
    （case 
        when month(a.首单日期) = month(b.订单日期) then &amp;quot;新司机&amp;quot;
        when month(a.首单日期) &amp;lt; month(b.订单日期) then &amp;quot;老司机&amp;quot;
      else null
      end) as &amp;quot;新老司机&amp;quot;
  from 司机数据 a 
  left join
  (
    select month(订单日期) as 月份, 司机id, count(订单id) as 订单量
    from 订单数据
    where (订单日期 between &amp;quot;2020-08-01&amp;quot; and &amp;quot;2020-09-30&amp;quot;)
    group by month(订单日期), 司机id
  ) b
  on a.司机id = b.司机id 
  on a.月份 = b.月份
  and a.城市id = 1000000 -- 北京市
  left join
  （
    select month(订单日期) as 月份, 司机id, count(在线时长) as 在线时长
    from 订单数据
    where 订单日期 between &amp;quot;2020-08-01&amp;quot; and &amp;quot;2020-09-30&amp;quot;
    group by month(订单日期), 司机id
  ） c
  on a.司机id = c.司机id
  and a.月份 = c.月份
) tmp
group by 月份, 新老司机;


-- 标准解答，t1计算新老司机数，t2计算在线时间, t3计算tph，然后join
select 
t1.*,t2.订单量,t3.在线时长,(t2.订单量/t3.在线时长) TPH
from
(
  select 
  t.城市id,
  month(t.日期) 月份,
  sum(if(新老司机=&#39;新司机&#39;,1,0)) 新司机数,
  sum(if(新老司机=&#39;老司机&#39;,1,0)) 老司机数
  from 
  (
    select
    a.*,
    if(date_format(日期,&#39;%y-%m&#39;)=DATE_FORMAT(首次完成订单时间,&#39;%y-%m&#39;),&#39;新司机&#39;,&#39;老司机&#39;) 新老司机
    from 司机数据 a
  ) t
  where (t.日期 BETWEEN &#39;2020-08-01&#39; and &#39;2020-09-30&#39; ) and t.城市id=100000
	group by month(t.日期)
) t1

left join 
   (
     select 
     	b.城市id,
      month(b.日期) 月份,
      count(a.订单id) 订单量
      from 订单数据 a 
      left join 司机数据 b
      on a.司机id=b.司机id
      where (b.日期 BETWEEN &#39;2020-08-01&#39; and &#39;2020-09-30&#39;) and b.城市id=100000
      group by month(a.日期)
    ) t2

on t1.城市id=t2.城市id and t1.月份=t2.月份
left join 
    (
      select 
      b.城市id,
      month(b.日期) 月份,
      sum(a.在线时长) 在线时长
      from 在线时长数据 a 
      left join 司机数据 b
      on a.司机id=b.司机id
      where (b.日期 BETWEEN &#39;2020-08-01&#39; and &#39;2020-09-30&#39;) and b.城市id=100000
      group by month(a.日期)
) t3
on t1.城市id=t3.城市id and t1.月份=t3.月份
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;分别提取司机数大于20，司机总在线时长大于2小时，订单量大于1，乘客数大于1的&lt;strong&gt;城市名称&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 计算每个城市司机数和总在线时长和订单量和乘客数
select t1.城市名称
from 城市匹配数据 t1
left join 
(
  select a.城市id, 
    count(distinct a.司机id)  司机数,
    sum(c.在线时长) 司机总在线时长,
    count(b.订单id) 订单量,
    count(distinct a.乘客id) 乘客数
  from 司机数据 a
  inner join 订单数据 b
  on a.司机id=b.司机id
  inner join 在线时长 c
  on c.司机id=c.司机id
  group by a.城市id
  having count(distinct a.司机id)&amp;gt;20 and sum(c.在线时长)&amp;gt;2 and count(b.订单id) &amp;gt;1 and count(distinct a.乘客id) &amp;gt;1
) t2
on t1.城市id = t2.城市id;
&lt;/code&gt;&lt;/pre&gt;
">sql面试题系列（二）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/sql_0218/"" data-c="
          &lt;p&gt;5~12题，涉及连续登录、行列互换、多表链接、留存率分析等&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;5查找不在表里的数据&#34;&gt;5.查找“不在表里的数据”&lt;/h2&gt;
&lt;p&gt;【题目】&lt;/p&gt;
&lt;p&gt;下面是学生的名单，表名为“学生表”；近视学生的名单，表名为“近视学生表”。请问不是近视眼的学生都有谁？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select t1.id, t1.name
from xueshengbiao t1
left join jinshibiao t2
on t1.id = t2.id 
where t2.id is null;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6薪水涨幅升序&#34;&gt;6.薪水涨幅升序&lt;/h2&gt;
&lt;p&gt;【题目】&lt;/p&gt;
&lt;p&gt;“雇员表“中记录了员工的信息，“薪水表“中记录了对应员工发放的薪水。两表通过“雇员编号”关联。查找当前所有雇员入职以来的薪水涨幅，给出雇员编号以及其对应的薪水涨幅，并按照薪水涨幅进行升序。&lt;br&gt;
（注：薪水表中结束日期为2004-01-01的才是当前员工，否则是已离职员工）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 1.我的回答
select a.*, ifnull(b. 涨薪,0) as 涨薪金额
from guyuan a
left join (
select t1.id, t1.endtime, t2.endtime as 离职时间, t1.salary-t2.salary as 涨薪
from xinshui t1, xinshui t2
where t1.id = t2.id
	and t2.starttime = t1.endtime
) b
on a.id = b.id
where b.离职时间=&amp;quot;2004-01-01&amp;quot;
order by b.涨薪金额;
-- 问题在于如果涨薪不止一次，就会出现bug

-- 2.标准答案，要限定原始薪水取入职时的数值
select t3.*, t1.当前薪水-t2.入职薪水 as 涨薪金额
from(
	select id, salary as 当前薪水
	from 薪水表
	where 结束日期=&amp;quot;2004-01-01&amp;quot;
) t1  
left join 
(
	select a.*，b.salary as 入职薪水
	from 雇员表 a,  
	left join 薪水表 b  
	on a.id = b.id -- 复合连接条件
	and a.雇佣日期=b.起始时间
) t2
on t1.id = t2.id
left join 雇员表 t3
on t1.id = t3.id
order by 涨薪金额 desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;7日期对比交叉连接&#34;&gt;7.日期对比，交叉连接&lt;/h2&gt;
&lt;p&gt;下面是某公司每天的营业额，表名为“日销”。“日期”这一列的数据类型是日期类型（date）.请找出所有比前一天（昨天）营业额更高的数据。（前一天的意思，如果“当天”是1月，“昨天”（前一天）就是1号）.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 我的答案，隐式连接
select t2.*
from 日销表 t1, 日销表 t2
where t1.id = t2.id,
and t2.date - t1.date = 1
and t2. revenue &amp;gt; t1. revenue

-- 标准答案，交叉连接（返回所有两两组合）
select t2.*
from 日销表 t1 
cross join 日销表 t2
on datediff(t2.date, t1.date) = 1
where t2.revenue &amp;gt; t1.revenue;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;8最小的n个数&#34;&gt;8.最小的n个数&lt;/h2&gt;
&lt;p&gt;【滴滴2020年面试题】“学生表”里记录了学生的学号、入学时间等信息。“成绩表”里是学生选课成绩的信息。两个表中的学号一一对应。&lt;/p&gt;
&lt;p&gt;现在需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;筛选出2017年入学的“计算机”专业年龄最小的3位同学名单（姓名、年龄）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统计每个班同学各科成绩平均分大于80分的人数和人数占比&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 第一问 easy
select 姓名, 年龄
from 学生表
where 入学时间 = &amp;quot;2017&amp;quot;
and 专业 = &amp;quot;计算机&amp;quot;
order by 年龄 asc  -- asc desc
limit 3;  -- limit a, b 跳过前a行，显示a+1到a+b行

-- 第二问
select 班级,
	sum(大于八十)as 人数, 
	avg(大于八十) as 占比
from(
	select t1.*, (case when t2.平均成绩&amp;gt;80 then 1 else 0 end) as 大于八十 
	from 学生表 t1
	left join
	(
		select 学号, avg(分数) as 平均成绩
		from 成绩表
		group by 学号
	) t2
	on t1.学号=t2.学号
) tmp
group by 班级;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关键点：有筛选条件的统计数量问题的万能模板&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select sum(
case when &amp;lt;判断表达式&amp;gt; then 1
       else 0
end
) as 数量
from 信息表；

-- 备注如果是按照某一列的取值对另一列计算
case col1 when &amp;lt;判断表达式&amp;gt; then col2...
	else col2...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;9行列互换问题&#34;&gt;9.行列互换问题&lt;/h2&gt;
&lt;p&gt;长变宽&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 年,
	sum(case 月 when &#39;1&#39; then 值 else 0 end) as &#39;m1&#39;,
	sum(case 月 when &#39;2&#39; then 值 else 0 end) as &#39;m2&#39;,
	sum(case 月 when &#39;3&#39; then 值 else 0 end) as &#39;m3&#39;,
	sum(case 月 when &#39;4&#39; then 值 else 0 end) as &#39;m4&#39;
from 长表
group by 年;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【题目】&lt;/p&gt;
&lt;p&gt;学生的成绩表(表名：成绩表，列名：学号，课程，成绩)，转化为表结构列名：学号，语文成绩，数学成绩）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 学号,
	sum(case 课程 when &amp;quot;语文&amp;quot; then 成绩 else 0) as 语文成绩,
	sum(case 课程 when &amp;quot;数学&amp;quot; then 成绩 else 0) as 数学成绩
from 成绩表
group by 学号;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;10连续出现n次的内容&#34;&gt;10.连续出现N次的内容&lt;/h2&gt;
&lt;p&gt;【题目】&lt;/p&gt;
&lt;p&gt;下面是学生的成绩表（表名score，列名：学号、成绩），使用SQL查找所有按照学号顺序排列，至少连续出现3次的成绩数值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select distinct t1.score
from score t1, score t2, score t3
where t2.id - t2.id = 1 
	and t3.id - t2.id = 1
	and t1.score = t2.score
	and t2.score = t3.score
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;查询连续登录的用户&#34;&gt;查询连续登录的用户&lt;/h2&gt;
&lt;p&gt;【复杂应用：&lt;strong&gt;&lt;mark&gt;连续登录三天以上的用户&lt;/mark&gt;&lt;/strong&gt;】除了隐式连接的方法，还可以利用窗口函数，更灵巧的解答。&lt;/p&gt;
&lt;p&gt;表名：table_A （ 用户userid和登录时间time）&lt;/p&gt;
&lt;p&gt;1）查询出最近7天的活跃用户，并对用户活跃日期进行排名（窗口函数dense_rank）&lt;/p&gt;
&lt;p&gt;2）计算用户活跃日期及排名之间的差值（如果连续登录，差值相同）&lt;/p&gt;
&lt;p&gt;3）对同用户及差值分组，统计差值个数&lt;/p&gt;
&lt;p&gt;4）将差值相同个数大于等于3的数据取出，即为连续3天及以上活跃的用户&lt;/p&gt;
&lt;p&gt;注意：&lt;strong&gt;去重&lt;/strong&gt;（考虑到一天内多次登录）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;datediff(d, day1, day2 ) = day2 -day1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;date_sub(login_date, interval x day)&lt;/strong&gt; = login_date - xdays&lt;/p&gt;
&lt;p&gt;回答：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select count(distinct userid) 
from
(
	select userid, count(login_date) as logdays
	from
	(
		select distinct userid, login_date, -- 去重
			dense_rank() over (partition by userid order by time) as rk
		from table_a
		where datediff(d, login_date, getdate())&amp;lt;=7    -- 查询近七天里所有数据
		group by userid, login_date
	)  as tmp1
	group by userid,date_sub(login_date, interval tmp1.rk day)   -- 登录日期-排序
)  as tmp2
where logdays &amp;gt;= 3;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;11-留存率分析&#34;&gt;11. 留存率分析&lt;/h2&gt;
&lt;h3 id=&#34;111-指标定义&#34;&gt;11.1 指标定义：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;某日活跃用户数，某日活跃的去重用户数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;N日活跃用户数，某日活跃的用户数在之后的第N日活跃用户数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;N日活跃留存率，N日留存用户数/某日活跃用户数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出结果按照每天来汇总&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 每天的活跃用户数
select login_date,
	count(distinct user_id) as 活跃用户数
from user
where login_date between&amp;quot;2021-01-01&amp;quot; and &amp;quot;2021-02-01&amp;quot;
group by login_date;

-- 次日留存率
select u1.login_date,  -- 日期
	count(distinct u2.user_id), -- 次日留存
	count(distinct u2.user_id) / count(distinct u1.user_id)   -- 次日留存率
from user u1
left join user u2 
on u1.user_id = u2.user_id
and u1.login_date between &amp;quot;2021-01-01&amp;quot; and &amp;quot;2021-02-01&amp;quot; 
and datediff(u1.login_date, u2.login_date) = 1
group by u1.login_date;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;112-输出次日-三日-七日留存数和留存率&#34;&gt;11.2 输出次日、三日、七日留存数和留存率&lt;/h3&gt;
&lt;p&gt;同时输出次日、三日、七日留存数和留存率？——先算时间间隔，再利用casewhen来做不同的count&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 只有一张登录表：
select u1.login_date,
	count (distinct case when by_days = 1 then u2.user_id else null end)) as 次日留存数
	count (distinct case when by_days = 1 then u2.user_id else null end)) / count(distinct u1.user_id) as 次日留存率
	count (distinct case when by_days = 3 then u2.user_id else null end)) as 三日留存数
	count (distinct case when by_days = 3 then u2.user_id else null end)) / count(distinct u1.user_id) as 三日留存率
	count (distinct case when by_days = 7 then u2.user_id else null end)) as 七日留存数
	count (distinct case when by_days = 7 then u2.user_id else null end)) / count(distinct u1.user_id) as 七日留存率
from
(
  select u1.user_id, u2.user_id, u1.login_date
    datediff(d, u1.login_date, u2.login_date) as by_days
  from user u1
  left join user u2
  on u1.user_id = u2.user_id
  and u1.login_date between &amp;quot;2021-01-01&amp;quot; and &amp;quot;2021-02-01&amp;quot; 
) as tmp
group by u1.login_date;
-- 有登录表（login_log）和 注册用户表(user_info)时把自连接换成两个表user_info left join login_log即可
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;113-真题&#34;&gt;11.3 真题&lt;/h3&gt;
&lt;p&gt;链家2018春招笔试面试：现有订单表和用户表，格式字段如下图：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;订单表&lt;/th&gt;
&lt;th&gt;时间&lt;/th&gt;
&lt;th&gt;订单id&lt;/th&gt;
&lt;th&gt;商品id&lt;/th&gt;
&lt;th&gt;用户id&lt;/th&gt;
&lt;th&gt;订单金额&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;用户表&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;用户id&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;姓名&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;性别&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;年龄&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;****&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;1.查询2019年Q1季度，不同性别，不同年龄的成交用户数，成交量及成交金额&lt;/p&gt;
&lt;p&gt;2.2019年Q1季度产生订单的用户数，以及在次月的留存用户数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;-- 分组统计
select u.gender, u.age,
	count(distinct o.用户id) as 成交用户数,
	count(o.订单id) as 成交量,
	sum(o.订单金额) as 成交金额
from 订单表 o
inner join 用户表 u -- 用户数据可能有缺失，所以要innerjoin
on u.用户id = o.用户id
and o.时间 between &amp;quot;2019-01-01&amp;quot; and &amp;quot;2019-03-31&amp;quot;
group by u.gender, u.age;

-- 留存&amp;amp;次月留存
-- 错误回答：（错误原因：对每个用户购买的次月时间是不同的）
select count(distinct o1.用户id) ,
	count(distinct o2.用户id) / count(distinct o1.用户id) 
from 订单表 o1
left join 订单表 o2
on o1.时间 between &amp;quot;2019-01-01&amp;quot; and &amp;quot;2019-03-31&amp;quot;
and o2.时间 between &amp;quot;2019-04-01&amp;quot; and &amp;quot;2019-04-30&amp;quot;;
-- 正确回答：
select count(distinct o1.userid) as Q1季度产生订单的用户
	count(distinct o2.userid) as 这些用户的次月留存率
from 订单表 o1
left join  订单表 o2
on o1.userid = o2.userid
and o1.时间 between &amp;quot;2019-01-01&amp;quot; and &amp;quot;2019-03-31&amp;quot;
where datediff(m, o1.时间, o2.时间) = 1;-- 时间间隔一个月
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;12用户满意度分析用or的多表联结&#34;&gt;12.用户满意度分析（用or的多表联结）&lt;/h2&gt;
&lt;p&gt;【题目】&lt;/p&gt;
&lt;p&gt;“满意度表”记录了教师和学生对课程的满意程度，包括教师编号、学生编号、和是否满意三列。&lt;/p&gt;
&lt;p&gt;“ 用户表”记录了学校教师和学生的信息，包括三列：每个用户有唯一键 “编号”，“是否在系统”表示这个用户是否还在这所学校里，“角色”表示这个人是学生还是教师。&lt;/p&gt;
&lt;p&gt;现在需要分析出学校里人员对课程的满意度。满意度的计算方式如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(对课程都满意且已存在当前教务系统中的用户) / (在学校里的人数)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select sum(case when 是否满意 is &amp;quot;满意&amp;quot; then 1 else 0) / count(是否满意)
from 满意度表
left join 用户表
on (满意度表.教师id =  用户表.id or 满意度表.学生id =  用户表.id)
where 是否在系统 is TRUE;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;【题目】&lt;/p&gt;
&lt;p&gt;Users 表里存放的是用户信息。一共三列：每个用户有唯一值（Users_Id） 。Banned 表示用户是否因为违规被禁止使用app。Role 记录了用户的角色，里面的值driver是司机，client是乘客，partner是合伙人。&lt;/p&gt;
&lt;p&gt;Trips 表记录了各个出租车的行程信息。每段行程有唯一键（Id），还有Client_Id 、 Driver_Id，Status 列表示行程类型（ ‘completed’表行程正常结束, ‘cancelled_by_driver’ 表示行程因为司机原因取消，‘cancelled_by_client’表示行程因为乘客原因取消），还有request_at 订单时间列。&lt;/p&gt;
&lt;p&gt;两个表的联结关系：Trips 表（Client_Id 、 Driver_Id） 和 Users 表中 Users_Id 的联结。  写一段 SQL 语句查出非禁止用户的取消率。&lt;/p&gt;
&lt;p&gt;取消率的计算方式如下：(被司机或乘客取消的非禁止用户生成的订单数量) / (非禁止用户生成的订单总数)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select trips.request_at as 日期, 
 -- count(distinct (case when Status = &amp;quot;cancelled_by_driver&amp;quot; then trips.id else full end))/count(distinct trips.id) as 当日取消率
 sum(if(trips.status = &#39;completed&#39;,0,1)) / count(trips.status) -- 算订单数量，所以没有重复问题
from Trips 
left join Users 
on (trips.Client_Id  = Users.Users_Id or trips.Driver_Id  = Users.Users_Id)
and Users.Banned = &amp;quot;no&amp;quot;
group by trips.request_at;
&lt;/code&gt;&lt;/pre&gt;
">sql面试题系列（一）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/zai-kan-or-20211/"" data-c="
          &lt;p&gt;听说隔段时间重读一本书，如果能有新的感受，证明这些年没有白吃饭，原来我们都在慢慢长大。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;书&#34;&gt;书&lt;/h1&gt;
&lt;h3 id=&#34;爱你就像爱生命&#34;&gt;《爱你就像爱生命》&lt;/h3&gt;
&lt;p&gt;我真的不知怎么才能和你亲近起来，你好像是一个可望不可即的目标，我捉摸不透，追也追不上，就坐下哭了起来。&lt;/p&gt;
&lt;p&gt;我把我整个的灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。&lt;/p&gt;
&lt;p&gt;美也是无穷的，可怜的就是人的生命、人的活力是有穷的。可惜我看不到无穷的一切。但是我知道它存在，我向往它。我会老也会死，势必有一天我也会衰老得无力进取的。可是我不怕。在什么事物消失之前，我们先要让它存在啊。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1611467239306.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;有关贫穷&#34;&gt;《有关贫穷》&lt;/h3&gt;
&lt;p&gt;如果说贫穷是种生活方式，拣垃圾和挑大粪只是这种方式的契机。生活方式像一个曲折漫长的故事，或者像一座使人迷失的迷宫。很不幸的是，任何一种负面的生活都能产生很多烂七八糟的细节，使它变得蛮有趣的。人就在这种趣味中沉沦下去，从根本上忘记了这种生活需要改进。&lt;/p&gt;
&lt;p&gt;要是一辈子都这么兴冲冲地弄一堆垃圾、一桶屎，最后自己也会变成一堆垃圾，一桶屎。所以总要想出些办法，别和垃圾、大粪直接打交道才对。&lt;/p&gt;
&lt;h3 id=&#34;一半是火焰一半是海水&#34;&gt;《一半是火焰，一半是海水》&lt;/h3&gt;
&lt;p&gt;“你是学文科的学生？”&lt;br&gt;
“你怎么知道？”&lt;br&gt;
“很简单，丑姑娘才去学理工。”&lt;/p&gt;
&lt;p&gt;我不爱她，不爱任何人。“爱”这个字眼在我看来太可笑了，尽管我也常把它挂在嘴边，那不过是象说“屁”一样顺口。&lt;/p&gt;
&lt;h3 id=&#34;过把瘾就死&#34;&gt;《过把瘾就死》&lt;/h3&gt;
&lt;p&gt;就像童话中两个贪心人挖地下的财宝，结果挖出一个人的骸骨，虽然迅速埋上了，甚至在上面种了树，栽了花，但两个人心里都清楚地知道底下埋的是什么，看见树，看见花，想的却是地下的那具骸骨。&lt;/p&gt;
&lt;p&gt;就是蠢，就是愚昧，因为我爱你。&lt;/p&gt;
&lt;h3 id=&#34;为什么我们总在逃避&#34;&gt;《为什么我们总在逃避》&lt;/h3&gt;
&lt;p&gt;苛刻的超我。那些深感羞耻的人通常拥有一个极其蛮横（与非常完美主义）的超我，不完美的代价便是攻击——自我憎恨，十分蛮横地否定自己。内心再次涌现的羞耻感令人痛苦难当，又因随之而来的自我厌恶而使一切变得更糟糕。受羞耻感困扰的人很难面对自身的需求，他们会认为有欲望是可耻的的。因为绝觉得自己有缺陷，没有价值，所以这些人会无力经营亲密关系，或者进进入一种虐待式关系。&lt;/p&gt;
&lt;p&gt;不再努力让一切看起来都“没问题”。你能改变到什么程度，取决于你对自己会有多诚实，你有多熟练甄别出内在的谎言。真正的成长是学会接纳防御层出不穷的特质，接纳我们不间断的自我欺骗。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1611467277980.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;用户数据挖掘&#34;&gt;《用户数据挖掘》&lt;/h3&gt;
&lt;p&gt;这书真挺无聊的，干脆把核心内容总结了一下：&lt;/p&gt;
&lt;p&gt;用户标签分类&lt;br&gt;
1.统计类，性别、年龄、城市、近七日活跃时长或天数（from注册数据、访问数据）&lt;br&gt;
2.规则类，自己定义的，类似近期活跃定义为“30天内交易次数&amp;gt;2”&lt;br&gt;
3.数据挖掘类，比如根据购买行为习惯判断性别&lt;/p&gt;
&lt;p&gt;用户画像的应用场景&lt;br&gt;
定位用户偏好——&amp;gt; 个性化推送，以提高点击转化率&lt;br&gt;
用户行为特征——&amp;gt; 用户流失预警&lt;br&gt;
消费偏好——&amp;gt; 精准的营销&lt;/p&gt;
&lt;h1 id=&#34;影视&#34;&gt;影视&lt;/h1&gt;
&lt;h3 id=&#34;杀死一只知更鸟&#34;&gt;《杀死一只知更鸟》&lt;/h3&gt;
&lt;p&gt;很难静下心再读一遍了，就翻出来电影看看&lt;/p&gt;
&lt;p&gt;一个人没必要把自己懂的东西都展现出来，这不是淑女的做派。再说了，人们不喜欢他们身边有什么人比他们懂得多。这会让他们气不打一处来你使用的语言再标准，也改变不了他们。除非他们自己想学，否则一点儿办法也没有，你要么闭上嘴巴，要么跟他们说一样的话。&lt;/p&gt;
&lt;h3 id=&#34;天国与地狱&#34;&gt;《天国与地狱》&lt;/h3&gt;
&lt;p&gt;话不多说，高桥一生yyds&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1611467630551.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">月读 | 2021.1期，我爱你</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/ru-he-zhun-bei-mian-shi-yi-pian-hua-bing-wen/"" data-c="
          &lt;p&gt;不能总是躲在舒适圈里，加油&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;干货篇&#34;&gt;干货篇&lt;/h1&gt;
&lt;p&gt;近几次面试总结，数分/ds岗面试看中什么&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术能力，sql面试题和逻辑；python、r基本函数和概念区分。（基础）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;业务分析逻辑（最重要）&lt;/strong&gt;，常见的拆解等分析方法、指标异动问题、费米问题、图表分析问题等等&lt;/li&gt;
&lt;li&gt;数理知识，统计学，机器学习，因果推断模型等（偏ds或者策略时会问到）&lt;/li&gt;
&lt;li&gt;过往经历，不要记流水账，重点在于难点+解决，展示出总结经验的能力（提升）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后续将会针对这些开始准备&lt;/p&gt;
&lt;h1 id=&#34;废话部分&#34;&gt;废话部分&lt;/h1&gt;
&lt;p&gt;吹头发真神奇，每次刚吹完头发我都能转困为醒。&lt;/p&gt;
&lt;p&gt;今天原本也是无聊的翻着手机等小X下班吃鸡的平平无奇的一天。吹完坐在宿舍里，脑袋清醒到总觉得自己聪明了些，于是认真想了想。既然选择要找工作，之后日子里学习应该目的性强一点，第一学期还希望多学补充各方面知识（划掉：其实就是0规划）。毕竟现在举着名校光环虽然名不副实，等真找不到工作那时全世界都确诊俺“交大废物”了，接着估计就成为大伙向学弟学妹指导就业经验时的不得不提的那个故事，甚至是一届届口口相传的失败典例。&lt;/p&gt;
&lt;p&gt;B 听完我这话说，你想多了。我心想果然，友谊真是暴雨天的一把雨伞，是黎明初升的一抹阳光温暖着悲惨的我，或许我这种废物也有匹配的垃圾工作可以干。可惜她说道，你没找到工作也没人在意的好伐！好家伙确实，谁关心你找没找到工作呢，尤其当爹妈都不在意时。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基础知识&lt;br&gt;
借鉴师兄所说，一切按照算法岗准备，这样数分也能秒杀。暂且认为这是正确的，毕竟听起来鸡蛋放在了两个篮子里（虽然目前我两个篮子都有洞）。因此我们需要积累：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法数理知识，各算法原理+对比等&lt;/li&gt;
&lt;li&gt;统计学基础知识，abtest等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面试技巧&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不要在意结果，请总结反思下自己的表现如何。&lt;/li&gt;
&lt;li&gt;积累面试问题，尤其是业务知识！！如果面试官没有给答案，记得在反问环节主动询问。&lt;/li&gt;
&lt;li&gt;讲话方式也要更有逻辑，平常可以练习整理思路回答一段完整的话，自信清晰的表达出来。&lt;/li&gt;
&lt;li&gt;项目经历要总结出两到三点项目中的难点&amp;amp;如何解决，重新整理下自己的项目经历（待完成）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
">如何准备面试，一篇画饼文</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/qing-wa/"" data-c="
          &lt;p&gt;”在你想要生活的那一刻，人生的spark就已经点亮了。”最近似乎真的很开心，能感受到自己再从低谷期慢慢爬起来，但也反省了蛮多问题。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一只目光短浅的青蛙&#34;&gt;一只目光短浅的青蛙&lt;/h2&gt;
&lt;p&gt;小羊在西二旗并列的张江高科（郊区）实习，刚入职一周每日几乎都是摸鱼度过的。每日坐在工位上打瞌睡，同事交流也不多，当然她也乐在其中。直到昨天临近任务DDL，她才慌忙点杯美式装模做样地研究工作。努力了一整天，结果倒是不错，算是得到了mentor的肯定。当然汇报之后又是继续摸鱼打发时间。&lt;/p&gt;
&lt;p&gt;没有几个人记得，小羊很容易晕车晕地铁飞机，清晨坐上巴士不敢刷手机只得靠在座位上打瞌睡。看着荒凉的窗外景色，顺便想了想很多问题。掐指一算，本命年即将到来，她粗略地算了算自己23年“奋斗“人生：小时候认真读书，是害怕名落孙山；长大后努力学习，是担心成为无业游民。新学期跟着经验看算法刷力扣，却从来不求甚解，就单纯图个面试通过。实习5天摸鱼4天，剩下1天努力写query也并非出于愧疚，只是预想到周报没话讲多尴尬。&lt;/p&gt;
&lt;p&gt;到站了，小羊同学呆滞走进早餐店，在玻璃门上看到了那只目光短浅的青蛙。“算了积极点讲，这叫活在当下“，她突然想起和小鱼去一起看的心灵奇旅里一段话，海里的小鱼想要寻找海，可能平庸生活里就是被忽视的人生意义吧。或许每个人都有自己的生活方式吧，毕竟自己也算应试教育流水线上的产品。用统计学的话说，人生志向至死也发没法找到这件事儿依概率收敛到1。“那就当我们都在海里好了！” 她心里默念着。&lt;/p&gt;
&lt;h2 id=&#34;为什么好奇怪&#34;&gt;为什么？好奇怪&lt;/h2&gt;
&lt;p&gt;最近似乎真的很开心，能感受到自己再从低谷期慢慢爬起来，但也反省了蛮多问题。现在想想我还真是一个悲观主义者吧，有人问我为什么不开心，或许我会愣住给不出回答，但总觉得少了什么，似乎还有很多想做的事，有很多能做成的事。原定周三下午有一场偏算法的面试，真真是紧张爆炸，不得已打了一上午游戏缓解焦虑。对着代码题写不出来，抑或是原理解释不清的尴尬场景已经在脑子里排演无数遍了。谁能想到我都经历过好几次面试了呢，为什么呢这好奇怪。&lt;/p&gt;
&lt;p&gt;不过我已经想到了一部分答案，从第一次面试到现在，我真的成长了吗？答案是有但也算寥寥无几。用忙碌泛泛学习来掩盖规划上的懒惰，只等着同辈推我走。有太多事情我都可以做得更好，无论是学习生活还是待人，可我没能进步就这样虚度了时光。或者换个角度，投入精力之前我该多问问自己为什么。&lt;/p&gt;
&lt;h2 id=&#34;鸡蛋里面挑骨头&#34;&gt;鸡蛋里面挑骨头&lt;/h2&gt;
&lt;p&gt;起因是h发给我p向他感叹总是被我push，暗示我太凡且卷。我们永远也不够了解世界与他人，而我总习惯性拿自己的标准套在他人身上。可能我总是期待每件事尽量都做合意，却忽略了他人的不同需求和闪光点，说难听点不就是鸡蛋里面挑骨头吗。总选择性忽略自己的问题，没有耐心地强迫别人的我真是狭隘的菜鸡。，严以律己宽以待人，提醒下最近飘忽且暴躁的自己。&lt;/p&gt;
&lt;p&gt;对了，最近每日一夸别人这件事又被我遗忘了，该复习如何做个合格朋友/同学/同事了。翻备忘录发现这一篇，当初心情非常糟糕，现在想想做他们忙碌生活里的一剂普通调味品也不错，何必自我贬低呢，并不是只有做到舔狗才值得有好朋友，只要适时付出时间或关心，甚至只要真诚就足够。&lt;/p&gt;
">一只目光短浅的青蛙</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/xie-zai-2020-nian-di/"" data-c="
          &lt;p&gt;日子真是一眨眼就过去了，如果…&lt;br&gt;
如果没有，如果不是，如果我…&lt;br&gt;
&lt;a href=&#34;https://music.163.com/#/song?id=29814898&#34;&gt;可惜没有如果&lt;/a&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;低谷期&#34;&gt;低谷期&lt;/h1&gt;
&lt;p&gt;正在经历真正意味上的人生低谷期。脆弱敏感，各种感情都被加倍放大，迷茫焦虑挣扎自我怀疑，要一直这样继续下去吗。崩溃过太多次，对着家人发火，拉黑不想回复的微信，任性地伤害了一些关心我的人，还有我自己。对了，我还欠某人一个道歉。一度觉得自己看不到光（找不到自己意义，作为朋友我的价值在哪里，真的会有人非常需要我吗，虽然现在这些问题还在摸索中）害怕面对所以不停的逃避。其实，逃到另一座城市，结局并不会改变，还是要勇敢面对。&lt;/p&gt;
&lt;p&gt;我一直一直很幸运，但是不能直接收美好的事情，却无法容忍坏事的带来。在这段漫长的低谷期，收到了很多很多很多的关心和帮助。我也慢慢发现自己需要做些事情，自救而不是等人来救我，比如接纳自己，重树信心。黑暗是常态，既然我好像也不是无可救药的废物，那么安抚心情，努力向前看叭。&lt;/p&gt;
&lt;p&gt;没什么是迈不过去的，不纠结过去了，希望2021自己能够变好一点点，认可自己多一点点。&lt;/p&gt;
&lt;h1 id=&#34;慢热&#34;&gt;慢热&lt;/h1&gt;
&lt;p&gt;来到了陌生的城市，起初忙忙碌碌却又觉得没有收获，新的生活氛围让我有些，焦虑，索性结识了新同学们给予我肯定，新室友们挺沙雕每天都有快乐分享，枯燥的学习日常有了花花和日文陪伴。日子确实挺难熬的，这一份温暖也显得弥足珍贵。这个冬天我正在过得很充实，努力稀释坏情绪。&lt;/p&gt;
&lt;p&gt;一直以来我好像都在朋友面前少了点，人情味。一直觉得更多的快乐是能够帮助到别人，而不是等待别人的救援，不过现在想想，脆弱不是什么大不了的事，一个人没法熬就别企图自己扛过去。希望可以不要嫌弃我笨拙迟钝的回应，请相信我喜欢被需要的感觉。&lt;/p&gt;
&lt;p&gt;爱上那个乐观开朗的你很容易，但是能够同样去爱，去包容那个阴暗，负面的你却很难。感谢真心实意待我的好朋友，在我所有压抑的情绪和缺点放大之后，仍然热情温柔的对待这个糟糕的我，努力带我逃离不开心。我想生活的意思，还是在于那些普通的日常，普通的我们和故事。&lt;br&gt;
&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1609399536405.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">写在2020年底</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/qi-qi-guai-guai-mian-shi-ji-lu/"" data-c="
          &lt;p&gt;今天是第一次onsite面试，一共两轮，但是和自己想象的比较不一样，是非常友善的一次面试（当然多半是我太菜了，就没有聊太多技术上的东西）&lt;/p&gt;
&lt;p&gt;首先来了一位非常可爱的小哥哥，没有什么面试压力还是很nice的（除了中间冷场了一下下😂&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;自我介绍&lt;br&gt;
学校+过往经历&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;项目介绍及其延伸&lt;br&gt;
我就讲了讲一个爬虫+正则提取特征+建模的小项目，面试官小哥哥说这个项目的流程听起来非常传统，有些像信贷违约问题。（反思下，最好把自己的项目好好的梳理一遍， 能够清晰的讲出来，我有点想到哪说哪，还没有明显侧重点）。接着他谈了谈贷违约风险预测是怎么做的，于是我全程乖巧点头。本来以为会问我建模问题，结果只了解下项目特征工程的一些细节，不涉及算法部分。（后来知道他们目前的任务不涉及这些机器学习类算法）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软件工具&lt;br&gt;
接着问了问常用的工具，我说起 python R sql 都可，本来以为他会问我代码题或者常用函数，可是他完全没有。呜呜呜昨晚刚考完生存分析，在有限的时间里我就只准备了一下代码题，结果没有被问到，好气！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;介绍工作内容，问我有什么想问的吗&lt;/p&gt;
&lt;p&gt;到这里我已经有点懵逼了，怎么突然进行到反问环节了？这竟然不是一场问答的面试，是交互型的，而我表现的挺呆，裂开。（思考了一下，可能他不想问我太多问题，是觉得目前需要的实习生不是我这类的）&lt;/p&gt;
&lt;p&gt;这部分小哥哥一直在快乐的介绍他和同事们的工作内容，大致是匹配清洗数据（有点偏NLP） -&amp;gt; 数据库 -&amp;gt; 智能定价模型。顺便他问了我知道ES数据库吗，当然不知道，又裂开。最后我了解了下定价模型的原理，就结束啦。&lt;/p&gt;
&lt;p&gt;整场面试基本都是，他讲我点头的模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来就是小哥哥的领导来面试，把这场面试变成经验座谈会了。领导大哥哥也挺善谈并且幽默的，但是他说我像一张白纸缺少经验呜呜呜。快结束的时候，反问环节我已经问不下去了（都是因为第一面问完了啊啊啊），看我问不出什么，场面一度有一点小尴尬，最后他看了很多次表急着想走哈哈哈😂。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;项目介绍&lt;br&gt;
他随便抓了一个小项目，问了问数据来源（爬虫，大概爬虫的流程，爬到了哪些变量），最后用到哪些特征建模（我大概说了下没有用内生性变量，主要用正则匹配提取信息构造变量，呜呜呜其实这个项目我忘光光了）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;职业规划&lt;br&gt;
聊了聊统计学的就业方向（分析岗、挖掘岗、算法岗），数据科学类和算法类的区别。他觉得统计学出身数理基础不错，但是coding 能力有待提升。（确实）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;团队介绍&lt;br&gt;
和第一位小哥哥说的很类似，大概意思就是，他们这里相比大厂，实习工作会相对自由&amp;amp;多样，可以增加多方面的experience。最后他感叹了下经验的重要性。。。（而我是一张白纸，他在暗示我凉了吗呜呜呜）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1608733659928.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">奇奇怪怪面试记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/hui-jia-ri-chang/"" data-c="
          &lt;!-- more --&gt;
&lt;h1 id=&#34;鸡汤&#34;&gt;鸡汤&lt;/h1&gt;
&lt;p&gt;回家第一天晚上就干了三碗老妈牌，喝鸡汤真的太太太棒了。鸡汤这种东西就真的很奇妙，虽然里面都是无用氨基酸，但真的会让你感觉被幸福包裹住，尤其是在冬天。喝完之后安心躺下睡觉，平常生物钟8点前就醒了的我，回家第二天睡到了9点。昨天在飞机上，有点晕机难受着难受着突然哭了，感觉自己心理负担有些太重了，但是又无法消解。以至于回家之后语气有点冲，让期待我的妈妈不开心了（那天妈妈喝多了，给我电话说真的好想好想我，可我回家连个想你或者抱抱都没给她，什么时候才配做妈妈的女儿）。&lt;/p&gt;
&lt;p&gt;不过今天起来，堆积好几天坏情绪好了一些吧，一是昨晚喝了鸡汤睡得香，二是因为早上剪头发遇到了帅哥，三是感觉终于有一天自己没那么紧了，虽然没有做到坦然面对坏情绪。顺便谢谢日文和花花，让我感觉自己还不是无药可救的废物。&lt;/p&gt;
&lt;h1 id=&#34;婚礼&#34;&gt;婚礼&lt;/h1&gt;
&lt;p&gt;回家的契机就是参加老哥的婚礼，不过我是单纯抱着吃狗粮的心情回家的。虽然小时候，我特别喜欢参加婚礼，但是其实理由只有两个，一是婚礼上有好看的新娘，二是有特别多好吃的，作为小孩子还能讨到喜糖吃。这么多年，我一直作为妹妹很幸运地受着大家的照顾，这次算是我成年之后参加的第一场婚礼，原来真挚的婚礼真的会让所有人感动。我和我哥其实差了四岁，所谓三年一个坎差四岁就意味我初中他高中，我高中他大学，我们都正好不能待在一所学校里读书。虽然我们一起生活的时间不多，但是我哥他在我心目中的印象都在不断革新。如今已经作为新郎承担起了家庭的责任（对我真的相信他可以）。愿有岁月可回首，且以深情共白头。新婚快乐，我的哥哥。&lt;/p&gt;
&lt;p&gt;爱情真是个好东西，起码当下看起来很幸福，对我这样目光短浅的人来说，这就够了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1608008417711.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">回家日常</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/em-suan-fa/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BC%95%E5%85%A5em%E7%AE%97%E6%B3%95&#34;&gt;引入EM算法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90&#34;&gt;一个简单的例子&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%81%87%E8%AE%BE%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93%E6%89%80%E6%9C%89%E7%9A%84%E5%8F%82%E6%95%B0&#34;&gt;1. 假设我们知道所有的参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%81%87%E8%AE%BE%E6%88%91%E4%BB%AC%E4%B8%8D%E7%9F%A5%E9%81%93%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0&#34;&gt;2. 假设我们不知道所有参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E9%B8%A1%E7%94%9F%E8%9B%8B%E8%9B%8B%E7%94%9F%E9%B8%A1%E9%97%AE%E9%A2%98&#34;&gt;3. 鸡生蛋蛋生鸡问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E5%8F%96%E7%BA%A2%E7%90%83%E9%97%AE%E9%A2%98%E7%9A%84%E6%A8%A1%E6%8B%9F&#34;&gt;4. 取红球问题的模拟&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#why-em%E7%AE%97%E6%B3%95&#34;&gt;why EM算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9&#34;&gt;算法内容&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B&#34;&gt;算法的一般流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B%E4%B8%8Bem%E7%AE%97%E6%B3%95%E7%9A%84%E6%B5%81%E7%A8%8B&#34;&gt;高斯混合模型下EM算法的流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#k%E5%9D%87%E5%80%BC%E4%B8%8Eem%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB&#34;&gt;K均值与EM算法的关系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0%E4%B8%8B%E7%95%8C%E7%9A%84%E6%8E%A8%E5%AF%BC&#34;&gt;似然函数下界的推导&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;主要内容：隐变量、EM算法的引入、一般流程、高斯混合模型的EM算法、Kmeans与EM算法关系、EM算法的推出。首先声明，本文来源于我个人理解，可能有误欢迎纠错嗷！至于写这篇的原因，只是希望通过梳理自己学到的，或许尝试输出才知道哪里没有理解。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;引入em算法&#34;&gt;引入EM算法&lt;/h1&gt;
&lt;h2 id=&#34;一个简单的例子&#34;&gt;一个简单的例子&lt;/h2&gt;
&lt;p&gt;现在有2个袋子，里面都装着红球和白球。第一步随机选择一个袋子，第二步从选出的袋子里取出一个球，记录取出的球的颜色。&lt;/p&gt;
&lt;h3 id=&#34;1-假设我们知道所有的参数&#34;&gt;1. 假设我们知道所有的参数&lt;/h3&gt;
&lt;p&gt;假设我们知道第一步中随机选到1号袋子的概率是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;π&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\pi&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;π&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，选到二号袋子的概率是&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;π&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;1-\pi&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.72777em;vertical-align:-0.08333em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;π&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，并且我们知道每个袋子里面红球和白球的比例为：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;-&lt;/th&gt;
&lt;th&gt;1号袋子&lt;/th&gt;
&lt;th&gt;二号袋子&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;红球&lt;/td&gt;
&lt;td&gt;p&lt;/td&gt;
&lt;td&gt;1-p&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;白球&lt;/td&gt;
&lt;td&gt;q&lt;/td&gt;
&lt;td&gt;1-q&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;那么我们可以根据参数计算出许多概率/条件概率，比如已知第二步取到白色球，想问它属于1号袋子的条件概率是多少？由贝叶斯公式可知：&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;p(1 | white) = \frac{p(white|1)p(1)}{p(white|1)p(1) + p(white|2)p(2)}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.363em;vertical-align:-0.936em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.427em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.936em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-假设我们不知道所有参数&#34;&gt;2. 假设我们不知道所有参数&lt;/h3&gt;
&lt;p&gt;现在我们想要估计所有的参数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;θ&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;π&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;/mrow&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\theta = {\pi, p, q}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;θ&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;π&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;（待估、未知的），定义&lt;strong&gt;隐变量&lt;/strong&gt;：表示第一步我们随机抽取的袋子是1号袋子还是2号袋子（是不可观测的），定义&lt;strong&gt;观测变量&lt;/strong&gt;：表示最后我们取出的是红球还是白球（可观测的）。从极大似然估计的角度出发怎么解决呢？假设试验独立重复n次，则似然函数为:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;Π&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;θ&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\Pi_{i} p(y_i|\theta)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;Π&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;θ&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; (全概率公式展开) = &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;Π&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;Σ&lt;/mi&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;θ&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;z&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;θ&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\Pi_{i} \Sigma_{z} p(y_i, z | \theta) p(z|\theta)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;Π&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;Σ&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.151392em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;θ&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.04398em;&#34;&gt;z&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;θ&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; = &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;Π&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;[&lt;/mo&gt;&lt;mi&gt;π&lt;/mi&gt;&lt;msup&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/msup&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/msup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;π&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mrow&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;]&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\Pi_{i} [\pi p^{y_i} (1-p)^{y_i} + (1-\pi) q^{1- y_i} (1-q)^{1- y_i} ]&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;Π&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;π&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3280857142857143em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3280857142857143em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;π&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3280857142857143em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3280857142857143em;&#34;&gt;&lt;span style=&#34;top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.143em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;参数的极大似然估计值为 =  &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;arg&lt;/mi&gt;&lt;mo&gt;⁡&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;max&lt;/mi&gt;&lt;mo&gt;⁡&lt;/mo&gt;&lt;mi&gt;θ&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;Σ&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;g&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;θ&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\arg\max\limits_{\theta} \Sigma_{i} log(p(y_i|\theta))&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.502108em;vertical-align:-0.752108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop&#34;&gt;ar&lt;span style=&#34;margin-right:0.01389em;&#34;&gt;g&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.43055999999999994em;&#34;&gt;&lt;span style=&#34;top:-2.047892em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.02778em;&#34;&gt;θ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.7em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop&#34;&gt;max&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.752108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;Σ&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;g&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;θ&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-鸡生蛋蛋生鸡问题&#34;&gt;3. 鸡生蛋蛋生鸡问题&lt;/h3&gt;
&lt;p&gt;针对这种包含隐变量的参数估计问题，我们想要解决的问题其实是“鸡生蛋蛋生鸡”的相互依赖问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题一，我们想要估计参数，首先要确定每个球到底来自哪个袋子（即确定隐变量的取值）才能写出似然函数的表达式&lt;/li&gt;
&lt;li&gt;问题二，隐变量是不可观测的，需要根据参数和观测变量来判断 Z 的取值概率（什么意思呢？比如1号袋子红球多而2号袋子白球多，当我们取到白球时可以认为该球来自2号袋子，或者说“Z=2号袋子”的概率更大）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;EM算法的求解思想认为：两个问题相互依赖，转化为一个动态求解过程。随机化给定参数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;θ&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\theta&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;θ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;初始值，根据参数初始值可以算出每个样本来自1号或者2号袋子的条件概率（E步），然后据此用极大似然调整参数估计值（M步），见下图所示。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1607933419776.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;通过不断动态迭代调整，直到满足终止条件，输出参数估计（局部最优值）&lt;/p&gt;
&lt;h3 id=&#34;4-取红球问题的模拟&#34;&gt;4. 取红球问题的模拟&lt;/h3&gt;
&lt;p&gt;假设取到一号袋子的概率是0.4，取到二号袋子的概率是0.6，一号袋子里红球比例为0.6，二号袋子里红球比例为0.4。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np

# 初始化参数
pi = 0.8; p = 0.2; q = 0.9;n = 200
theta_true = np.array([pi, p, q])
thetas = np.array([0.8 ,0.9, 0.5])

for i in range(5):
    # 1.生成观测数据
    observed_y = []
    for _ in range(n):
        bags = np.random.binomial(1, theta_true[0])
        yi= np.random.binomial(1, theta_true[1]) if bags else np.random.binomial(1, theta_true[2])
        observed_y.append(yi)
    observed_y = np.array(observed_y)

    # E步
    ai = observed_y * (thetas[0] *  thetas[1])  / (thetas[0] *  thetas[1] + (1- thetas[0]) * thetas[2] )
    ci = observed_y * (1- thetas[0]) * thetas[2] / (thetas[0] *  thetas[1] + (1- thetas[0]) * thetas[2] )
    bi = (1 - observed_y) * (thetas[0] *  (1- thetas[1])) /  (thetas[0] * (1- thetas[1]) + (1 - thetas[0] ) * (1- thetas[2]))
    di = (1 - observed_y) * ((1 - thetas[0] ) * (1- thetas[2])) /  (thetas[0] * (1- thetas[1]) + (1 - thetas[0] ) * (1- thetas[2]))
    # M步
    pi_new = np.mean(ai + bi) 
    p_new = np.sum(ai)  / np.sum(ai + bi)
    q_new = np.sum(ci)  / np.sum(ci + di)
    thetas = np.array([pi_new, p_new, q_new])
    # print
    print(&amp;quot;times: %d&amp;quot; % ( i +1))
    print(&amp;quot;π = %.3f, p = %.2f, q = %.2f&amp;quot; 
                  % (thetas[0], thetas[1], thetas[2]))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;times: 1
π = 0.564, p = 0.43, q = 0.08
times: 2
π = 0.588, p = 0.49, q = 0.10
times: 3
π = 0.603, p = 0.53, q = 0.11
times: 4
π = 0.590, p = 0.50, q = 0.10
times: 5
π = 0.598, p = 0.52, q = 0.11
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看起来结果不是很ok？如何验证呢，由大数定律可知应该有 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;π&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;π&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi&gt;q&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\pi p + (1-\pi) q = \frac{k}{n}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7777700000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;π&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;π&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.2251079999999999em;vertical-align:-0.345em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8801079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.6550000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.394em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.345em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;（观测数据中红球的比例）,最终只要我们的三个参数满足这一个方程就是合理的，可见解不唯一，主要原因是参数数&amp;gt;方程的个数，当数据更高维时就不一定是这样了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(theta_true[0] * theta_true[1] + (1-theta_true[0]) * theta_true[2],  thetas[0] * thetas[1] + (1-thetas[0]) * thetas[2])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0.3499999997 0.355
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;why-em算法&#34;&gt;why EM算法&lt;/h2&gt;
&lt;p&gt;通常情况下我们对似然函数或者对数似然求偏导，然后求出偏导=0且二阶导&amp;lt;0的极值点。然而由于隐变量的存在，我们发现这个问题复杂了起来，变成了一个非凸问题，没有全局最优解析解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何求解一个非凸问题？梯度下降、EM算法等等来求出局部最优解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;梯度下降 v.s. EM算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;梯度下降时是通用方法&lt;/li&gt;
&lt;li&gt;EM算法 不用调参 收敛 代码简单 但只适用于部分非凸问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;算法内容&#34;&gt;算法内容&lt;/h1&gt;
&lt;h2 id=&#34;算法的一般流程&#34;&gt;算法的一般流程&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1607932098398.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;高斯混合模型下em算法的流程&#34;&gt;高斯混合模型下EM算法的流程&lt;/h2&gt;
&lt;p&gt;高斯混合模型的参数估计是EM算法的一个重要应用。下面看起来很长，其实是根据EM算法一般流程进行“公式套用”哈~ 主要步骤为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写出对数似然函数&lt;/li&gt;
&lt;li&gt;E步求期望，利用全概率公式，得到隐变量取值的条件概率&lt;/li&gt;
&lt;li&gt;M步，带入E步的值，再极大化对数似然函数，更新参数估计值（其实就是对参数求极大似然估计）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1607937884554.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;k均值与em算法的关系&#34;&gt;K均值与EM算法的关系&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;联系&lt;br&gt;
K均值算法其实利用了EM算法的思想，E步时把每个点归入某类，M步时候重新计算类中心点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区别：&lt;br&gt;
EM算法的E步中，我们用上一次参数迭代值和观测值，求出观测样本的隐变量取值的条件概率。注意！我们不是每个点归入某个总体，而是给出它来自某个总体的概率值，这个概率值在0-1之间，这就做&lt;strong&gt;软分配&lt;/strong&gt;。&lt;br&gt;
而 k-means 不同于此，它把每个点直接归入某类。求隐变量取值的条件概率时候，先找出某个观测点与各中心点距离最小的那一类，直接令属于这一类概率=1，其他类=0，而不是以一定概率来自某类，这就叫做&lt;strong&gt;硬分配&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;似然函数下界的推导&#34;&gt;似然函数下界的推导&lt;/h2&gt;
&lt;p&gt;心塞之前看完立马忘光光，现在只能看着笔记本发愣，感觉有一步奇奇怪怪（裂开）&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1607933993802.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;蛮奇怪的一点，就是如何理解EM算法通过提升下界，使得对数似然函数不断提升的。下面这张图或许可以说明白：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1607933504316.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">EM算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/wo-suan-ge-shi-me/"" data-c="
          &lt;h1 id=&#34;我算个什么&#34;&gt;我算个什么&lt;/h1&gt;
&lt;p&gt;“嗨，你算哪根葱、你犯个错谁会在乎呀”&lt;/p&gt;
&lt;p&gt;不要逃避不要逃避不要逃避！&lt;/p&gt;
&lt;h1 id=&#34;progress-in-meaningful-work&#34;&gt;Progress in Meaningful Work&lt;/h1&gt;
&lt;p&gt;引发“最糟糕的一天”最常见的事件是挫折，“最好的日子”是工作进展&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有意义，学习 &amp;amp; 反思 &amp;amp; 获得肯定&lt;/li&gt;
&lt;li&gt;进展，记录 &amp;amp; 积累&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;除去运气还剩下什么&#34;&gt;除去运气，还剩下什么？&lt;/h1&gt;
&lt;p&gt;2020是属实糟糕的一年，反思了下过去（好运）的生活。换句话说，认识到自己的实力缺陷之后，该怎么做呢？&lt;/p&gt;
&lt;h1 id=&#34;勇气丢了&#34;&gt;勇气丢了&lt;/h1&gt;
&lt;p&gt;最近通过某家公司的初面，虽然后面因为复杂原因没有继续，但是这个简单的肯定是最近唯一的真正开心来源了😣。我的自信呢？勇气呢？丢了一往无前的勇气，也没有了面对难题的底气。这一年太容易自卑焦虑了，想了想自己最近想谈恋爱的本质原因，真的想要一个人肯定我认可我（深入了解之后还能认可我吗，我总会把对方拒之门外，其实也是一种逃避，以免遭受被对方否定的痛苦）。&lt;/p&gt;
&lt;p&gt;已经到了别人鼓励和夸赞也不能让我快乐的地步了吗？&lt;/p&gt;
">我算个什么</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/di-er-ci-mian-shi-zong-jie/"" data-c="
          &lt;h1 id=&#34;主题-特征工程&#34;&gt;主题： 特征工程&lt;/h1&gt;
&lt;h2 id=&#34;1缺失值&#34;&gt;1.缺失值&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;删除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果某一列缺失非常严重（超过80%）可以直接删除该列，或者数据量足够大而缺失不多的情况下删除该行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插补&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺失值占比在可接受的范围以内，可以插补，常见①用均值/众数/中位数插补（如果偏态最好用众数或者中位数插补）；②模型插值（例如knn 利用其它变量进行相似插补，但可能会引起变量自相关问题）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接离散化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即离散特征，把缺失当做一个新的category。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;random&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果缺失特别少（比如1%）可以随机生成；或者假定该列服从某种分布，可以按照分布随机生成。&lt;/p&gt;
&lt;h2 id=&#34;2归一化&#34;&gt;2.归一化&lt;/h2&gt;
&lt;p&gt;2.1 常用归一化方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;（真正的归一化）减去最小值，除以极差 &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\frac{x - min}{max - min}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.258995em;vertical-align:-0.403331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.855664em;&#34;&gt;&lt;span style=&#34;top:-2.655em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.394em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.403331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;（标准化，有时被当做归一化）减掉均值，除以标准差  &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;μ&lt;/mi&gt;&lt;/mrow&gt;&lt;mi&gt;σ&lt;/mi&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\frac{x - \mu}{\sigma}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.199439em;vertical-align:-0.345em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.854439em;&#34;&gt;&lt;span style=&#34;top:-2.6550000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03588em;&#34;&gt;σ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.446108em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mbin mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;μ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.345em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.2 归一化的作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;涉及到有关距离的算法时，比如 knn/svm，使不同量纲的特征处于同一数值量级，具有可比性，以免模型过分关注方差大的特征。&lt;/li&gt;
&lt;li&gt;影响迭代算法收敛，不进行归一化学习率比较难把握，而且算法可能收敛很慢，比如逻辑回归。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.3 不需要归一化&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树模型。因为树模型寻找的是最优分割点，而归一化前后分位点不变，不会影响树模型的结构&lt;/li&gt;
&lt;li&gt;有解析解，不涉及算距离或者梯度迭代时候，比如求逆计算最小二乘估计。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-连续变量离散化-数据分箱&#34;&gt;3. 连续变量离散化 / 数据分箱&lt;/h2&gt;
&lt;p&gt;3.1 连续变量离散化的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无监督：按照实际意义、等宽、分位点&lt;/li&gt;
&lt;li&gt;有监督：（联系回归树）给定箱子数，最小化分割后的平方误差——找到最优分割点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.2 离散化的原因&lt;/p&gt;
&lt;p&gt;合理性在于小范围连续数据的差别没有太大意义，可以看做一类，好处是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免异常点，模型更加 robust，也算是消除了量纲影响。&lt;/li&gt;
&lt;li&gt;对于线性模型来说（比如逻辑回归），如果特征和y不是线性的关系的话，进行离散化相当于为模型引入了非线性，加大拟合&lt;/li&gt;
&lt;li&gt;离散变量的计算相对于连续变量更快&lt;/li&gt;
&lt;li&gt;缺失值处理时，可以把缺失当做一个新的category&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.3 问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显而易见，丢失部分信息。&lt;/li&gt;
&lt;li&gt;增加了特征的个数（整体上降低了bias，增大了variance）（这一点可以结合正则化解决）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4异常值&#34;&gt;4.异常值&lt;/h2&gt;
&lt;p&gt;4.1 异常值识别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;某个特征（一元）：3sigma原则、箱线图&lt;/li&gt;
&lt;li&gt;（多元）基于距离：马氏距离/库克距离，看看与中心的距离远近&lt;/li&gt;
&lt;li&gt;线性模型，具有大残差的数据可能是异常值&lt;/li&gt;
&lt;li&gt;主成分分析，定义outlier scores衡量“原数据与映射回来的数据的差别”（考虑不同主成分所需乘以的权重，第一主成分所代表的数据中正常数据更多，所以权重越小；当j取到最后一维的主成分下，我们认为权重最高，达到1）&lt;/li&gt;
&lt;li&gt;isolation forest&lt;br&gt;
基于二叉树，单颗树每次随机选择特征+分割点，离群数据很容易被划分到最终子节点。用节点深度来衡量数据异常的可能性。再构建多棵树消除随机的影响。&lt;/li&gt;
&lt;li&gt;one class svm&lt;br&gt;
训练出一个最小的超球面把训练集把包起来，判断一个新的数据点落在内外。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.2 异常值处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除观察值&lt;/li&gt;
&lt;li&gt;分箱/离散化&lt;/li&gt;
&lt;li&gt;变换（比如右偏 Log变换）&lt;/li&gt;
&lt;li&gt;估算（类似缺失值处理，用分位点或者模型比如knn）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5-偏态&#34;&gt;5. 偏态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;识别：偏态系数、画图比如直方图&lt;/li&gt;
&lt;li&gt;问题：线性模型（比如逻辑回归）不符合分布假设&lt;/li&gt;
&lt;li&gt;处理：boxcox变换（常见的比如对数变换、平方根）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6-降维-特征选择&#34;&gt;6. 降维 &amp;amp; 特征选择&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;降维/投影：PCA&lt;/li&gt;
&lt;li&gt;特征选择：系数显著性、随机森林变量重要性、向前向后选择、正则项&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;主题算法&#34;&gt;主题：算法&lt;/h1&gt;
&lt;h2 id=&#34;7-svm原理&#34;&gt;7. SVM原理&lt;/h2&gt;
&lt;p&gt;相关问题见教材 &amp;amp; &lt;a href=&#34;https://github.com/sladesha/Reflection_Summary/blob/master/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.md&#34;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;主题代码&#34;&gt;主题：代码&lt;/h1&gt;
&lt;h2 id=&#34;10python-和-r-常用的预处理的函数&#34;&gt;10.python 和 r 常用的预处理的函数&lt;/h2&gt;
&lt;p&gt;python pandas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;df.loc / iloc&lt;/li&gt;
&lt;li&gt;df.duplicated&lt;/li&gt;
&lt;li&gt;df.isnull().sum(axis=0), df.dropna&lt;/li&gt;
&lt;li&gt;pd.cut&lt;/li&gt;
&lt;li&gt;value_counts / sort&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;r baseR&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;na.omit / unique&lt;/li&gt;
&lt;li&gt;table / arrange / apply&amp;amp;aggregate...&lt;/li&gt;
&lt;li&gt;tidyr pivot_longer group_by+mutate&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;11sql-常用的函数&#34;&gt;11.sql 常用的函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;聚合函数 + groupby&lt;/li&gt;
&lt;li&gt;窗口函数 rank xx over(partitions by &amp;lt;用于分组的列名&amp;gt; order by &amp;lt;用于排序的列名&amp;gt;)&lt;/li&gt;
&lt;li&gt;字符串、日期、数值函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;主题其他&#34;&gt;主题：其他&lt;/h1&gt;
&lt;h2 id=&#34;12给你一些数据你的处理步骤&#34;&gt;12.给你一些数据，你的处理步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;定义问题&lt;/li&gt;
&lt;li&gt;理解数据：特征、清洗（预处理）、选择（相关性）&lt;/li&gt;
&lt;li&gt;选择算法 + 调参&lt;/li&gt;
&lt;li&gt;评估模型&lt;/li&gt;
&lt;/ol&gt;
">第二次面试总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1208/"" data-c="
          &lt;p&gt;中等难度也太难了，做吐了，每一道题的心路历程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;（开始前）这是中等难度，估计很难&lt;/li&gt;
&lt;li&gt;（看完题目）似乎还行啊？我可以&lt;/li&gt;
&lt;li&gt;（试错）我真的可以吗？有点麻烦了&lt;/li&gt;
&lt;li&gt;（再坚持一会）烦躁！怎么还不对劲&lt;/li&gt;
&lt;li&gt;（看完题解）好家伙🐂原来要这样想可以这么简单&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;剑指-offer-59-ii-队列的最大值&#34;&gt;剑指 Offer 59 - II. 队列的最大值&lt;/h1&gt;
&lt;p&gt;请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。&lt;/p&gt;
&lt;p&gt;若队列为空，pop_front 和 max_value 需要返回 -1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MaxQueue:

    def __init__(self):
        self.queue = []
        self.stack = []  #用一个单调栈来保存最大值

    def max_value(self) -&amp;gt; int:
        if not self.stack:
            return -1
        return self.stack[0]
        
    def push_back(self, value: int) -&amp;gt; None:
        self.queue.append(value)
        while self.stack and value &amp;gt; self.stack[-1]:
            self.stack.pop()  # 把stack里所有小于当前值的都pop掉
        self.stack.append(value)

    def pop_front(self) -&amp;gt; int:
        if not self.queue:
            return -1
        if self.queue[0] == self.stack[0]:
            self.stack.pop(0)
        return self.queue.pop(0)

# Your MaxQueue object will be instantiated and called as such:
# obj = MaxQueue()
# param_1 = obj.max_value()
# obj.push_back(value)
# param_3 = obj.pop_front()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-33-二叉搜索树的后序遍历序列&#34;&gt;剑指 Offer 33. 二叉搜索树的后序遍历序列&lt;/h1&gt;
&lt;p&gt;后续遍历的理解关键点（for me）：先找到左下角的节点，然后按照左——右——根节点的顺序来，总之注意，当前节点append进去之后，先看看他的父节点的右子节点有没有遍历完，没有的话先去遍历这个右子节点/右子树，遍历完之后在去父节点的位置。&lt;/p&gt;
&lt;p&gt;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。&lt;/p&gt;
&lt;p&gt;——递归思路：&lt;/p&gt;
&lt;p&gt;给出遍历序列 [1, 4, 3, 17, 12, 9, 5]，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最后一个数字是跟节点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第一个比节点大的数index，0,index为左子数，index,len-1为右子树，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;递归看是否满足规则&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在判断每次的左子树个数加上右子树的个数是否为树的长度&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def verifyPostorder(self, postorder):
        while len(postorder) &amp;gt; 2:
            node = postorder.pop()

            length = 0
            for i in range(len(postorder)):
                if postorder[i] &amp;lt; node:
                    length += 1
                else: break
            for j in range(i, len(postorder)):
                if postorder[j] &amp;gt; node:
                    length += 1
                else: break
            
            print(length, postorder)
            if length != len(postorder):
                return False
        
        return True

# 测试
s2 = Solution()
arr = [1,4,3,7,10,13,12,19,18,15,9]
print(s2.verifyPostorder(postorder = arr))
arr = [1, 6, 16, 13, 15, 19, 11, 10]
print(s2.verifyPostorder(postorder = arr))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;10 [1, 4, 3, 7, 10, 13, 12, 19, 18, 15]
9 [1, 4, 3, 7, 10, 13, 12, 19, 18]
8 [1, 4, 3, 7, 10, 13, 12, 19]
7 [1, 4, 3, 7, 10, 13, 12]
6 [1, 4, 3, 7, 10, 13]
5 [1, 4, 3, 7, 10]
4 [1, 4, 3, 7]
3 [1, 4, 3]
2 [1, 4]
True
7 [1, 6, 16, 13, 15, 19, 11]
6 [1, 6, 16, 13, 15, 19]
5 [1, 6, 16, 13, 15]
3 [1, 6, 16, 13]
False
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-14-剪绳子&#34;&gt;剑指 Offer 14. 剪绳子&lt;/h1&gt;
&lt;p&gt;给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]&lt;em&gt;k[1]&lt;/em&gt;...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。&lt;/p&gt;
&lt;p&gt;e.g.&lt;br&gt;
输入: 10&lt;br&gt;
输出: 36&lt;br&gt;
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36&lt;/p&gt;
&lt;p&gt;输出所有的可能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用字典记录算出过的值，加速，避免重复计算&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;d = dict()
d[2] = 1
def cuttingRope(n):
    res = []
    if n in d.keys():
        return d[n]
    for i in range(1, n//2 + 1):
        tmpi = max(i * cuttingRope(n-i), i *  (n-i))
        res.append(tmpi)
    d[n] = max(res) 
    return d[n]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(cuttingRope(36))
print(d)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;531441
{2: 1, 3: 2, 4: 4, 5: 6, 6: 9, 7: 12, 8: 18, 9: 27, 10: 36, 11: 54, 12: 81, 13: 108, 14: 162, 15: 243, 16: 324, 17: 486, 18: 729, 19: 972, 20: 1458, 21: 2187, 22: 2916, 23: 4374, 24: 6561, 25: 8748, 26: 13122, 27: 19683, 28: 26244, 29: 39366, 30: 59049, 31: 78732, 32: 118098, 33: 177147, 34: 236196, 35: 354294, 36: 531441}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-31-栈的压入-弹出序列&#34;&gt;剑指 Offer 31. 栈的压入、弹出序列&lt;/h1&gt;
&lt;p&gt;输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。&lt;/p&gt;
&lt;p&gt;输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]&lt;br&gt;
输出：true&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不断入栈，1 2 3 4，此时栈顶=popped[0]，pop()&lt;/li&gt;
&lt;li&gt;辅助栈剩下1 2 3 5 栈顶=popped[1] pop&lt;/li&gt;
&lt;li&gt;1 2 3  3 = popped[2] pop&lt;/li&gt;
&lt;li&gt;最后popped遍历完，辅助栈为空-》return T&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#39;&#39;&#39;
stack = []
j = 0
for num in pushed:
    stack.append(num)
    while stack and stack[-1]==popped[0]:
        stack.pop()
        popped.pop(0)
print(not stack)
&#39;&#39;&#39;

def validateStackSequences(pushed, popped):
    stack, i = [], 0
    for num in pushed:
        stack.append(num) # 入栈
        while stack and stack[-1] == popped[i]:  # 判断出栈
            stack.pop()
            i += 1
    return not stack

# 测试
validateStackSequences(pushed = [1,2,3,4,5], popped = [4,3,5,1,2]),validateStackSequences(pushed = [1,0], popped = [1,0])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(False, True)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-26-树的子结构&#34;&gt;剑指 Offer 26. 树的子结构&lt;/h1&gt;
&lt;p&gt;输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)&lt;/p&gt;
&lt;p&gt;B是A的子结构， 即 A中有出现和B相同的结构和节点值。&lt;/p&gt;
&lt;p&gt;好家伙&lt;strong&gt;递归套递归&lt;/strong&gt;，思路太清晰了🐂&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

# 定义测试用例1
t1 = TreeNode(5)
t2 = TreeNode(4)
t3 = TreeNode(8)
t4 = TreeNode(11)
t5 = TreeNode(13)
t6 = TreeNode(4)
t7 = TreeNode(7)
t8 = TreeNode(2)
t9 = TreeNode(5)
t10 = TreeNode(1)
t1.left = t2; t1.right = t3
t2.left = t4; t3.left = t5; t3.right = t6;
t4.left = t7; t4.right = t8; t6.left = t9; t6.right = t10


# 定义测试用例2
z1 = TreeNode(-2)
z2 = TreeNode(-3)
z1.right = z2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSubStructure(self, A, B):
        # 补充定义函数
        def recur(A,B):   # 递归判断是否是子结构：
            # 结束条件——匹配完了/发现不一致的
            if not B:
                return True
            if not A or (A.val != B.val):
                return False
            # 递归
            return recur(A.left, B.left) and recur(A.right, B.right)

        # 结束条件1：空树
        if (not A) or (not B):   # 约定空树不是任意一个树的子结构
            return False
        # 结束条件2：找到了子结构
        if recur(A, B):
            return True
        
        # 否则递归
        return self.isSubStructure(A.left, B) or self.isSubStructure(A.right, B) 
    
s5 = Solution()
s5.isSubStructure(t1, t3), s5.isSubStructure(z1, z2),s5.isSubStructure(t2, t6)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(True, True, False)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-34-二叉树中和为某一值的路径&#34;&gt;剑指 Offer 34. 二叉树中和为某一值的路径&lt;/h1&gt;
&lt;p&gt;输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def pathSum(root, target):
    res, path = [], []
   
    def recur(root, target):
        if not root: return
        
        path.append(root.val)
        print(path, target, res)
        
        if root.val == target:  # 找到这样的路径就append进去
            res.append(list(path))
            &#39;&#39;&#39; 
            if (not root.right) and (not root.left):    # 如果题目要求必须从根节点-叶节点的路径，加入这一个判断
                 res.append(list(path))
            &#39;&#39;&#39;
        
        recur(root.left, target - root.val)
        recur(root.right, target - root.val)
        path.pop()  # 这里是关键点
        return
    
    recur(root, target)
    return res

pathSum(t1, 22)
print(&amp;quot;\n&amp;quot;)
pathSum(z1, -5)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[5] 22 []
[5, 4] 17 []
[5, 4, 11] 13 []
[5, 4, 11, 7] 2 []
[5, 4, 11, 2] 2 []
[5, 8] 17 [[5, 4, 11, 2]]
[5, 8, 13] 9 [[5, 4, 11, 2]]
[5, 8, 4] 9 [[5, 4, 11, 2]]
[5, 8, 4, 5] 5 [[5, 4, 11, 2]]
[5, 8, 4, 1] 5 [[5, 4, 11, 2], [5, 8, 4, 5]]


[-2] -5 []
[-2, -3] -3 []





[[-2, -3]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-47-礼物的最大价值&#34;&gt;剑指 Offer 47. 礼物的最大价值&lt;/h1&gt;
&lt;p&gt;在一个 mXn 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: 
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;基础版本&#34;&gt;基础版本&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def maxValue(grid):
    if (not len(grid)) or (grid and not len(grid[0])):
        return False
    
    m =  len(grid)
    n =  len(grid[0])
    
    def gifts(i, j):
        # print(i,j)
        if i &amp;gt;= m or j&amp;gt;=n :
            return 0
        if i == m-1 and j == n-1:
            return grid[i][j]
        else:
            return grid[i][j] + max(gifts(i, j+1), gifts(i+1, j))  
    
    return gifts(0,0)

grid = [
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
maxValue(grid)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于复杂的情况，上面的版本就超时了，如何解决？&lt;/p&gt;
&lt;h2 id=&#34;改进版本&#34;&gt;改进版本&lt;/h2&gt;
&lt;p&gt;考虑用字典改进为记忆递归（套路方法嘿嘿），确实加速了，但是无论时间/空间复杂度表现都不太行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;grid = [[7,1,3,5,8,9,9,2,1,9,0,8,3,1],[9,5,9,4,0,4,8,8,9,5,7,3,6,6],[8,2,9,1,3,1,9,7,2,5,3,1,2,4],[6,7,9,8,4,8,3,0,4,0,9,6,6,0],[7,1,3,1,8,8,3,1,2,1,5,0,2,1],[9,5,4,3,5,6,1,3,6,4,9,7,0,8],[1,4,2,5,8,7,7,0,0,7,1,2,1,2],[3,9,7,9,5,8,9,5,6,9,8,8,0,1],[1,5,2,2,2,5,6,3,9,3,1,7,9,6]]

m =  len(grid)
n =  len(grid[0])
d = dict()

def gifts2(i, j):
    if i &amp;gt;= m or j&amp;gt;=n :
        return 0
    if i == m-1 and j == n-1:
        d[(i, j)] = grid[i][j]
        return d[(i, j)] 
    else:
        t1 = d[i, j+1] if (i, j+1) in d else gifts2(i, j+1)
        t2 = d[i+1, j] if  (i+1, j) in d else gifts2(i+1, j)
        d[(i, j)] = grid[i][j] + max(t1, t2) 
        return d[(i, j)] 

print(gifts2(0, 0))
print(d)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;164
{(8, 13): 6, (7, 13): 7, (6, 13): 9, (5, 13): 17, (4, 13): 18, (3, 13): 18, (2, 13): 22, (1, 13): 28, (0, 13): 29, (8, 12): 15, (7, 12): 15, (6, 12): 16, (5, 12): 17, (4, 12): 20, (3, 12): 26, (2, 12): 28, (1, 12): 34, (0, 12): 37, (8, 11): 22, (7, 11): 30, (6, 11): 32, (5, 11): 39, (4, 11): 39, (3, 11): 45, (2, 11): 46, (1, 11): 49, (0, 11): 57, (8, 10): 23, (7, 10): 38, (6, 10): 39, (5, 10): 48, (4, 10): 53, (3, 10): 62, (2, 10): 65, (1, 10): 72, (0, 10): 72, (8, 9): 26, (7, 9): 47, (6, 9): 54, (5, 9): 58, (4, 9): 59, (3, 9): 62, (2, 9): 70, (1, 9): 77, (0, 9): 86, (8, 8): 35, (7, 8): 53, (6, 8): 54, (5, 8): 64, (4, 8): 66, (3, 8): 70, (2, 8): 72, (1, 8): 86, (0, 8): 87, (8, 7): 38, (7, 7): 58, (6, 7): 58, (5, 7): 67, (4, 7): 68, (3, 7): 70, (2, 7): 79, (1, 7): 94, (0, 7): 96, (8, 6): 44, (7, 6): 67, (6, 6): 74, (5, 6): 75, (4, 6): 78, (3, 6): 81, (2, 6): 90, (1, 6): 102, (0, 6): 111, (8, 5): 49, (7, 5): 75, (6, 5): 82, (5, 5): 88, (4, 5): 96, (3, 5): 104, (2, 5): 105, (1, 5): 109, (0, 5): 120, (8, 4): 51, (7, 4): 80, (6, 4): 90, (5, 4): 95, (4, 4): 104, (3, 4): 108, (2, 4): 111, (1, 4): 111, (0, 4): 128, (8, 3): 53, (7, 3): 89, (6, 3): 95, (5, 3): 98, (4, 3): 105, (3, 3): 116, (2, 3): 117, (1, 3): 121, (0, 3): 133, (8, 2): 55, (7, 2): 96, (6, 2): 98, (5, 2): 102, (4, 2): 108, (3, 2): 125, (2, 2): 134, (1, 2): 143, (0, 2): 146, (8, 1): 60, (7, 1): 105, (6, 1): 109, (5, 1): 114, (4, 1): 115, (3, 1): 132, (2, 1): 136, (1, 1): 148, (0, 1): 149, (8, 0): 61, (7, 0): 108, (6, 0): 110, (5, 0): 123, (4, 0): 130, (3, 0): 138, (2, 0): 146, (1, 0): 157, (0, 0): 164}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-48-最长不含重复字符的子字符串&#34;&gt;剑指 Offer 48. 最长不含重复字符的子字符串&lt;/h1&gt;
&lt;p&gt;请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: &amp;quot;pwwkew&amp;quot;
输出: 3
解释: 因为无重复字符的最长子串是 &amp;quot;wke&amp;quot;，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，&amp;quot;pwke&amp;quot; 是一个子序列，不是子串。
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;用一个优先队列来维护，用双指针表示&lt;/li&gt;
&lt;li&gt;每次在队列内循环——如果存在和当前相同的，就把左指针变为重复的下一位，保证队列内unique&lt;/li&gt;
&lt;li&gt;保留最大长度的队列&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;strings = list(&amp;quot;daddvdffd&amp;quot;) # 最长的是vdf——3
i = 0
curmax = 0
for j in range(len(strings)):
    for idx in range(i, j):
        if  strings[idx] == strings[j]:
            i = idx + 1
            break
    print(strings[i:(j+1)])    # 保留的队列
    curmax = j - i +1 if ( j-i +1 &amp;gt; curmax) else curmax
curmax
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&#39;d&#39;]
[&#39;d&#39;, &#39;a&#39;]
[&#39;a&#39;, &#39;d&#39;]
[&#39;d&#39;]
[&#39;d&#39;, &#39;v&#39;]
[&#39;v&#39;, &#39;d&#39;]
[&#39;v&#39;, &#39;d&#39;, &#39;f&#39;]
[&#39;f&#39;]
[&#39;f&#39;, &#39;d&#39;]





3
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-49-丑数&#34;&gt;剑指 Offer 49. 丑数&lt;/h1&gt;
&lt;p&gt;我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。&lt;/p&gt;
&lt;p&gt;解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数&lt;/p&gt;
&lt;p&gt;动态规划&lt;br&gt;
dp[i]=min(dp[a]∗2,dp[b]∗3,dp[c]∗5)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;n = 10
dp = [None] * n
dp[0] = 1
a,b,c = 0, 0, 0
for i in range(1, n):
    tmp = min(dp[a] * 2, dp[b] * 3, dp[c] * 5)
    dp[i] = tmp
    if tmp == dp[a] * 2:
        a += 1
    if tmp == dp[b] * 3:
        b += 1
    if tmp == dp[c] * 5:
        c +=1
    print(tmp, dp)
print(dp)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2 [1, 2, None, None, None, None, None, None, None, None]
3 [1, 2, 3, None, None, None, None, None, None, None]
4 [1, 2, 3, 4, None, None, None, None, None, None]
5 [1, 2, 3, 4, 5, None, None, None, None, None]
6 [1, 2, 3, 4, 5, 6, None, None, None, None]
8 [1, 2, 3, 4, 5, 6, 8, None, None, None]
9 [1, 2, 3, 4, 5, 6, 8, 9, None, None]
10 [1, 2, 3, 4, 5, 6, 8, 9, 10, None]
12 [1, 2, 3, 4, 5, 6, 8, 9, 10, 12]
[1, 2, 3, 4, 5, 6, 8, 9, 10, 12]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-60-n个骰子的点数&#34;&gt;剑指 Offer 60. n个骰子的点数&lt;/h1&gt;
&lt;p&gt;把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。&lt;/p&gt;
&lt;p&gt;你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。&lt;/p&gt;
&lt;p&gt;输入: 2&lt;br&gt;
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 单个
probs = ([1/6]*6)
# 两个骰子
d = dict()
for i in range(6):
    for j in range(6):
        if i+j+2 in d:
             d[i+j+2] = d[i+j+2] + probs[i]*probs[j]
        else:
             d[i+j+2] = probs[i]*probs[j]
print(d)
# 如果是多个怎么办——换一种思路——递归
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{2: 0.027777777777777776, 3: 0.05555555555555555, 4: 0.08333333333333333, 5: 0.1111111111111111, 6: 0.1388888888888889, 7: 0.16666666666666669, 8: 0.1388888888888889, 9: 0.1111111111111111, 10: 0.08333333333333333, 11: 0.05555555555555555, 12: 0.027777777777777776}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1暴力解答&#34;&gt;1.暴力解答&lt;/h2&gt;
&lt;p&gt;时间复杂度：O(6^n)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def dicesProbability(n):
    
    def count(n, s):
        if s &amp;lt; n or s &amp;gt; 6 * n:
            return 0
        if n == 1:
            return 1
        return sum([count(n - 1, s - i) for i in range(1, 7)])

    res = []
    for s in range(n, 6 * n +1 ):
        res.append(count(n,s))
    return [x/sum(res) for x in res]

# 测试
dicesProbability(3)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[0.004629629629629629,
 0.013888888888888888,
 0.027777777777777776,
 0.046296296296296294,
 0.06944444444444445,
 0.09722222222222222,
 0.11574074074074074,
 0.125,
 0.125,
 0.11574074074074074,
 0.09722222222222222,
 0.06944444444444445,
 0.046296296296296294,
 0.027777777777777776,
 0.013888888888888888,
 0.004629629629629629]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;动态规划方法&#34;&gt;动态规划方法&lt;/h2&gt;
&lt;p&gt;递推公式：probs(n,s) = sigma i从1到6求和{1/6 * probs(n-1, n-i)}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用一个二维数组去记录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;n = 3
dp = [[0 for _ in range((6*n)+1)] for _ in range(n+1)]

for i in range(1,7):
    dp[1][i] = 1.0/6

for i in range(2, n+1):   # i表示从掷出1个筛子的情况，递推到掷出n个
    for j in range(i, (6 * i) + 1):     
        for k in range(1, 7):
            if j &amp;gt;= k+1:
                dp[i][j]  += (1/6) * dp[i-1][j-k] 
                
dp[n][n:]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[0.004629629629629629,
 0.013888888888888888,
 0.027777777777777776,
 0.046296296296296294,
 0.06944444444444445,
 0.09722222222222224,
 0.11574074074074074,
 0.125,
 0.125,
 0.11574074074074073,
 0.09722222222222222,
 0.06944444444444445,
 0.046296296296296294,
 0.027777777777777776,
 0.013888888888888888,
 0.004629629629629629]
&lt;/code&gt;&lt;/pre&gt;
">练习题Day8</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/machine-learning-in-r/"" data-c="
          &lt;p&gt;今天的男主角是一个神奇的R包——MLR。最近在肝数据挖掘课大作业，顺便拿R跑了跑 machine learning， 之前基本都是用 ggplot2，总觉得R涉及机器学习部分有点零乱（因为要装各种包需要的数据结构也不太一样，总之相比 sklearn 显得挺麻烦的？）这几天突然看到了这个MLR！！用完感觉神仙救了我一命，快速就把作业搞定啦！开心&lt;/p&gt;
&lt;p&gt;那今天就拿大作业为例，讲讲我们今天的男主角神仙R包叭！作业所有的 code &amp;amp; data 都放在&lt;a href=&#34;https://github.com/yangggshuyi/datamining_code-data&#34;&gt; github 上面啦&lt;/a&gt;，随时更新，欢迎各位老铁关注、点星嘿嘿。&lt;/p&gt;
&lt;p&gt;最后还想分享下有关我们作业的有趣发现~&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;mlr包的流程&#34;&gt;mlr包的流程&lt;/h1&gt;
&lt;p&gt;以一个基本的逻辑回归来看看：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# 1.加载我们今天的男主——mlr包
library(mlr)  

# 2.定义一个分类问题，target就是因变量
classif.task = makeClassifTask(data = data, target = &amp;quot;y&amp;quot;)   
n = getTaskSize(classif.task)  
random_index = sample(x = 1:n, size = n * 0.8, replace = F)
train.set = random_index   # 划分训练集合
test.set = (1:n)[-random_index]

# 3.选择学习器（面向对象的味道和 sklearn 灰常像
logistic_learner = makeLearner(&amp;quot;classif.logreg&amp;quot;, predict.type = &amp;quot;prob&amp;quot;, fix.factors.prediction = TRUE)

# 4. 训练模型
lr_model = train(logistic_learner, classif.task, subset = train.set)

# 5. 预测
lr.pred = predict(lr_model, task = classif.task, subset = test.set)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;复制粘贴！完事了！交作业！！！高老师一拳一个糊弄学大师&lt;/p&gt;
&lt;p&gt;算了算了，具体来说有四个步骤：&lt;/p&gt;
&lt;h2 id=&#34;第一步-定义我们的研究问题&#34;&gt;第一步 定义我们的研究问题&lt;/h2&gt;
&lt;p&gt;这里是一个二分类问题，使用makeClassifTask()，其他的类型的问题见下面。要给出一个数据表（data.frame），target就是我们的响应变量（Y），其他列默认为解释变量（X1-Xn）。注意！变量不可以是 strings 必须转化为 factor 或者 numeric。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RegrTask() for regression problems,&lt;/li&gt;
&lt;li&gt;ClassifTask() for binary and multi-class classification problems with class-dependent costs can be handled as well),&lt;/li&gt;
&lt;li&gt;SurvTask() for survival analysis,&lt;/li&gt;
&lt;li&gt;ClusterTask() for cluster analysis,&lt;/li&gt;
&lt;li&gt;MultilabelTask() for multilabel classification problems,&lt;/li&gt;
&lt;li&gt;CostSensTask() for general cost sensitive classification (with example-specific costs).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;第二步-选择模型&#34;&gt;第二步 选择模型&lt;/h2&gt;
&lt;p&gt;呜呜呜这次作业所有模型都要做（不过这正体现了男主角的优越性！），用 makeLearner 来选择学习器。所有学习器的列表&lt;a href=&#34;https://mlr.mlr-org.com/articles/tutorial/integrated_learners.html&#34;&gt;在这里可以看到&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;你会发现它汇总了了88种Classification，59种Regression，12种Survival analysis，10种Cluster analysis，还有 Multilabel classification等等🤙🤙🤙所有的方法还会标注出&lt;strong&gt;能否处理factor、NA等特殊情况&lt;/strong&gt;，简直是太！贴！心！了！&lt;/p&gt;
&lt;h2 id=&#34;第三步-训练和预测&#34;&gt;第三步 训练和预测&lt;/h2&gt;
&lt;p&gt;这部分就没什么好说的了，直接 train + predict，有几个常用注意点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;subset 参数使用训练集 or 测试集&lt;/li&gt;
&lt;li&gt;names函数可以看到 train/ predict 里面有什么信息，然后直接用$进行访问，就和我们一般用R包跑出来的是一样的哈。&lt;/li&gt;
&lt;li&gt;weights 参数可以对类失衡的问题进行重采样&lt;/li&gt;
&lt;li&gt;预测结果包含真实值（truth）和预测值（response）。如果想要输出概率值（比如画个ROC曲线之类的），需要在 makeLearner那里加上 predict.type = &amp;quot;prob&amp;quot;，预测结果就会增加概率值~&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;交叉验证搜索最优参数&#34;&gt;交叉验证搜索最优参数&lt;/h1&gt;
&lt;p&gt;如果你觉得掉包也不麻烦，一两行代码的事，那 mlr 最棒的点就是搜索最优参数了。&lt;/p&gt;
&lt;p&gt;这里以KNN搜索最佳K值为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先用 getLearnerParamSet 看看所有超参数及其取值范围，然后结合理论知识和经验（实话说，结合百度各种博客的说法哈哈哈），&lt;/li&gt;
&lt;li&gt;用 makeParamSet 选几个参数和一些常见的调参范围。&lt;/li&gt;
&lt;li&gt;设置 makeResampleDesc 进行交叉验证&lt;/li&gt;
&lt;li&gt;直接 tuneParams 开始交叉验证搜索参数就完事了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原本挨个掉包写循环的我直呼好家伙...&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;getLearnerParamSet(makeLearner(&amp;quot;classif.kknn&amp;quot;))  # 获取所有超参数
rdesc = makeResampleDesc(&amp;quot;CV&amp;quot;, iters = 5L)  # 5折交叉验证
discrete_ps = makeParamSet(  # 参数空间
  makeDiscreteParam(&amp;quot;k&amp;quot;, values = c(1, 3, 5, 10, 20, 30, 50, 80, 100))
  )
ctrl = makeTuneControlGrid()
res = tuneParams(&amp;quot;classif.kknn&amp;quot;, task = classif.task,
                 resampling = rdesc, par.set = discrete_ps, control = ctrl)
res # 搜索结果：
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;## Tune result:
## Op. pars: k=3
## mmce.test.mean=0.3585818
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;得到的最优参数K = 3（这时候交叉验证 test 平均误差最低），&lt;strong&gt;利用 setHyperPars 用得到的最优参数建模&lt;/strong&gt;，再 train + prediction 就完事了！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;# 获得最优参数
knn_best = setHyperPars(makeLearner(&amp;quot;classif.kknn&amp;quot;, predict.type = &amp;quot;prob&amp;quot;), k = res$x$k)
# 用最优参数建模
knn_model_best = train(knn_best, classif.task, subset = train.set)
knn.pred = predict(knn_model_best, task = classif.task, subset = test.set)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在输出预测准确率、 ROC 和 AUC，作业不就是分分钟完事啦？夸我谢谢。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;library(pROC)      # 画ROC曲线
library(ROCR)      # 算AUC值

# 输入我们的模型预测结果
plotROC &amp;lt;- function(input){  # roc_curve
  modelroc &amp;lt;- roc(input$truth, input$prob.TRUE)
  plot(modelroc, print.auc=TRUE,auc.polygon=TRUE, 
       auc.polygon.col=&amp;quot;#f6f6f6&amp;quot;, print.thres=TRUE,main = &amp;quot;ROC curve&amp;quot;)
}

Accuracy &amp;lt;- function(input){  # matrix &amp;amp; accuracy
  res = table(input[, c(&amp;quot;truth&amp;quot;, &amp;quot;response&amp;quot;)])  # rf预测结果
  print(res)
  return(sum(diag(res)) / sum(res))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;补充&#34;&gt;补充&lt;/h1&gt;
&lt;h2 id=&#34;关于我们的作业一些有趣的发现&#34;&gt;关于我们的作业，一些有趣的发现&lt;/h2&gt;
&lt;h3 id=&#34;1-cs-有多卷&#34;&gt;1. CS 有多卷？&lt;/h3&gt;
&lt;p&gt;左边为原始专业（来源），下方为申请专业（去向）。肉眼可见第一列飘红，果然是全民CS的时代，机械专业同学1 /4 都飘去了CS，果然卷还是CS卷。而统计专业的话，本科统计一般还是会继续申统计，当然还有一批本科金融的同学和你竞争申请，也要越来越卷的节奏。&lt;br&gt;
&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1607329152437.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2phd难在哪儿&#34;&gt;2.PhD难在哪儿？&lt;/h3&gt;
&lt;p&gt;博士一列“论文、SCI、一作”都飘红，申请博士也太太太卷了叭！至今没有论文的小菜鸡当场抹眼泪...而申请硕士的话专注实习就好了。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1607329131379.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-英语成绩到底有多重要&#34;&gt;3. 英语成绩到底有多重要？&lt;/h3&gt;
&lt;p&gt;总有人说英语成绩只要差不多就行，但。。。GRE verbal 成绩对录取结果的影响表明，英语好还是非常重要的，英语太差申请Top50名校难度不小嗷。。。当然有可能是优秀的人各方面都不会差的，再次落泪。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1607329159552.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4出身重要吗&#34;&gt;4.出身重要吗&lt;/h3&gt;
&lt;p&gt;of course！来自全球Top100的本科（清北复交港大等）就是很占优势。（我人呢，这次人大附中附属大学没有牌面，说好的全国Top3呢&lt;br&gt;
&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1607329164151.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">Machine Learning in R 神器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/r-package/"" data-c="
          &lt;p&gt;简单来讲的话，R package 其实就是把代码函数，数据和文档打包起来的一个文件夹。最近统计软件课上学习了R包的结构、创建，这里是一篇总结文。我的课堂作业R包传上了&lt;a href=&#34;https://github.com/yangggshuyi/yang88&#34;&gt;github主页&lt;/a&gt;，可以devtools::install_github(&amp;quot;yangggshuyi/yang88&amp;quot;) 安装使用哟！&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;什么是-r包&#34;&gt;什么是 R包&lt;/h1&gt;
&lt;p&gt;简单来讲的话，R package 其实就是把代码函数，数据和文档打包起来的一个文件夹哈哈哈哈。通常我们讲R包，包括源码和编译之后的版本，源码大多是R语言写的（当然可以用上其他语言）。如果这个包没有编译过，在安装的时候会编译之后装。&lt;br&gt;
&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1607096858141.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;想要安装R包，按照来源可以分为本地、github、&lt;a href=&#34;https://cran.r-project.org/web/packages/available_packages_by_name.html&#34;&gt;cran&lt;/a&gt;。CRAN是包含R发行版和已贡献代码（尤其是R包）的网络，从cran上任意点进去一个包的主页，比如glmnet包，可以看到如下信息（还没看到源码，先看到复杂的介绍文档和论文了可怕）：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1607096433484.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;简单写个函数不难，但是如何包装，如何从使用者的角度考虑进行完善，包括如何写帮助文档，这些琐碎的事情有时候劳心费神。就拿写help来说，有些help文档真的看不大懂有些一下就能明白。从使用者的角度来看，好的文档应该解释清楚参数的含义、得给出有用的示例代码等等，如果真的要做R包，除了code还要干很多活呐。&lt;/p&gt;
&lt;h1 id=&#34;r包的结构&#34;&gt;R包的结构&lt;/h1&gt;
&lt;h2 id=&#34;一个简单的包结构&#34;&gt;一个简单的包结构&lt;/h2&gt;
&lt;p&gt;创建R包前先看看R包（一个大文件夹）里面具体有哪些内容。一个简单的包结构是这样子的：&lt;br&gt;
&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1607097484557.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;|--DESCRIPTION (软件包的基本信息，包括包名、版本号、标题、描述、依赖关系等)
|--R (函数源文件)
   |--function1.R
   |--function2.R
   |--...
|--man (帮助文档)
   |--function1.Rd
   |--function2.Rd
   |--...
|--data（存放数据）
   |--data1.RData
   |--data2.RData
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先注意R文件夹，这个文件夹下应该放着所有的自创的 R 代码，比如可以每个函数一个文件，方便整理。而每一个函数其实都有对应的输入变量和数据结构，应该有对应的解释等。在 man 文件夹中会有对应的 .Rd 文件，里面的内容看起来是latex，就是我们每个函数的help文档内容。&lt;/p&gt;
&lt;p&gt;课堂上我们直接对 .Rd 文件进行修改，其实并不方便&amp;amp;不大合理。除了直接修改，常见的办法就是在R文件函数上面加上一串注释。这种注释是 #&#39; 开头的，会由 devtools 里面的辅助函数来进行处理，大概长这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#&#39; title
#&#39; This function...
#&#39; @param abc ...   
#&#39; @export
#&#39; @examples
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样写完你的help文档之后，运行document()，会自动生成对应的 *.Rd 文件在 man 文件夹中（似乎变得简单了起来）&lt;/p&gt;
&lt;h2 id=&#34;进阶r包的结构&#34;&gt;进阶R包的结构：&lt;/h2&gt;
&lt;p&gt;（这里用glmnet包为例，瞅瞅它的源码是这样的：&lt;br&gt;
&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1607097476777.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;除了 R 和 man 文件夹之外，还有一些可能有用的东西/文件夹&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;demo&lt;br&gt;
下面可以放一些演示 R 代码，这样用户可以使用demo()函数调用这些演示&lt;/li&gt;
&lt;li&gt;data&lt;br&gt;
放数据，通常是通过save()函数保存成 rda 文件放到这里&lt;/li&gt;
&lt;li&gt;src&lt;br&gt;
可以放其它语言的源代码，编译时会特殊处理；&lt;/li&gt;
&lt;li&gt;Vignette&lt;br&gt;
关于一个包的介绍文档，里面是rmarkdown &amp;amp; html&lt;/li&gt;
&lt;li&gt;NAMESPACE&lt;br&gt;
可以控制哪些 R 对象是对用户可见的，哪些对象是从别的包导入（import），哪些对象从本包导出（export）。比如有些函数仅仅供你自己使用，对用户没什么帮助，就可以利用export(函数名)只导出那些需要对用户可见的函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;r包的建立和发布&#34;&gt;R包的建立和发布&lt;/h1&gt;
&lt;p&gt;了解了这些，创建和发布可以用点点点的无脑操作完成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步：创建&lt;br&gt;
创建一个new project，选择 R package，会生成一个大文件夹，点击文件夹里的蓝色Rproj图标就进入这个project啦！&lt;/li&gt;
&lt;li&gt;第二步：添加&lt;br&gt;
往文件夹里添加我们想要添加的内容，函数、文档、数据等等&lt;/li&gt;
&lt;li&gt;第三步：打包&lt;br&gt;
点build创建我们的R包&lt;br&gt;
&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1607099228050.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
source 是源码， binary是编译过的（分为windows和mac两个版本），一般还是 build source R包方面系统互通。&lt;/li&gt;
&lt;li&gt;第四步：发布和适用&lt;br&gt;
这里我试了下发布在github上面，建一个同名库之后把源码文件夹全部放上去就好了，非常简单哈哈。安装放在github上的R包可以这样：（欢迎安装使用我的包嘻嘻）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;devtools::install_github(&amp;quot;yangggshuyi/yang88&amp;quot;)
library(yang88)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那如果没有上传，直接本地安装也是可以滴：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;install.packages(&amp;quot;~/yang88_0.1.0.tar.gz&amp;quot;, repos = NULL, type = &amp;quot;source&amp;quot;)
library(yang88)
&lt;/code&gt;&lt;/pre&gt;
">R package</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1203/"" data-c="
          &lt;p&gt;查找（二分查找），经典排序（冒泡排序、选择排序/插入排序、谢尔排序、归并排序、快速排序）&lt;br&gt;
常考问题：topk 即找出前k大或者前k小的数，使用快排和堆排序实现。补充二叉堆的概念理解和功能实现。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE&#34;&gt;二分查找&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95&#34;&gt;二分查找的递归算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%9A%84%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95%E9%87%8D%E8%A6%81&#34;&gt;二分查找的双指针算法（重要）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%92%E5%BA%8F&#34;&gt;排序&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F&#34;&gt;冒泡排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F&#34;&gt;选择排序/插入排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B0%A2%E5%B0%94%E6%8E%92%E5%BA%8F&#34;&gt;谢尔排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F&#34;&gt;归并排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&#34;&gt;快速排序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#topk-%E7%B1%BB%E9%97%AE%E9%A2%98&#34;&gt;topk 类问题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BF%AB%E6%8E%92&#34;&gt;快排&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A0%86%E6%8E%92%E5%BA%8F&#34;&gt;堆排序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8F%89%E5%A0%86&#34;&gt;二叉堆&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3&#34;&gt;二叉堆的概念理解&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97&#34;&gt;用来做什么的？实现优先队列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84%E7%BB%93%E6%9E%84%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;二叉堆的结构？完全二叉树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A0%86%E6%AC%A1%E5%BA%8F%E6%9C%80%E5%A4%A7%E5%A0%86%E5%92%8C%E6%9C%80%E5%B0%8F%E5%A0%86&#34;&gt;堆次序？最大堆和最小堆&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E5%A0%86%E7%9A%84%E5%8A%9F%E8%83%BD&#34;&gt;实现二叉堆的功能&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-insert&#34;&gt;1. insert&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-delmax&#34;&gt;2. delMax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%A0%86%E6%8E%92%E5%BA%8Fmin-k-%E9%97%AE%E9%A2%98&#34;&gt;3.用自己的函数进行堆排序——min k 问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;二分查找&#34;&gt;二分查找&lt;/h1&gt;
&lt;h2 id=&#34;二分查找的递归算法&#34;&gt;二分查找的递归算法&lt;/h2&gt;
&lt;p&gt;——返回T F&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 二分查找的递归算法
###  如果只剩下1个数字，直接对比，如果不是则不存在
def binarySearch(alist,item):
    # 停止条件
    if not alist:
        return False
    if len(alist) == 1:
        return alist[0]==item
    # 递归
    mid = len(alist)//2
    return binarySearch(alist[:mid], item) or binarySearch(alist[mid:], item)

print(binarySearch([1,3,5,8,12,19,25], 8))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;二分查找的双指针算法重要&#34;&gt;二分查找的双指针算法（重要）&lt;/h2&gt;
&lt;p&gt;稍微改造一下可以返回下标值，并且复杂度更优&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def binarysearch(nums, target):
    if not nums:
        return False
    l, r = 0, len(nums) - 1
   
    while l &amp;lt;= r:
        if target &amp;lt; nums[l] or target &amp;gt; nums[r]:
            return False
        mid = (l + r) // 2
        if target == nums[mid]:
            return True
        if target &amp;gt; nums[mid]:
            l = mid + 1
        if target &amp;lt; nums[mid]:
            j = mid -1
    return False      

print(binarySearch([1,3,5,8,12,19,25], 2))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;False
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;排序&#34;&gt;排序&lt;/h1&gt;
&lt;h2 id=&#34;冒泡排序&#34;&gt;冒泡排序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对无序表多趟比较，每趟多次相邻对比交换，并交换。第i躺排序第i大的项。&lt;/li&gt;
&lt;li&gt;稍加改进的版本：加入exchange， 如果这一趟没有exchange 说明排序完成了， 直接break&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 1.原始版本
nums = [34,82,66,14,56,80,9,44,69,21,60,65]
for i in range(len(nums)):
    for idx in range(len(nums)-1):
        if nums[idx] &amp;gt; nums[idx+1]:
             nums[idx], nums[idx+1] = nums[idx + 1], nums[idx]
    print(nums)

print(&#39;\n改进版本:\n&#39;)
### 2.加入exchange的改进版本
nums = [34,82,66,14,56,80,9,44,69,21,60,65]
for i in range(len(nums)):
    exchange = False
    for idx in range(len(nums)-1):
        if nums[idx] &amp;gt; nums[idx + 1]:
            exchange = True
            nums[idx], nums[idx + 1] = nums[idx + 1], nums[idx]
    if not exchange: break
    print(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[34, 66, 14, 56, 80, 9, 44, 69, 21, 60, 65, 82]
[34, 14, 56, 66, 9, 44, 69, 21, 60, 65, 80, 82]
[14, 34, 56, 9, 44, 66, 21, 60, 65, 69, 80, 82]
[14, 34, 9, 44, 56, 21, 60, 65, 66, 69, 80, 82]
[14, 9, 34, 44, 21, 56, 60, 65, 66, 69, 80, 82]
[9, 14, 34, 21, 44, 56, 60, 65, 66, 69, 80, 82]
[9, 14, 21, 34, 44, 56, 60, 65, 66, 69, 80, 82]
[9, 14, 21, 34, 44, 56, 60, 65, 66, 69, 80, 82]
[9, 14, 21, 34, 44, 56, 60, 65, 66, 69, 80, 82]
[9, 14, 21, 34, 44, 56, 60, 65, 66, 69, 80, 82]
[9, 14, 21, 34, 44, 56, 60, 65, 66, 69, 80, 82]
[9, 14, 21, 34, 44, 56, 60, 65, 66, 69, 80, 82]

改进版本:

[34, 66, 14, 56, 80, 9, 44, 69, 21, 60, 65, 82]
[34, 14, 56, 66, 9, 44, 69, 21, 60, 65, 80, 82]
[14, 34, 56, 9, 44, 66, 21, 60, 65, 69, 80, 82]
[14, 34, 9, 44, 56, 21, 60, 65, 66, 69, 80, 82]
[14, 9, 34, 44, 21, 56, 60, 65, 66, 69, 80, 82]
[9, 14, 34, 21, 44, 56, 60, 65, 66, 69, 80, 82]
[9, 14, 21, 34, 44, 56, 60, 65, 66, 69, 80, 82]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;选择排序插入排序&#34;&gt;选择排序/插入排序&lt;/h2&gt;
&lt;p&gt;和动态规划的感觉类似，每一次迭代完成前i项的排序&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前k项已经从小到大排序了，现在看第k+1个&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序对比第k+1个应该插入到前K项的哪里，即对于前k项从右向左遍历，如果大于k+1项则往后挪1&lt;/li&gt;
&lt;li&gt;直到前K项中，所有大于第K+1项的都已经依次往后挪了一位，空出来的那位插入第K+1项&lt;/li&gt;
&lt;li&gt;结果——前k+1项已经从小到大排序了&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nums = [34,82,66,14,56,80,9,44,69,21,60,65]
for idx in range(1, len(nums)):
    tmp = nums[idx]
    j = 1
    while j &amp;lt;= idx and nums[idx - j] &amp;gt; tmp:  #  前面所有小于tmp 的都依次往后挪1
        nums[idx - j + 1] = nums[idx - j] 
        j += 1
    nums[idx - j + 1] = tmp   # 多出来的位置插入tmp
    print(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[34, 82, 66, 14, 56, 80, 9, 44, 69, 21, 60, 65]
[34, 66, 82, 14, 56, 80, 9, 44, 69, 21, 60, 65]
[14, 34, 66, 82, 56, 80, 9, 44, 69, 21, 60, 65]
[14, 34, 56, 66, 82, 80, 9, 44, 69, 21, 60, 65]
[14, 34, 56, 66, 80, 82, 9, 44, 69, 21, 60, 65]
[9, 14, 34, 56, 66, 80, 82, 44, 69, 21, 60, 65]
[9, 14, 34, 44, 56, 66, 80, 82, 69, 21, 60, 65]
[9, 14, 34, 44, 56, 66, 69, 80, 82, 21, 60, 65]
[9, 14, 21, 34, 44, 56, 66, 69, 80, 82, 60, 65]
[9, 14, 21, 34, 44, 56, 60, 66, 69, 80, 82, 65]
[9, 14, 21, 34, 44, 56, 60, 65, 66, 69, 80, 82]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;谢尔排序&#34;&gt;谢尔排序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;按照间隔划分子列表，分别插入排序后，整体更加接近有序。&lt;/li&gt;
&lt;li&gt;间隔越来越小，最后间隔为1时进行的插入排序，复杂度和对无序进行插入排序完全不同。&lt;/li&gt;
&lt;li&gt;复杂度为o(n^1.5)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nums = [34,82,66,14,56,80,9,44,69,21,60,65]
def gapsort(nums, gap):
    for i in range(gap, len(nums), gap):
        # 进行排序
        tmp =  nums[i]
        j = gap
        while j &amp;lt;= i and nums[i - j] &amp;gt; tmp:
            nums[i - j + gap] = nums[i - j]
            j += gap
        nums[i - j + gap] = tmp
    
    print([nums[i] for i in range(0, len(nums), gap)])  # 输出子列的排序结果
    return nums

def shellsort(nums):
    gap = len(nums)//2
    while gap&amp;gt;0:
        nums = gapsort(nums, gap)
        print(nums)     # 一次gap排序的结果
        gap = gap // 2
    return nums

shellsort(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[9, 34]
[9, 82, 66, 14, 56, 80, 34, 44, 69, 21, 60, 65]
[9, 14, 21, 34]
[9, 82, 66, 14, 56, 80, 21, 44, 69, 34, 60, 65]
[9, 14, 21, 34, 44, 56, 60, 65, 66, 69, 80, 82]
[9, 14, 21, 34, 44, 56, 60, 65, 66, 69, 80, 82]





[9, 14, 21, 34, 44, 56, 60, 65, 66, 69, 80, 82]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;归并排序&#34;&gt;归并排序&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def mergesort(nums):
    if len(nums) &amp;lt;= 1:
        return nums
    mid = len(nums) // 2
    left = mergesort(nums[:mid])
    right = mergesort(nums[mid:])

    # merge
    merged = []
    while left and right:
        if left[0] &amp;lt;= right[0]:
            merged.append(left.pop(0))
        else:
            merged.append(right.pop(0))
    merged.extend(left if left else right)
    return merged
    
nums = [34,82,66,14,56,80,9,44,69,21,60,65]
mergesort(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[9, 14, 21, 34, 44, 56, 60, 65, 66, 69, 80, 82]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;快速排序&#34;&gt;快速排序&lt;/h2&gt;
&lt;p&gt;思想：首先找一个基准值，设置一个左标和右标，从两侧开始：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左标对应数字应该小于基准值，如果大于，左标暂时不动，等待与右标交换&lt;/li&gt;
&lt;li&gt;右标对应数字应该大于基准值，如果小于，右标暂时不动，等待与左标交换&lt;/li&gt;
&lt;li&gt;左标往右移动，右标往左移动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使得list前面的都小于基准值，后面的都大于基准值&lt;/p&gt;
&lt;p&gt;对前面的部分和后面的部分分别递归——最后+连接起来，递归终值条件为长度&amp;lt;=1&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fastsort(nums):
    if len(nums) &amp;lt;= 1:
        return nums
    
    baseline = nums[0]
    left, right = 1, len(nums) - 1
    while left &amp;lt; right:
        if nums[left] &amp;lt; baseline:
            left += 1
        elif nums[right] &amp;gt; baseline:
            right -= 1
        elif nums[left] &amp;gt; baseline &amp;gt; nums[right]:
            nums[left], nums[right] = nums[right], nums[left]
    if nums[left] &amp;lt; nums[0]:
        nums[left], nums[0] = nums[0], nums[left]
    print(nums)
    l = fastsort(nums[:left])
    r = fastsort(nums[left:])

    return l + r

nums = [32,34,82,66,14,56,80,9,44,69,21,60,65]
fastsort(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[32, 21, 9, 14, 66, 56, 80, 82, 44, 69, 34, 60, 65]
[14, 21, 9, 32]
[14, 9, 21]
[9, 14]
[66, 56, 65, 60, 44, 34, 69, 82, 80]
[34, 56, 65, 60, 44, 66]
[34, 56, 65, 60, 44]
[56, 44, 60, 65]
[44, 56]
[60, 65]
[69, 82, 80]
[80, 82]





[9, 14, 21, 32, 34, 44, 56, 60, 65, 66, 69, 80, 82]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;topk-类问题&#34;&gt;topk 类问题&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;简单的可以用排序稍微变换一下，比如用快排&lt;/li&gt;
&lt;li&gt;用堆排序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;快排&#34;&gt;快排&lt;/h2&gt;
&lt;p&gt;e.g. 剑指 Offer 40. 最小的k个数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# topk 快排问题
nums = [32,34,82,66,14,56,80,9,44,69,21,60,65]

def minK(nums, k):
    if k &amp;lt; 1:
        return []
    if k &amp;gt;= len(nums):
        return nums

    tmp = nums[0]
    left, right = 1, len(nums) - 1
    while left &amp;lt; right:
        if nums[right] &amp;lt; tmp &amp;lt; nums[left]:
            nums[right], nums[left]  = nums[left], nums[right]
        elif nums[left] &amp;lt;= tmp:
            left += 1
        elif nums[right] &amp;gt;= tmp:
            right -= 1

    if nums[left] &amp;lt; tmp:
        nums[0], nums[left] = nums[left], nums[0]
    
    # 递归
    if left &amp;gt;= k:
        return minK(nums[:left], k)
    if left &amp;lt; k:
        return nums[:left] + minK(nums[left:], k - left)


# 测试
minK([32,21,82,66,14,56,80,9,44,69,21,60,66], k = 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[32, 21, 21, 9, 14]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;堆排序&#34;&gt;堆排序&lt;/h2&gt;
&lt;p&gt;我们可以使用一个大小为 k 的最大堆（大顶堆），将数组中的元素依次入堆，当堆的大小超过 k 时，便将多出的元素从堆顶弹出&lt;/p&gt;
&lt;p&gt;什么是堆——https://www.bilibili.com/video/BV1K4411X7fq?from=search&amp;amp;seid=15213146471374609847&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def getLeastNumbers(self, arr, k):
        if k == 0:
            return list()

        hp = [-x for x in arr[:k]]    # python 里面是最小堆，也就是根节点是最小值，所以用负号逆转过来
        heapq.heapify(hp)             # 前k项先直接加入堆
        
        for i in range(k, len(arr)):
            if -hp[0] &amp;gt; arr[i]:          # 如果当前值 &amp;gt; 堆里最大值
                heapq.heappop(hp)  # 就把最大值pop出来，把当前值加进去
                heapq.heappush(hp, -arr[i])
        ans = [-x for x in hp]
        return ans
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二叉堆&#34;&gt;二叉堆&lt;/h1&gt;
&lt;h2 id=&#34;二叉堆的概念理解&#34;&gt;二叉堆的概念理解&lt;/h2&gt;
&lt;p&gt;理论部分：&lt;/p&gt;
&lt;h3 id=&#34;用来做什么的实现优先队列&#34;&gt;用来做什么的？实现优先队列&lt;/h3&gt;
&lt;p&gt;用二叉堆来实现“优先队列”。优先队列和队列一样队尾进队首出，但是优先队列内有次序，优先级高的要作为VIP插队到前排。&lt;br&gt;
当然我们可以简单的用插入+排序来实现优先队列，但是插入复杂度o(n)排序复杂度o(nlogn)。如果用二叉堆实现，出入队列复杂度都是o(logn)！&lt;/p&gt;
&lt;h3 id=&#34;二叉堆的结构完全二叉树&#34;&gt;二叉堆的结构？完全二叉树&lt;/h3&gt;
&lt;p&gt;二叉堆是一颗完全二叉树，即&lt;strong&gt;节点都有左右两个子节点&lt;/strong&gt;，最多可有一个节点例外。这个性质使得树&lt;strong&gt;可以用数组&lt;/strong&gt;（比self.left&amp;amp;right这种链式存储更简单高效）来存储：&lt;/p&gt;
&lt;p&gt;当第一个元素放在索引为0的位置上时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;索引为 i 的左孩子的索引为（2*i + 1）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;索引为 i 的右孩子的索引为 （2*i + 2）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;索引为 i 的父节点的索引为 （i - 1）// 2&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;堆次序最大堆和最小堆&#34;&gt;堆次序？最大堆和最小堆&lt;/h3&gt;
&lt;p&gt;分为两种：最大堆和最小堆。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大堆：父结点的键值总是大于或等于任何一个子节点的键值；&lt;/li&gt;
&lt;li&gt;最小堆：父结点的键值总是小于或等于任何一个子节点的键值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实现二叉堆的功能&#34;&gt;实现二叉堆的功能&lt;/h2&gt;
&lt;p&gt;这里以最大堆为例&lt;/p&gt;
&lt;h3 id=&#34;1-insert&#34;&gt;1. insert&lt;/h3&gt;
&lt;p&gt;先放到列表尾，如果新加入的数据项比父节点要大，把它与父节点互换位置——不断上浮直到正确位置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MaxHeap:
    def __init__(self):
        self.heapList = []
        
    def insert(self, new):
        self.heapList.append(new)  # 1.插入到队尾
        self.percUp()     # 2.上浮操作
        
    def percUp(self):
        cur = len(self.heapList) - 1 
        while cur &amp;gt;= 1:
            parent = (cur - 1) //2
            if self.heapList[parent] &amp;lt; self.heapList[cur]:
                self.heapList[parent], self.heapList[cur]  = self.heapList[cur], self.heapList[parent]
                cur = parent
            else: break
                
    def getMax(self):
        return self.heapList[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;hp = MaxHeap()
hp.insert(1);hp.insert(4);hp.insert(3);hp.insert(11);hp.insert(7);
print(hp.heapList)
print(hp.getMax())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[11, 7, 3, 1, 4]
11
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-delmax&#34;&gt;2. delMax&lt;/h3&gt;
&lt;p&gt;跟节点是最大的，但困难的是移走根节点后如何恢复堆结构和堆次序——分两步走：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用最后一个节点来代替根节点。&lt;/li&gt;
&lt;li&gt;将新节点“下沉”来恢复堆次序，同样通过交换——如果小于子节点，&lt;strong&gt;和左右子节点中较大的进行交换&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MaxHeap(MaxHeap):
    
    def maxChild(self, i):   # 返回最大child 的索引
        left, right = 2 * i + 1,  2 * i + 2
        length = len(self.heapList) - 1 
        
        if length &amp;gt;= right:  # 左右都存在
            return left if self.heapList[left] &amp;gt; self.heapList[right]  else right  # return maxchild
        if length &amp;lt; left:      # 没有子节点
            return None
        else:                     # 只有左节点
            return left
    
    def percDown(self):     # 下沉
        cur = 0
        while self.maxChild(cur):
            maxchild = self.maxChild(cur)
            if self.heapList[cur] &amp;lt; self.heapList[maxchild]:
                self.heapList[cur], self.heapList[maxchild] = self.heapList[maxchild], self.heapList[cur]
            cur = maxchild
            
    def delMax(self):
        tmp = self.heapList[0]
        if len(self.heapList) == 1:
            self.heapList.pop()
        if len(self.heapList) &amp;gt; 1:
            self.heapList[0]  = self.heapList.pop()
            self.percDown()
        return tmp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用del操作可以实现排序:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;hp = MaxHeap()
hp.insert(1);hp.insert(4);hp.insert(7);hp.insert(11);hp.insert(3);

print(hp.heapList)
# 测试删除操作
res_sorted = []
while hp.heapList:
    res_sorted.append(hp.delMax())
    print(hp.heapList)

res_sorted   # 每次删掉的都是最大值——组成从大到小的顺序list，完成了堆排序
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[11, 7, 4, 1, 3]
[7, 3, 4, 1]
[4, 3, 1]
[3, 1]
[1]
[]





[11, 7, 4, 3, 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3用自己的函数进行堆排序min-k-问题&#34;&gt;3.用自己的函数进行堆排序——min k 问题&lt;/h3&gt;
&lt;p&gt;输入：数字list + k&lt;/p&gt;
&lt;p&gt;输出：最小的k个数字——用大根堆&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def getLeastNumbers(arr, k):
    if k &amp;gt;= len(arr):
        return arr
    
    hp = MaxHeap()
    # 1.先加入k个
    for i in range(k):
        hp.insert(arr[i])

    # 2.只保留当前最小的k个
    for j in range(k, len(arr)):
        if hp.getMax() &amp;gt; arr[j]:
            hp.delMax()
            hp.insert(arr[j])
    
    return hp.heapList

arr = [32,21,82,66,14,56,80,9,44,69,21,60,66]
getLeastNumbers(arr, k = 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[21, 21, 14, 9]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
">二分查找、快排、堆排序</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1201/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-59-i-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC&#34;&gt;剑指 Offer 59 - I. 滑动窗口的最大值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90&#34;&gt;剑指 Offer 61. 扑克牌中的顺子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97&#34;&gt;剑指 Offer 62. 圆圈中最后剩下的数字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6&#34;&gt;剑指 Offer 63. 股票的最大利润&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-68-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88&#34;&gt;剑指 Offer 68 -  二叉树的最近公共祖先&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE&#34;&gt;剑指 Offer 04. 二维数组中的查找&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%80%90%E8%A1%8C%E4%BA%8C%E5%88%86%E6%B3%95%E5%85%B6%E5%AE%9E%E6%95%88%E7%8E%87%E4%B9%9F%E8%BF%98%E4%B8%8D%E9%94%99&#34;&gt;逐行二分法，其实效率也还不错&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%9B%BE%E9%97%AE%E9%A2%98&#34;&gt;转化为图问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;剑指 Offer 07. 重建二叉树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84&#34;&gt;剑指 Offer 12. 矩阵中的路径&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;剑指-offer-59-i-滑动窗口的最大值&#34;&gt;剑指 Offer 59 - I. 滑动窗口的最大值&lt;/h1&gt;
&lt;p&gt;给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。&lt;/p&gt;
&lt;p&gt;注意不用切片和max——每次取max无法降低重复操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用一个队列维护最大值的index&lt;/strong&gt; 最大长度为3，单调递减，队首为当前窗口的最大值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nums = [1, 3, -1, 6, -3, 3, 1, 2, 5, 3, 6, 7]
k = 3
queue, res = [], []
for i in range(len(nums)):
    while queue and (nums[i] &amp;gt; nums[queue[-1]]):  
        queue.pop()   # 如果nums[i]比之前的大，就把队列里小的pop掉
    queue.append(i)  # 加入queue
    if i - queue[0] &amp;gt;= k:      # 如果最大值不在窗口内了，则pop掉
        queue.pop(0)
    if i &amp;gt;= k-1:  
        res.append(nums[queue[0]])  # 队首是当前窗口的最大值
print(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[3, 6, 6, 6, 3, 3, 5, 5, 6, 7]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-61-扑克牌中的顺子&#34;&gt;剑指 Offer 61. 扑克牌中的顺子&lt;/h1&gt;
&lt;p&gt;从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王(0)可以看成任意数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技巧点：没有重复 &amp;amp; 最大值-最小值 &amp;lt;= 4，就是顺子&lt;/strong&gt;&lt;br&gt;
[2,0,0,0,0]&lt;br&gt;
[0,0,0,0,0]&lt;br&gt;
[1,2,5,0,0]&lt;/p&gt;
&lt;p&gt;[1,2,2,3,0]  有重复&lt;br&gt;
[2,3,4,0,7] 极值&amp;gt;4&lt;/p&gt;
&lt;p&gt;所以首先进行一步检查重复，如果出现非0的重复直接 return False，然后再检查极差&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def isStraight(nums):
    d = dict()
    for num in nums:
        if num in d.keys() and num!=0:
            return False
        elif num!=0:
            d[num] = 1
    newnums = list(d.keys())
    if len(newnums) &amp;gt; 1 and  (max(newnums)-min(newnums) &amp;gt; 4):
        return False
    else:
        return True
isStraight([10,4,5,0,0])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;False
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-62-圆圈中最后剩下的数字&#34;&gt;剑指 Offer 62. 圆圈中最后剩下的数字&lt;/h1&gt;
&lt;p&gt;0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。&lt;/p&gt;
&lt;p&gt;例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基础版的可以理解为一个队列问题，每次把队首的移到队尾，如果移动了m次，pop就不再添加到队尾了&lt;/li&gt;
&lt;li&gt;复杂情况下这样就超时了，结合数学知识理解:
&lt;ul&gt;
&lt;li&gt;每次pop掉的索引是(i + m - 1) % len(a)&lt;/li&gt;
&lt;li&gt;递推公式 f(N,M)=(f(N−1,M)+M)%N&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 简单版——一个队列问题——超时
def lastRemaining(n, m):
    queue = list(range(n))
    while len(queue) &amp;gt; 1:
        for j in range(m):
            cur = queue.pop(0)
            if j &amp;lt; m-1:
                queue.append(cur)
        print(queue)
    return queue[0]
print(lastRemaining(5, 3))


# 结合数学逻辑，每次pop掉的索引是(i + m - 1) % len(a)——可以理解
def lastRemaining(n, m):
    queue = list(range(n))
    i = 0
    while len(queue) &amp;gt; 1:
        i = ( i + m - 1 ) % len(queue)
        queue.pop(i)
    return queue[0]
print(lastRemaining(5, 3))
print(lastRemaining(500, 300))


# 最佳解答——递推公式——其实使用了数学逻辑
def lastRemaining(n, m):
    # 递推公式 f(N,M)=(f(N−1,M)+M)%N
    # // f(n,m) = (f(n-1,m)+m) % n
    # // 我们把数字看做人，报到 m 的人，直接干掉
    # // n 代表的是当前人数，m 代表的是报数
    # // 假设一共有 11 人,最后那个胜利的人下标是 6
    # // 在下一轮 10 人的时候，胜利者的编号往前移动三格(假设m=3)
    # // 那假设我们有 10 人，胜利者下标为3，到 11 人的时候胜利者下标是 6
    # // 所以公式为 fn = (fn-1 + m) % n
    # // 如果只有一个人，那么下标为0
    last = 0
    # 往回推 推出最出最开始人数是n的时候last的index 
    for i in range(2, n+1):
        last = (last+m)%i
    return last
print(lastRemaining(500, 300))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[3, 4, 0, 1]
[1, 3, 4]
[1, 3]
[3]
3
3
335
335
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-63-股票的最大利润&#34;&gt;剑指 Offer 63. 股票的最大利润&lt;/h1&gt;
&lt;p&gt;假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票&lt;strong&gt;一次&lt;/strong&gt;可能获得的最大利润是多少？&lt;/p&gt;
&lt;p&gt;输入: [7,1,5,3,6,4]&lt;br&gt;
输出: 5&lt;br&gt;
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&lt;br&gt;
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。&lt;br&gt;
示例 2:&lt;/p&gt;
&lt;p&gt;输入: [7,6,4,3,1]&lt;br&gt;
输出: 0&lt;br&gt;
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def maxprofit(prices):
    profit = 0
    minprice = prices[0]
    if len(prices)&amp;lt;2:
        return profit
    for i in range(1, len(prices)):
        if prices[i] &amp;lt; minprice:
            minprice = prices[i]
        elif prices[i] &amp;gt; minprice  + profit:
            profit = prices[i] - minprice
    return profit
maxprofit([7,1,5,3,6,4]),maxprofit([7,6,4,3,1])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(5, 0)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-68-二叉树的最近公共祖先&#34;&gt;剑指 Offer 68 -  二叉树的最近公共祖先&lt;/h1&gt;
&lt;p&gt;给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

# 定义测试用例
t1 = TreeNode(5)
t2 = TreeNode(3)
t3 = TreeNode(9)
t1.left = t2; t1.right = t3
t4 = TreeNode(1)
t5 = TreeNode(4)
t6 = TreeNode(12)
t7 = TreeNode(18)
t2.left = t4; t2.right = t5; t3.right = t6;t6.right = t7
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    # 1.如果是二叉搜索树，非常直接，题目给出pq一定有公共祖先
    def lowestCommonAncestor(self, root, p, q):
        if root.val &amp;gt; max(p.val, q.val):
            return self.lowestCommonAncestor(root.left, p, q)
        if root.val &amp;lt; min(p.val, q.val):
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def lowestCommonAncestor(root, p, q):
    # 2.不是二叉搜索树，递归的时候有技巧
    if not root:
        return None
    if root == p or root == q:
        return root
    else:
        l1 = lowestCommonAncestor(root.left, p, q)
        l2 =  lowestCommonAncestor(root.right, p, q)
    if l1 and l2:
        return root
    elif l1 or l2:
        return l1 or l2
    else:
        return None
print(lowestCommonAncestor(t1,t4,t7).val)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;5
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-04-二维数组中的查找&#34;&gt;剑指 Offer 04. 二维数组中的查找&lt;/h1&gt;
&lt;p&gt;每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
 [1,   4,   7,   11,  15],
 [2,   5,   8,  12,  19],
 [3,   6,   9,  16,  22],
 [10,  13,  14, 17,  24],
 [18,  21,  23, 26, 30],
 [25,  28, 31, 33, 40]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;逐行二分法其实效率也还不错&#34;&gt;逐行二分法，其实效率也还不错&lt;/h2&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果行长度小于列长度——转置，保证遍历行min(m,n)次，每行二分查找时间复杂度为o(log(max(m,n)))，总复杂度O(min(m,n)*log(max(m,n)))&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def findNumberIn2DArray(self, matrix, target):
        # 定义二分查找
        def binarySearch1(alist,item):
            if not alist:
                return False
            left, right = 0, len(alist) - 1
            while left &amp;lt;= right:
                if item &amp;gt; alist[right] or item &amp;lt; alist[left]:
                    return False
                mid = (right + left)//2
                if alist[mid] == item:
                    return True
                if alist[mid] &amp;lt; item:
                    left = mid+1
                if alist[mid] &amp;gt; item:
                    right = mid - 1
            return False
        
        # 如果是空，直接F
        if not len(matrix) or not len(matrix[0]):
            return False
        # 如果行长&amp;lt;列长——转置，从而实现只遍历min(m,n)次
        if len(matrix[0]) &amp;lt; len(matrix):  
            matrix = zip(*matrix)
        # 开始逐行二分:
        for row_list in matrix:
            if binarySearch1(row_list, target):  # 找到了
                return True
        return False

s7 = Solution()
matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30],[2,28,31,33,40]]
s7.findNumberIn2DArray(matrix, 17)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;转化为图问题&#34;&gt;转化为图问题&lt;/h2&gt;
&lt;p&gt;时间复杂度 O(M+N)&lt;/p&gt;
&lt;p&gt;这里的旋转之后用二叉搜索树，从左上角或者右下角开始搜索的想法，直呼好家伙！！！神仙思路&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def findTarget(matrix, target):
    # 从左下角开始
    i, j = len(matrix)-1, 0

    while i &amp;gt;=0 and j &amp;lt; len(matrix[0]):
        cur = matrix[i][j]
        if cur &amp;lt; target:
            j += 1
        if cur &amp;gt; target:
            i -= 1
        if cur == target:
            return True
    return False  # 包括没找到、空值、等等各种情形

findTarget(matrix, 16)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-07-重建二叉树&#34;&gt;剑指 Offer 07. 重建二叉树&lt;/h1&gt;
&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;
&lt;p&gt;前序遍历 preorder = [3,9,4,1,6,20,15,8,11,7]&lt;br&gt;
中序遍历 inorder = [1,4,9,6,3,8,15,11,20,7]&lt;/p&gt;
&lt;p&gt;自己的逻辑可以看出，这是一个递归问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
class TreeNode:
     def __init__(self, x):
            self.val = x
            self.left = None
            self.right = None

def rebuild(preorder, inorder):
    n = len(preorder)
    if not n:
        return None
    root = TreeNode(preorder[0])
    i = inorder.index(preorder[0])
    root.left = rebuild(preorder[1:i+1],  inorder[:i])
    root.right = rebuild( preorder[i+1:], inorder[i+1:])
    return root

preorder = [3,9,4,1,6,20,15,8,11,7]
inorder = [1,4,9,6,3,8,15,11,20,7]
t1 = rebuild(preorder, inorder)
t1.val
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。
def print_row(root):
    row_list = [root]
    res = []
    while row_list:
        row_res = []      
        for i in range(len(row_list)):
            cur = row_list.pop(0)
            row_res.append(cur.val)
            if cur.left:
                row_list.append(cur.left)
            if cur.right:
                row_list.append(cur.right)
        res.append(row_res)
    return res

print_row(t1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[[3], [9, 20], [4, 6, 15, 7], [1, 8, 11]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-12-矩阵中的路径&#34;&gt;剑指 Offer 12. 矩阵中的路径&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;输入：board = [[&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;E&amp;quot;],[&amp;quot;S&amp;quot;,&amp;quot;F&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;S&amp;quot;],[&amp;quot;A&amp;quot;,&amp;quot;D&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;E&amp;quot;]], word = &amp;quot;ABCCED&amp;quot;&lt;/li&gt;
&lt;li&gt;输出：true&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;[[&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;E&amp;quot;],
[&amp;quot;S&amp;quot;,&amp;quot;F&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;S&amp;quot;],
[&amp;quot;A&amp;quot;,&amp;quot;D&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;E&amp;quot;]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉是一个图的问题——DFS问题，类似骑士周游&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我的想法写的太复杂啦：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 我的解答
def findPath(board, word):
    words = list(word)

    def dfs(location, k):
        if k &amp;gt;= len(words) or not board[location[0]][location[1]] or words[k] != board[location[0]][location[1]]:
            return False
        if k == len(words) - 1: 
            print(location)
            return True
        print(location)
        board[location[0]][location[1]] = None
        nexts = next_step(board, location)
        if not nexts:
            return False
        for _ in nexts:
            if dfs(_, k+1):
                return True
        board[location[0]][location[1]] = words[k]
        return False

    def next_step(matrix, location):
        res = []
        if not len(matrix) or not len(matrix[0]):
            return res
        m = len(matrix) - 1
        n = len(matrix[0]) - 1
        cur_x, cur_y = location[0], location[1]
        if cur_x &amp;gt;= 1:
            res.append([cur_x - 1, cur_y])
        if cur_y &amp;gt;= 1:
            res.append([cur_x, cur_y - 1])
        if cur_x &amp;lt;= m - 1:
            res.append([cur_x +1, cur_y])
        if cur_y &amp;lt;= n - 1:
            res.append([cur_x, cur_y + 1])
        return res

    def getlocation(matrix, word):
        res = []
        if not len(matrix) or not len(matrix[0]):
            return res
        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if matrix[i][j] == word:
                    res.append([i, j])     
        return res

    start = getlocation(board, words[0])
    
    for s in start:
        if dfs(s, 0):
            return True
    return False


board = [[&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;E&amp;quot;],[&amp;quot;S&amp;quot;,&amp;quot;F&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;S&amp;quot;],[&amp;quot;A&amp;quot;,&amp;quot;D&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;E&amp;quot;]]
findPath(board, &#39;ABCCEDFSA&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[0, 0]
[0, 1]
[0, 2]
[1, 2]
[2, 2]
[2, 1]
[1, 1]
[1, 0]
[2, 0]





True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;标准答案真的清晰简单，好好学好好看：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;递归的时候一定想清楚函数（）里面是什么更加简洁清晰，多想想在下手敲&lt;/li&gt;
&lt;li&gt;可以合并的内容尽量合并起来不要再写上面这样又臭又长的code啦&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def exist(board, word):
    def dfs(i, j, k):
        # 结束条件
        if not 0&amp;lt;=i&amp;lt;len(board) or not 0&amp;lt;=j&amp;lt;len(board[0]) or board[i][j]!=word[k]:
            return False
        if k==len(word)-1:
            return True
        board[i][j] = None
        # 递归
        return dfs(i+1, j, k+1) or dfs(i-1, j, k+1) or dfs(i, j+1, k+1) or dfs(i, j-1, k+1)
    
    for i in range(len(board)):
        for j in range(len(board[0])):
            if dfs(i, j, 0):
                return True
    return False

board = [[&amp;quot;A&amp;quot;,&amp;quot;B&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;E&amp;quot;],[&amp;quot;S&amp;quot;,&amp;quot;F&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;S&amp;quot;],[&amp;quot;A&amp;quot;,&amp;quot;D&amp;quot;,&amp;quot;E&amp;quot;,&amp;quot;E&amp;quot;]]
exist(board, &#39;ABCCEDFSA&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;True
&lt;/code&gt;&lt;/pre&gt;
">练习题 Day7</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/jin-qi-zi-xue-ji-hua/"" data-c="
          &lt;p&gt;研一自学计划包括：数据结构与算法、python、SQL、JAVA、Linux、爬虫等；理论知识部分包括机器学习算法、深度学习相关概念、计算机系统原理等等，&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;python:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/shu-ju-jie-gou-yu-suan-fa-python-ban/&#34;&gt;数据结构与算法&lt;/a&gt; ——完结✔️&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/xi-lie-leetcode-shua-ti-bi-ji/&#34;&gt;leetcode练习题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/python-pa-chong-xpath/&#34;&gt;爬虫实践&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/0923-0924/&#34;&gt;深度学习开源框架&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;数据挖掘课大作业&lt;/li&gt;
&lt;li&gt;《利用python进行数据分析》&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/xi-lie-shu-ju-fen-xi-xiao-xiang-mu/&#34;&gt;数据分析小项目&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;理论知识层面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/shou-dong-shi-xian-ji-qi-xue-xi-suan-fa-xi-lie/&#34;&gt;传统机器学习算法手动实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;NLP方面，word2vec&lt;/li&gt;
&lt;li&gt;深度学习方面，强化学习，GAN等&lt;/li&gt;
&lt;li&gt;推荐算法方面，协同过滤， pagerank top_K&lt;/li&gt;
&lt;li&gt;计算机系统的各种概念CPU Cache 的运行机制&lt;/li&gt;
&lt;li&gt;最优化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;SQL:&lt;br&gt;
&lt;a href=&#34;https://yangggshuyi.github.io/post/mysql1/&#34;&gt;【系列】mysql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1UE41147KC?p=5&#34;&gt;中字 | mysql教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.bilibili.com/video/BV1xh411Z79d/?spm_id_from=333.788.videocard.0&#34;&gt;进阶理解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JAVA&lt;br&gt;
&lt;a href=&#34;https://yangggshuyi.github.io/post/java/&#34;&gt;基础知识&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Linux&lt;/p&gt;
">【2020】自学计划</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1129/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6&#34;&gt;剑指 Offer 50. 第一个只出现一次的字符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9&#34;&gt;剑指 Offer 52. 两个链表的第一个公共节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-53-i-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-i&#34;&gt;剑指 Offer 53 - I. 在排序数组中查找数字 I&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-53-ii-0~n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97&#34;&gt;剑指 Offer 53 - II. 0～n-1中缺失的数字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9&#34;&gt;剑指 Offer 54. 二叉搜索树的第k大节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E9%97%AE%E9%A2%98&#34;&gt;二叉搜索树的遍历问题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95&#34;&gt;递归解法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%AD%E4%BB%A3%E8%A7%A3%E6%B3%95&#34;&gt;迭代解法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-55-ii-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;剑指 Offer 55 - II. 平衡二叉树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-56-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%95%B0%E5%AD%97%E7%9A%84%E6%AC%A1%E6%95%B0&#34;&gt;剑指 Offer 56 数组中出现数字的次数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-57-%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%AA%E6%95%B0%E5%AD%97&#34;&gt;剑指 Offer 57. 和为某个数字&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E6%89%BE%E5%87%BA%E5%92%8C%E4%B8%BAx%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97&#34;&gt;1.找出和为X的两个数字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97&#34;&gt;找出所有和为s的连续正数序列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-58-i-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F&#34;&gt;剑指 Offer 58 - I. 翻转单词顺序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-58-ii-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2&#34;&gt;剑指 Offer 58 - II. 左旋转字符串&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;剑指-offer-50-第一个只出现一次的字符&#34;&gt;剑指 Offer 50. 第一个只出现一次的字符&lt;/h1&gt;
&lt;p&gt;在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。&lt;/p&gt;
&lt;p&gt;s = &amp;quot;abaccdeff&amp;quot;&lt;br&gt;
返回 &amp;quot;b&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def firstUniqChar(self, s):
        lists = list(s)
        d = dict()
        
        for ss in lists:
             d[ss] = not ss in d  # 没出现过=1，出现过=0
        
        find = False
        for key in d.keys():
            if d[key]: # 没出现过=1
                find = True
                break
        
        if find:
            return key
        if not find:
            return &#39; &#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-52-两个链表的第一个公共节点&#34;&gt;剑指 Offer 52. 两个链表的第一个公共节点&lt;/h1&gt;
&lt;p&gt;交替遍历！！！这段code 我直接好家伙！！&lt;/p&gt;
&lt;p&gt;巧妙的消除两个链表的长度差&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    
    def getIntersectionNode(self, headA, headB):
        node1, node2 = headA, headB
        
        while node1 != node2:
            node1 = node1.next if node1 else headB
            # 当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点
            node2 = node2.next if node2 else headA
            # 当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点.

        return node1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-53-i-在排序数组中查找数字-i&#34;&gt;剑指 Offer 53 - I. 在排序数组中查找数字 I&lt;/h1&gt;
&lt;p&gt;统计一个数字在排序数组中出现的次数。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nums = [5,7,7,8,8,10]
target = 8
count = 0
for num in nums:
    if num == target:
        count += 1
    if num &amp;gt; target:
        break
print(count)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-53-ii-0~n-1中缺失的数字&#34;&gt;剑指 Offer 53 - II. 0～n-1中缺失的数字&lt;/h1&gt;
&lt;p&gt;一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。&lt;/p&gt;
&lt;p&gt;输入: [0,1,2,3,4,5,6,7,9] 输出: 8&lt;br&gt;
输入：[1,2] 输出0&lt;br&gt;
输入：[0,1] 输出2&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def missingNumber(self, nums):
        &#39;&#39;&#39;
        解法一
        for _ in range(len(nums)+1):
            if _ not in nums:
                return _
        &#39;&#39;&#39;
        # 解法二（数学逻辑）
        n = len(nums)
        total = n * (n + 1) // 2
        return total - sum(nums)      
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-54-二叉搜索树的第k大节点&#34;&gt;剑指 Offer 54. 二叉搜索树的第k大节点&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

# 定义测试用例
t1 = TreeNode(5)
t2 = TreeNode(3)
t3 = TreeNode(9)
t1.left = t2; t1.right = t3
t4 = TreeNode(1)
t5 = TreeNode(4)
t6 = TreeNode(18)
t2.left = t4; t2.right = t5; t3.right = t6
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;二叉搜索树的遍历问题&#34;&gt;二叉搜索树的遍历问题&lt;/h1&gt;
&lt;p&gt;参考链接题解https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/tu-jie-er-cha-shu-de-si-chong-bian-li-by-z1m/&lt;/p&gt;
&lt;p&gt;首先搞清楚遍历规则：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1606724691395.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;前序：5 3 1 4 9 18&lt;/li&gt;
&lt;li&gt;中序 1 3 4 5 9 18&lt;/li&gt;
&lt;li&gt;后序 1 4 3 18 9 5&lt;/li&gt;
&lt;li&gt;层次 5 3 9 1 4 18&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;递归解法&#34;&gt;递归解法&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 前序
def qianxu(root):
    res = []
    def dfs(root):
        nonlocal res
        if not root:
            return
        else:
            res.append(root.val)   # 变动位置
            dfs(root.left)
            dfs(root.right)
    dfs(root)
    return res
print(qianxu(t1))

# 中序
def zhongxu(root):
    res = []
    def dfs(root):
        nonlocal res
        if not root:
            return
        else:
            dfs(root.left)
            res.append(root.val)  # 变动位置
            dfs(root.right)
    dfs(root)
    return res
print(zhongxu(t1))

# 后序
def houxu(root):
    res = []
    def dfs(root):
        nonlocal res
        if not root:
            return
        else:
            dfs(root.left)
            dfs(root.right)
            res.append(root.val)  # 变动位置
    dfs(root)
    return res
print(houxu(t1))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;迭代解法&#34;&gt;迭代解法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;层次遍历——队列，左子节点先进先出&lt;/li&gt;
&lt;li&gt;前序遍历——1.栈，右子节点先进后出，之后append；2.栈，左子节点一边先进一边，再轮到右子节点&lt;/li&gt;
&lt;li&gt;中序遍历——栈，左子节点先进，全进之后append&lt;/li&gt;
&lt;li&gt;后序遍历——1.前序遍历左右互换，最后反向输出；2.用一个flag 让根节点保持在队伍前方，从而晚于子节点输出。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 层次——队列迭代
def cengci(root):
    res = []
    if not root:
        return res
    nodelist = [root]
    while nodelist:
        cur = nodelist.pop(0)
        res.append(cur.val)
        if cur.left:
            nodelist.append(cur.left)
        if cur.right:
            nodelist.append(cur.right)
    return res
print(cengci(t1))


# 前序遍历迭代第一种
def qianxu2(root):
    res = []
    if not root:
        return res
    nodelist = [root]
    while nodelist:
        # nodelist右子节点先进——栈pop左子节点先出
        cur = nodelist.pop() 
        res.append(cur.val)
        if cur.right:
            nodelist.append(cur.right)
        if cur.left:
            nodelist.append(cur.left)
    return res
print(qianxu2(t1))

# 前序遍历迭代第二种
def qianxu2(root):
    res = []
    if not root:
        return res
    nodelist = []
    cur = root
    while nodelist or cur:
        while cur:
            nodelist.append(cur)
            res.append(cur.val)
            cur = cur.left
        cur = nodelist.pop()
        cur = cur.right
    return res
print(qianxu2(t1))


# 中序遍历
def zhongxu2(root):
    res = []
    if not root:
        return res
    cur = root
    nodelist = []
    while nodelist or cur:
        while cur: 
            nodelist.append(cur)
            cur = cur.left
        cur = nodelist.pop()
        res.append(cur.val)
        cur = cur.right
    return res
print(zhongxu2(t1))

# 后序遍历第一种——把前序左右反过来，然后倒序输出
def houxu2(root):
    res = []
    if not root:
        return res
    nodelist = []
    cur = root
    while nodelist or cur:
        while cur:
            nodelist.append(cur)
            res.append(cur.val)
            cur = cur.right
        tmp = nodelist.pop()
        cur = tmp.left
    return res[::-1]
print(houxu2(t1))

# 后序遍历第二种——栈操作，前序根-左-右，后续左-右-根，
# 如果是根节点先append回去最后pop
def houxu3(root):
    res = []
    if not root:
        return res
    nodelist = [(0, root)]
    while nodelist:
        flag, cur = nodelist.pop()
        if flag == 1:  # 如果是1
            res.append(cur.val)
        else:  # 如果不是重新append回去
            nodelist.append((1, cur))
            if cur.right:
                nodelist.append((0, cur.right))
            if cur.left:
                nodelist.append((0, cur.left))
    return res

print(houxu3(t1))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-55-ii-平衡二叉树&#34;&gt;剑指 Offer 55 - II. 平衡二叉树&lt;/h1&gt;
&lt;p&gt;如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isBalanced(self, root: TreeNode) -&amp;gt; bool:
        def maxDepth(root):
            if not root:
                return 0
            return max(maxDepth(root.left),maxDepth(root.right))+1
        if not root:
            return True
        diff = abs(maxDepth(root.left) - maxDepth(root.right))
        if diff &amp;gt; 1:
            return False
        else:
            return self.isBalanced(root.left) and self.isBalanced(root.right) 
s7 = Solution()
s7.isBalanced(t1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-56-数组中出现数字的次数&#34;&gt;剑指 Offer 56 数组中出现数字的次数&lt;/h1&gt;
&lt;p&gt;——字典通解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。
def findUnique(nums):
    d = dict()
    res = []
    for num in nums:
        d[num] = 0 if num in d else 1
    for num in d:
        if d[num]:
            res.append(num)
    return res
findUnique([9,1,7,9,7,9,7]), findUnique([1,2,10,4,1,4,3,3])
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-57-和为某个数字&#34;&gt;剑指 Offer 57. 和为某个数字&lt;/h1&gt;
&lt;h2 id=&#34;1找出和为x的两个数字&#34;&gt;1.找出和为X的两个数字&lt;/h2&gt;
&lt;p&gt;输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开始的二重for暴力超时了！&lt;/li&gt;
&lt;li&gt;要充分利用这个&lt;strong&gt;数组递增&lt;/strong&gt;的性质，提高运算效率&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def twoSum(self, nums, target):
        # 使用双指针
        n = len(nums)
        left, right = 0, n-1
        while left &amp;lt; right:
            tmpsum = nums[left] + nums[right] 
            if tmpsum == target:
                return [nums[left], nums[right]]
            if tmpsum &amp;gt; target:
                right -= 1
            if tmpsum &amp;lt; target:
                left += 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;找出所有和为s的连续正数序列&#34;&gt;找出所有和为s的连续正数序列&lt;/h2&gt;
&lt;p&gt;输入一个正整数 target ，输出所有和为 target 的&lt;strong&gt;连续正整数序列&lt;/strong&gt;（至少含有两个数）。&lt;/p&gt;
&lt;p&gt;序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;方法一：循环/滑动窗口&lt;br&gt;
target = 9&lt;br&gt;
12345如果有一颗等于则输出，一旦大于就break，下一次从2开始&lt;/li&gt;
&lt;li&gt;方法二：利用&lt;strong&gt;求和公式&lt;/strong&gt;找到i，从而减少一次循环次数——时间复杂度大大降低&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 1.方法1  二重循环
target = 15
res = []
for i in range(1, target//2 + 1):  # 至少含有两个数字
    tmpsum = i
    tmp_res = [i]
    for j in range(i+1, target):
        tmpsum += j
        tmp_res.append(j)
        if tmpsum == target:
            break
        if tmpsum &amp;gt; target:
            tmp_res =  []
            break
    if tmp_res:
        res.append(tmp_res)
print(res)

### 2.方法2  滑动窗口
i, j = 1, 2
res2 = []
while j &amp;lt;= target//2 + 1 and i &amp;lt; j:
    cur_sum = sum(list(range(i, j+1)))  # 当前和
    if cur_sum &amp;lt; target:
        j +=1
    if cur_sum &amp;gt; target:
        i +=1
    if cur_sum == target:
        res2.append(list(range(i, j+1)))
        i += 1  # 进行下一种情况
print(res2)

### 3.运用数列求和公式找到可能的i，从而减少一次循环次数
res3 = []
for k in range(1, target//2):
    i = ((2 * target) / (k+1) - k) / 2
    if i &amp;gt;0 and i%1==0:
        res3.append(list(range(int(i), int(i)+k+1)))
print(res3[::-1])
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-58-i-翻转单词顺序&#34;&gt;剑指 Offer 58 - I. 翻转单词顺序&lt;/h1&gt;
&lt;p&gt;输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串&amp;quot;I am a student. &amp;quot;，则输出&amp;quot;student. a am I&amp;quot;。同时删掉多余的空格！&lt;/p&gt;
&lt;p&gt;e.g.输入: &amp;quot;  hello world!  &amp;quot;&lt;br&gt;
输出: &amp;quot;world! hello&amp;quot;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;str = &#39;   I  am a  a student.  !!!   &#39;
strlist = list( str )
res = []
i = 0
while i &amp;lt; len( strlist ):
    tmp = []
    j = 0
    # 每一个单词作为一个[] 整体
    while ( i + j &amp;lt; len(strlist) ) and ( strlist[ i + j] != &#39; &#39; ):
        tmp.append(strlist[ i + j ])
        j += 1
    # 对下一个字符进行操作
    i += j + 1
    if tmp:
        res.append(tmp)
# 结果——一个嵌套list
print(res)
 
# 用一个栈倒序输出
ress = []
while res:  
    ress.append(&#39;&#39;.join(res.pop()))
print(&#39; &#39;.join(ress))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[[&#39;I&#39;], [&#39;a&#39;, &#39;m&#39;], [&#39;a&#39;], [&#39;a&#39;], [&#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;d&#39;, &#39;e&#39;, &#39;n&#39;, &#39;t&#39;, &#39;.&#39;], [&#39;!&#39;, &#39;!&#39;, &#39;!&#39;]]
!!! student. a a am I
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-58-ii-左旋转字符串&#34;&gt;剑指 Offer 58 - II. 左旋转字符串&lt;/h1&gt;
&lt;p&gt;是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串&amp;quot;abcdefg&amp;quot;和数字2，该函数将返回左旋转两位得到的结果&amp;quot;cdefgab&amp;quot;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;s = &amp;quot;yangshuyi&amp;quot;;n = 4
# 1.直接切片
print(s[n:] + s[:n])
# 2.队列问题
strlist = list(s)
for i in range(n):
    tmp = strlist.pop(0)
    strlist.append(tmp)
print(&#39;&#39;.join(strlist))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;shuyiyang
shuyiyang
&lt;/code&gt;&lt;/pre&gt;
">练习题 Day6</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1126/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0&#34;&gt;剑指 Offer 15. 二进制中1的个数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9&#34;&gt;剑指 Offer 18. 删除链表的节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2&#34;&gt;剑指 Offer 21. 调整数组顺序使奇数位于偶数前面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9&#34;&gt;剑指 Offer 22. 链表中倒数第k个节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8&#34;&gt;剑指 Offer 24. 反转链表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8&#34;&gt;剑指 Offer 25. 合并两个排序的链表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F&#34;&gt;剑指 Offer 27. 二叉树的镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;剑指 Offer 28. 对称的二叉树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5&#34;&gt;剑指 Offer 29. 顺时针打印矩阵&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%80%E6%AD%A5p%E7%BB%B4%E7%9F%A9%E9%98%B5&#34;&gt;第一步，p维矩阵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%BA%8C%E6%AD%A5m-x-n-%E7%BB%B4%E7%9F%A9%E9%98%B5&#34;&gt;第二步，m x n 维矩阵&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88&#34;&gt;剑指 Offer 30. 包含min函数的栈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-32-%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;剑指 Offer 32 打印二叉树&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B-%E6%AF%8F%E4%B8%80%E5%B1%82%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3&#34;&gt;从上到下、每一层从左到右&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%AF%8F%E4%B8%80%E5%B1%82%E6%89%93%E5%8D%B0%E5%88%B0%E4%B8%80%E8%A1%8C&#34;&gt;每一层打印到一行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;之字形顺序打印二叉树&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-39-%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97&#34;&gt;剑指 Offer 39. 出现次数超过一半的数字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0&#34;&gt;剑指 Offer 40. 最小的k个数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C&#34;&gt;剑指 Offer 42. 连续子数组的最大和&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problemset/lcof/&#34;&gt;剑指 Offer 第二版&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;剑指-offer-15-二进制中1的个数&#34;&gt;剑指 Offer 15. 二进制中1的个数&lt;/h1&gt;
&lt;p&gt;输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。&lt;/p&gt;
&lt;p&gt;输入：00000000000000000000000000001011&lt;/p&gt;
&lt;p&gt;输出：3&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 简单思路，二进制转化，随后统计
n = 99
res = []
while n &amp;gt; 0:
    res.append(n % 2)
    n = n // 2
binary = []
while res:
    binary.append(res.pop())
print(binary)
count = 0
for i in range(len(binary)):
    if binary[i] == 1:
        count += 1
print(count)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1, 1, 0, 0, 0, 1, 1]
4
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-18-删除链表的节点&#34;&gt;剑指 Offer 18. 删除链表的节点&lt;/h1&gt;
&lt;p&gt;链表中节点的值互不相同&lt;/p&gt;
&lt;p&gt;给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。&lt;/p&gt;
&lt;p&gt;返回删除后的链表的头节点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    
    def deletNode(self, head, val):
        
        if head.val == val:
            return head.next
        pred = head
        
        while pred.next:
            if pred.next.val == val:
                pred.next = pred.next.next
                return head
            else:
                pred = pred.next
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-21-调整数组顺序使奇数位于偶数前面&#34;&gt;剑指 Offer 21. 调整数组顺序使奇数位于偶数前面&lt;/h1&gt;
&lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nums = [1,6,2,5,3,4]
res = []
for i in nums:
    if i % 2:
        res.append(i)
for j in nums:
    if j % 2 == 0:
        res.append(j)
print(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1, 5, 3, 6, 2, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-22-链表中倒数第k个节点&#34;&gt;剑指 Offer 22. 链表中倒数第k个节点&lt;/h1&gt;
&lt;p&gt;本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getKthFromEnd(self, head, k):
        nodelist = []
        current = head
        while current:
            nodelist.append(current)
            current = current.next
        for i in range(k - 1):
            nodelist.pop()
        return nodelist.pop()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-24-反转链表&#34;&gt;剑指 Offer 24. 反转链表&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head):
        pre, cur = None, head
        while cur:
            tmp = cur.next
            cur.next = pre
            pre = cur
            cur = tmp
        return pre
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-25-合并两个排序的链表&#34;&gt;剑指 Offer 25. 合并两个排序的链表&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeTwoLists(self, l1, l2):
        start = ListNode()
        node = start
        while (l1 or l2):
            # 只有一个
            if not (l1 and l2):
                node.next = l1 or l2
                break
            # 都非空，比大小
            elif l1.val &amp;lt; l2.val:
                node.next = l1
                l1 = l1.next
            else:
                node.next = l2
                l2 = l2.next
            node = node.next
        return start.next
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-27-二叉树的镜像&#34;&gt;剑指 Offer 27. 二叉树的镜像&lt;/h1&gt;
&lt;p&gt;请完成一个函数，输入一个二叉树，该函数输出它的镜像。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

# 解法一
class Solution:
    def mirrorTree(self, root):
        return self.mirror(root)

    def mirror(self, node):
        if node:  # 非空
            if node.left and node.right:  # 左右都有
                node.right, node.left = self.mirror(node.left), self.mirror(node.right)
            elif node.left:  # 只有一边
                node.left, node.right = None, self.mirror(node.left)
            elif node.right: # 只有一边
                node.right, node.left = None, self.mirror(node.right)
        return node

# 解法二（更简洁）
    def mirrorTree(self, root):
        if root:
            # 关键点在于先左右子节点交换！！！，就不用考虑赋值None了
            root.left, root.right = root.right, root.left 
            if root.left:
                root.left = self.mirrorTree(root.left)
            if root.right:
                root.right = self.mirrorTree(root.right)
        return root
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-28-对称的二叉树&#34;&gt;剑指 Offer 28. 对称的二叉树&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root):
        if not root:   # none，直接返回T
            return True
        else: 
            return self.ifmatch(root.left, root.right)
        
    def ifmatch(self, a, b):
        if (not a) and (not b):  # 都是none
            return True
        elif a and b and a.val == b.val:    # 都存在且数值相等，对子节点递归！
            return self.ifmatch(a.left, b.right) and self.ifmatch(a.right, b.left) 
        # 只有一个存在或者数值不相等
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-29-顺时针打印矩阵&#34;&gt;剑指 Offer 29. 顺时针打印矩阵&lt;/h1&gt;
&lt;p&gt;按照从外向里以顺时针的顺序依次打印出每一个数字。&lt;/p&gt;
&lt;h2 id=&#34;第一步p维矩阵&#34;&gt;第一步，p维矩阵&lt;/h2&gt;
&lt;p&gt;输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1  2  3  4
5  6  7  8
9  10 11  12
13 14 15 16 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输出：[1,2,3,6,9,8,7,4,5]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def printmatrix(res, matrix):
    p = len(matrix)
    # 停止条件
    
    if p == 1:
        res.append(matrix)
        return
    
    for i in range(0, p):
        res.append(matrix[0][i])
    for i in range(1, p - 1):
        res.append(matrix[i][p - 1])
    for i in range(1, p):
        res.append(matrix[p - 1 ][p - i])
    for i in range(1, p):
        res.append(matrix[p - i][0])
        
    if p &amp;gt;= 3:
        return printmatrix(res, [x[1: len(matrix)-1] for x in matrix[1:len(matrix)-1]])
    
res = []
matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
printmatrix(res, matrix) 
print(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;第二步m-x-n-维矩阵&#34;&gt;第二步，m x n 维矩阵&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;1  2  3  4
5  6  7  8
9 10 11 12
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;6  7 行&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    
    def printmatrix(self, res, matrix):
        # 空
        if (not matrix) or (not matrix[0]):
            return
        # 非空
        m, n = len(matrix), len(matrix[0])
        # 向量
        if m == 1:       
            res +=  matrix[0]
            return
        if n ==1:
            res += [x[0] for x in matrix]
            return
        # 矩阵
        for i in range(0, n):
            res.append(matrix[0][i])
        for i in range(1, m):
            res.append(matrix[i][n - 1])
        for i in range(1, n):
            res.append(matrix[m - 1][n - i -1])
        for i in range(1, m - 1):
            res.append(matrix[m - i -1][0])
        # 递归
        self.printmatrix(res, [x[1: (n-1)] for x in matrix[1:(m-1)]])
        return
    
    def spiralOrder(self, matrix):
        res = []
        self.printmatrix(res, matrix) 
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
s = Solution()
s.spiralOrder(matrix)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-30-包含min函数的栈&#34;&gt;剑指 Offer 30. 包含min函数的栈&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MinStack:

    def __init__(self):
        self.stack = [] 
        self.mins = []  # 存每次push之后最小值的栈

    def push(self, x: int) -&amp;gt; None:
        self.stack.append(x)
        if not self.mins or x &amp;lt;= self.mins[-1]:
            self.mins.append(x)
            
    def pop(self) -&amp;gt; None:
        x = self.stack.pop()
        tmp = self.mins.pop()
        if tmp != x:
            self.mins.append(tmp)
            
    def top(self) -&amp;gt; int:
        tmp = self.stack.pop()
        self.stack.append(tmp)
        return tmp

    def min(self) -&amp;gt; int:
        tmp = self.mins.pop()
        self.mins.append(tmp)
        return tmp
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;s = MinStack()
s.push(-3),s.push(0),s.push(-2)
s.min(),s.pop(),s.top(),s.min()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(-3, None, 0, -3)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-32-打印二叉树&#34;&gt;剑指 Offer 32 打印二叉树&lt;/h1&gt;
&lt;p&gt;这个部分的关键在于理解——&lt;strong&gt;队列的思想！&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

# 定义测试用例
t1 = TreeNode(3)
t2 = TreeNode(9)
t3 = TreeNode(20)
t1.left = t2; t1.right = t3
t4 = TreeNode(15)
t5 = TreeNode(7)
t6 = TreeNode(0)
t2.left = t4; t2.right = t5; t3.right = t6
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;从上到下-每一层从左到右&#34;&gt;从上到下、每一层从左到右&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def print_tree(root):
    res = []
    
    if not root:  # root 是空
        return res

    nodelist = [root]
    while nodelist:
        current = nodelist.pop(0)
        res.append(current.val)
        if current.left:
            nodelist.append(current.left)
        if current.right:
            nodelist.append(current.right)
    
    return res

print_tree(t1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[3, 9, 20, 15, 7, 0]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;每一层打印到一行&#34;&gt;每一层打印到一行&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印。
def print_row(root):
    row_list = [root]
    res = []
    
    while row_list:
        row_res = []         # 本层的打印结果
        n = len(row_list)   # 本层有多少节点
        
        for i in range(n):
            cur = row_list.pop(0)
            row_res.append(cur.val)
            if cur.left:
                row_list.append(cur.left)
            if cur.right:
                row_list.append(cur.right)
        
        res.append(row_res)
    
    return res
print_row(t1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[[3], [9, 20], [15, 7, 0]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;之字形顺序打印二叉树&#34;&gt;之字形顺序打印二叉树&lt;/h2&gt;
&lt;p&gt;即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def print_row(root):
    row_list = [root]
    res = []
    row = 1     # 记录z字，即打印顺序
    while row_list:
        row_res = []         # 本层的打印结果
        n = len(row_list)   # 本层有多少节点

        for i in range(n): 
            cur = row_list.pop(0)   
            row_res.append(cur.val)
            if cur.left:
                row_list.append(cur.left)
            if cur.right:
                row_list.append(cur.right)
        
        if row % 2 == 0:
            row_res.reverse()
        res.append(row_res)

        row += 1
        
    return res
print_row(t1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[[3], [20, 9], [15, 7, 0]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-39-出现次数超过一半的数字&#34;&gt;剑指 Offer 39. 出现次数超过一半的数字&lt;/h1&gt;
&lt;p&gt;数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 解法一：字典计数
nums = [1, 0, 0, 2, 2, 3, 2, 2, 2, 5, 4, 2, 2]
d = dict()
for num in nums:
    if num in d.keys():
        d[num] += 1
    else:
        d[num] = 1
for k in d.keys():
    if d[k] &amp;gt; (len(nums)/2):
        print(k)

# 解法二：摩尔投票，技巧性
votes = 0
for num in nums:
    if votes == 0: 
        x = num
    if num == x:
        votes += 1
    else:
        votes -= 1
if votes != 0:
    print(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2
2
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-40-最小的k个数&#34;&gt;剑指 Offer 40. 最小的k个数&lt;/h1&gt;
&lt;p&gt;输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/&#34;&gt; topk 堆排序 示意图&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution:
    def getLeastNumbers(self, arr: List[int], k: int) -&amp;gt; List[int]:
        if k == 0:
            return list()

        hp = [-x for x in arr[:k]]
        heapq.heapify(hp)
        for i in range(k, len(arr)):
            if -hp[0] &amp;gt; arr[i]:
                heapq.heappop(hp)
                heapq.heappush(hp, -arr[i])
        ans = [-x for x in hp]
        return ans
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;我们用一个大根堆实时维护数组的前k最小值&lt;/li&gt;
&lt;li&gt;从第 k+1 个数开始遍历，如果当前遍历到的数比大根堆的堆顶的数要小，就把堆顶的数弹出，再插入当前遍历到的数。最后将大根堆里的数存入数组返回即可。&lt;/li&gt;
&lt;li&gt;注意：Python 语言中是小根堆，因此要&lt;strong&gt;对数组中所有的数取其相反数&lt;/strong&gt;，才能使用小根堆维护前 k 小值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;剑指-offer-42-连续子数组的最大和&#34;&gt;剑指 Offer 42. 连续子数组的最大和&lt;/h1&gt;
&lt;p&gt;输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。&lt;/p&gt;
&lt;p&gt;输入: nums = [-2,1,-3,4,-1,2,1,-5,4]&lt;/p&gt;
&lt;p&gt;输出: 6&lt;/p&gt;
&lt;p&gt;解释: 连续子数组 [4,-1,2,1] 的和最大为 6。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt;&lt;br&gt;
当前最大 = max(当前值加上前一个最大，当前值）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nums = [-2,1,-3,4,-1,2,1,-5,4]
max_list = nums
for i in range(1, len(nums)):
    max_list[i] = max(max_list[i-1] + nums[i], nums[i])
print(max(max_list))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;6
&lt;/code&gt;&lt;/pre&gt;
">练习题 Day5</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1125/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#448-%E6%89%BE%E5%88%B0%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97&#34;&gt;448.  找到消失的数字&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%B8%80&#34;&gt;解法一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%BA%8C-%E5%AE%98%E6%96%B9%E9%A2%98%E8%A7%A3&#34;&gt;解法二 官方题解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#461-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB&#34;&gt;461 汉明距离&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9B%B4%E5%BE%84&#34;&gt;543 二叉树直径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;617 合并二叉树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97&#34;&gt;剑指 Offer 03 数组中重复的数字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC&#34;&gt;剑指 Offer 05. 替换空格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8&#34;&gt;剑指 Offer 06. 从尾到头打印链表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97&#34;&gt;剑指 Offer 09. 用两个栈实现队列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-10-%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92&#34;&gt;剑指 Offer 10 经典递归&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%91%E6%8C%87-offer-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97&#34;&gt;剑指 Offer 11. 旋转数组的最小数字&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;11.25日，最近还是好好刷题 leetcode python3 &amp;amp; sql\n&amp;quot;,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;热门100道题中的简单题——最后四道&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;【448】找到消失的数字&lt;/li&gt;
&lt;li&gt;【461】汉明距离&lt;/li&gt;
&lt;li&gt;【543】二叉树直径&lt;/li&gt;
&lt;li&gt;【617】合并二叉树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problemset/lcof/&#34;&gt;剑指 Offer 第二版&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;448-找到消失的数字&#34;&gt;448.  找到消失的数字&lt;/h1&gt;
&lt;p&gt;找到所有在 [1, n] 范围之间没有出现在数组中的数字&lt;/p&gt;
&lt;h2 id=&#34;解法一&#34;&gt;解法一&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nums = [4,3,2,7,8,2,3,1]
list(set(range(1, len(nums) + 1)) - set(nums))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[5, 6]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解法二-官方题解&#34;&gt;解法二 官方题解&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;一个萝卜一个坑，鸽巢思想&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将每个数字放到正确的位置上（对应的下标）,&lt;/li&gt;
&lt;li&gt;遍历排序后的数组，若位置上不是正确的元素，则输出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组长度其实和数组的索引相关，最大索引+1即为数组长度,&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能不能通过数组的值转换为索引，,&lt;/li&gt;
&lt;li&gt;将原始数组的值加个标签，比如变为-1或者乘以*-1 作为标记 tag ，最后根据标签来判断数组索引是否存在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nums = [4, 3, 2, 7, 8, 2, 3, 1]
for num in nums:
    nums[abs(num) - 1] = - abs(nums[abs(num) - 1])      # 如果索引值1：n存在与nums中，则标记为负数
print(nums)  # 正数——对应索引值不存在nums中，负数——对应索引值存在于nums中
print([idx + 1 for idx, num in enumerate(nums) if num &amp;gt; 0])  # 输出正数对应的索引值 +1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[-4, -3, -2, -7, 8, 2, -3, -1]
[5, 6]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;461-汉明距离&#34;&gt;461 汉明距离&lt;/h1&gt;
&lt;p&gt;定义：两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目&lt;/p&gt;
&lt;h1 id=&#34;543-二叉树直径&#34;&gt;543 二叉树直径&lt;/h1&gt;
&lt;p&gt;一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。两结点之间的路径长度是以它们之间边的数目表示&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;错误解答： 最大直径是左子树和右子树的最大深度之和，但是万一最大直径没有经过根节点呢？&lt;/li&gt;
&lt;li&gt;所以说对于树中的每一个结点，都要把它视为根节点，然后比较所有结点的左子树和右子树的最大深度之和，取其中的最大值。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self x):
#         self.val = x
#         self.left = None
#         self.right = None
   
# 1.初步考虑（经过根节点的情况）——对左右递归
&#39;&#39;&#39;
def depth(root):
    if root == None:
        return 0
    l = depth(root.left)
    r = depth(root.right)
    return max(l r) + 1
&#39;&#39;&#39;

# 2.用一个max记录所有结点看做根节点对左右递归时候的max值
class solution:
    def __init__(self):
        self.max = 0
           
    def diameterOfBinaryTree(self, root):
        self.depth(root)
        return self.max
       
    def depth(self, root):
        if root == None:
            return 0
        l = self.depth(root.left)
        r = self.depth(root.right)
        self.max = max(self.max, l + r)
        return max(l, r) + 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;617-合并二叉树&#34;&gt;617 合并二叉树&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;如果两个节点重叠，那么将他们的值相加作为节点合并后的新值&lt;/li&gt;
&lt;li&gt;否则不为 NULL 的节点将直接作为新二叉树的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
   # class TreeNode:
   #     def __init__(self x):
   #         self.val = x
   #         self.left = None
   #         self.right = None

class Solution:
       def mergeTrees(self, t1, t2):
           
        # 结束条件
        if not t1 or not t2:
            return t1 or t2
           
        # 否则就合并，即+
        else:
            t1.val += t2.val
            t1.left = self.mergeTrees(t1.left, t2.left)
            t1.right = self.mergeTrees(t1.right, t2.right)
            return t1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-03-数组中重复的数字&#34;&gt;剑指 Offer 03 数组中重复的数字&lt;/h1&gt;
&lt;p&gt;在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    # 解法一（找出任意一个）
    def findRepeatNumber(self, nums):
        n = len(nums)
        nums.sort()
        for i in range(n):
            if nums[i] - nums[i+1] == 0:
                return nums[i]
   
    # 解法二（可以找出所有）        
    def findRepeatNumber(self, nums):
        d = dict()
        res = []
           
        for i in range(len(nums)):
            if nums[i] in d.keys():
                d[nums[i]] += 1
            else:
                d[nums[i]] = 1
   
        for j in d.keys():
            if d[j] &amp;gt;= 2: res.append(j)
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-05-替换空格&#34;&gt;剑指 Offer 05. 替换空格&lt;/h1&gt;
&lt;p&gt;请实现一个函数，把字符串 s 中的每个空格替换成 %20&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;s = &amp;quot;We are happy!&amp;quot;
def replaceblank(s):
    ss = list(s)
    res = []
    for _ in ss:
        if _ == &#39; &#39;:
            res.append(&#39;%20&#39;)
        else:
            res.append(_)
    return &#39;&#39;.join(res)
replaceblank(s)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&#39;We%20are%20happy!&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-06-从尾到头打印链表&#34;&gt;剑指 Offer 06. 从尾到头打印链表&lt;/h1&gt;
&lt;p&gt;输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def reversePrint(self head):
        val = []
        node = head
        while node:
            val.append(node.val)
            node = node.next
        res = []
        while val:
            res.append(val.pop())
        return res
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-09-用两个栈实现队列&#34;&gt;剑指 Offer 09. 用两个栈实现队列&lt;/h1&gt;
&lt;p&gt;只使用一个栈 stack1 当作队列，另一个栈 stack2 用来辅助操作。&lt;/p&gt;
&lt;p&gt;要想将新加入的元素出现栈底，需要先将 stack1 的元素转移到 stack2，将元素入栈 stack1，最后将 stack2 的元素全部回到 stack1。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class CQueue:
    def __init__(self):
        self.q1 = []
        self.q2 = []
   
    def appendTail(self, value):
        self.q1.append(value)
           
    def deleteHead(self):
        if self.q2:  # 先前进行过一次倒序
            return self.q2.pop()
        elif self.q1: # 第一次删除/把以前加入的全部删掉了，但是还有新的
            while self.q1:
                self.q2.append(self.q1.pop())  # 倒序
            return self.q2.pop()
        else:   # 都空，则按照题目要求返回-1
            return -1 
        
# 测试
test = CQueue()
for i in [&#39;top&#39;,&#39;middle&#39;,&#39;end&#39;]:
    test.appendTail(i);
test.deleteHead(),test.deleteHead(),test.deleteHead(),test.deleteHead()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(&#39;top&#39;, &#39;middle&#39;, &#39;end&#39;, -1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-10-经典递归&#34;&gt;剑指 Offer 10 经典递归&lt;/h1&gt;
&lt;p&gt;fib数列、青蛙跳台阶问题&lt;/p&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fib(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a %  1000000007

def numWays1(n):
    if n &amp;lt; 2:
        return 1
    else:
        return (numWays(n - 1) + numWays(n - 2)) %  1000000007

def numWays2(n):
    a, b = 1, 1
    for _ in range(n):
        a, b = b, a + b
    return a % 1000000007
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;剑指-offer-11-旋转数组的最小数字&#34;&gt;剑指 Offer 11. 旋转数组的最小数字&lt;/h1&gt;
&lt;p&gt;假设按照升序排序的数组在预先未知的某个点上进行了旋转。&lt;/p&gt;
&lt;p&gt;( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。&lt;/p&gt;
&lt;p&gt;请找出其中最小的元素。&lt;/p&gt;
&lt;p&gt;注意数组中可能存在重复的元素。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nums = [0,1,2,4,5,6,7]
nums = [4,5,6,7,8,1,2,3]

res = None
i = 0
while (i &amp;lt; (len(nums)-1 )) and (res == None) :
    if nums[i] &amp;gt; nums[i+1]:
        res = nums[i+1]
    i += 1
if res == None:
    res = nums[0]

print(res)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
">练习题 Day4</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/kmeans11_11/"" data-c="
          &lt;h1 id=&#34;kmeans&#34;&gt;kmeans&lt;/h1&gt;
&lt;p&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;随机选择初始k个样本点&lt;/li&gt;
&lt;li&gt;对每个非中心样本点计算到k个中心点的距离，归入距离最小的一类&lt;/li&gt;
&lt;li&gt;重新计算中心，重复第二步&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;停止条件：迭代停止条件/中心点不变&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 导入模块
import numpy as np
import matplotlib.pyplot as plt

## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    

## 生成数据
X = np.array([[1.5, 5], [2, 7.5],[2.3, 3.9], [2,3.1], [2.5, 6], [3, 5.7], [3.3, 2.9], [4, 8], [4,6.6],
              [6, -1], [5, 0.5], [5.5, 3.9], [6,2], [6.4,1.2],[7,-0.5], [6.7, 3], [7.5, 0.5]])
x1 = [x[0] for x in X]
x2 = [x[1] for x in X]
fig = plt.figure(figsize = (5, 4))   # 创建一张画布
plt.scatter(x1, x2)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1605143051358.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 1.定义函数——抽取初始值
import random
def sample(data, sample_size):
    sample_list = []
    number_set = list(range(X.shape[0]))
    for i in range(sample_size):  # 独立抽样
        num = random.choice(number_set)
        number_set.remove(num)   # 不放回
        sample_list.append(num)
    return sample_list


# 2.定义函数——对于非中心点归类
def cluster(X, centriod):
    new_cluster = []
    number_list =  list(range(X.shape[0]))
    for i in number_list:
        closest_dist = float(&#39;inf&#39;)
        closest_i = None
        for j in range(len(centriod)):
            l2_dist = np.dot((centriod[j] - X[i]).T, centriod[j] - X[i])
            if l2_dist &amp;lt; closest_dist:
                closest_dist = l2_dist
                closest_i = j
        new_cluster.append(closest_i) 
    return new_cluster


# 3.定义函数——更新中心点
def new_centriod(X, new_cluster):
    cluster1 = []
    cluster2 = []
    number_list =  list(range(X.shape[0]))
    for i in number_list:
        if new_cluster[i] == new_cluster[0]:
            cluster1.append(X[i])
        else:
            cluster2.append(X[i])
    new_k  = [np.mean(cluster1, axis = 0), np.mean(cluster2, axis = 0)]
    return new_k
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;inital_k = sample(list(range(X.shape[0])), 2)  # k=2 分为两类的情况
print(&amp;quot;选取的初始中心点为:{}&amp;quot;.format(inital_k)) # 选取的初始值
new_k = np.array([X[k] for k in inital_k])

for _ in range(3):  # 多次迭代
    new_cluster = cluster(X, new_k)
    color = [&amp;quot;orange&amp;quot; if c == new_cluster[0] else &amp;quot;dodgerblue&amp;quot; for c in new_cluster] 
    fig = plt.figure(figsize=(5, 4))    # 创建一张画布
    plt.scatter(x1, x2, c = color)
    new_k = new_centriod(X, new_cluster)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;选取的初始中心点为:[8, 0]
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1605143107979.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1605143115187.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1605143122088.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;inital_k = sample(list(range(X.shape[0])), 2)  # k=2 分为两类的情况
print(&amp;quot;选取的初始中心点为:{}&amp;quot;.format(inital_k)) # 选取的初始值
new_k = np.array([X[k] for k in inital_k])

for _ in range(3):  # 多次迭代
    new_cluster = cluster(X, new_k)
    color = [&amp;quot;orange&amp;quot; if c == new_cluster[0] else &amp;quot;dodgerblue&amp;quot; for c in new_cluster] 
    fig = plt.figure(figsize=(5, 4))    # 创建一张画布
    plt.scatter(x1, x2, c = color)
    new_k = new_centriod(X, new_cluster)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;选取的初始中心点为:[10, 15]
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1605143139929.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1605143147057.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1605143153157.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;【小总结】分类过程和结果都依赖于初始值的选择&lt;/p&gt;
">简单Kmeans 硬分配+随机初始</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/di-yi-ci-mian-shi-fan-che-ji-lu/"" data-c="
          &lt;p&gt;【面试翻车记录】 55min（真的好久哈哈哈因为太多地方不懂我问了好多问题）&lt;/p&gt;
&lt;p&gt;目标实习岗位：商业化数据分析&lt;/p&gt;
&lt;h2 id=&#34;1历史实习项目经验&#34;&gt;1.历史实习&amp;amp;项目经验&lt;/h2&gt;
&lt;p&gt;问了我某两个变量之间存在多重共线性问题，有没有检查过？如何处理的？&lt;/p&gt;
&lt;h2 id=&#34;2sql&#34;&gt;2.sql&lt;/h2&gt;
&lt;p&gt;①有哪些join？A表3行，B表4行，leftjoin之后可能有几行？&lt;br&gt;
②用到窗口函数的一个题&lt;/p&gt;
&lt;h2 id=&#34;3假设检验&#34;&gt;3.假设检验&lt;/h2&gt;
&lt;p&gt;这里问到了如何判断不同类型客户对产品价值是否有差异——方差分析&lt;br&gt;
面试官补充问了p值的含义，怎么理解统计显著。&lt;/p&gt;
&lt;p&gt;如果说前面的问题我都顺利结束了，面对业务问题真的完全翻车…😵&lt;/p&gt;
&lt;h2 id=&#34;4业务问题&#34;&gt;4.业务问题&lt;/h2&gt;
&lt;h3 id=&#34;1如何估计一个煎饼摊一年的收入&#34;&gt;①如何估计一个煎饼摊一年的收入？&lt;/h3&gt;
&lt;p&gt;第一次面试的我…完全没有思路，只好说简单说下大概抽样-&amp;gt;时间序列，虽然她说思路可以理解...但是我回答的实在没有什么逻辑.....&lt;/p&gt;
&lt;h3 id=&#34;2如果有一个指标比如所有用户平均xx率出现异常增长降低如何定位问题源头&#34;&gt;②如果有一个指标（比如所有用户平均XX率）出现异常增长/降低，如何定位问题源头？&lt;/h3&gt;
&lt;p&gt;我再次一脸懵逼，大概讲了下同比环比，对于可能的因素排除法来判断。&lt;br&gt;
面试官谈了下“问题拆解”，那其实这道题主要看你分析问题的思路是否清晰，他想要一个从上而下的分析思路。&lt;/p&gt;
&lt;h3 id=&#34;3觉得某些app有什么缺点&#34;&gt;③觉得某些APP有什么缺点？&lt;/h3&gt;
&lt;p&gt;广告太多（我真就随口一说），接着面试官问如何平衡广告收入和用户体验…..&lt;br&gt;
其实我完全没有把自己代入公司的角色，确实答不出来，我只能猜测度量用户体验的指标，后续怎么做一无所知。&lt;br&gt;
面试官分享了她的看法：做实验。实验组增加广告，对比实验组和对照组的用户体验指标（比如日活、时长等等），根据用户体验指标的减少来估计广告收入的减少（这里我反问他怎么估计，她说确实很难估计😢），与增加广告带来的收入对比，做投入产出分析。&lt;/p&gt;
&lt;h2 id=&#34;5反问环节&#34;&gt;5.反问环节&lt;/h2&gt;
&lt;h3 id=&#34;1统计数学背景做数据分析的优势和需要注意的方面在哪儿&#34;&gt;①统计/数学背景做数据分析的优势和需要注意的方面在哪儿？&lt;/h3&gt;
&lt;p&gt;他说我问的很好…统计出身对于理论知识编程都技术方面都非常熟悉，但是业务能力确实差一些（有被暗示到哈哈哈也反面说明面试官不是统计出身）我们就这个话题谈了蛮久。&lt;/p&gt;
&lt;h3 id=&#34;2接着我就问了如何提升业务能力&#34;&gt;②接着我就问了如何提升业务能力&lt;/h3&gt;
&lt;p&gt;（这里其实自己放开了，觉得面试展现缺点也没有关系，主要想学点东西）&lt;br&gt;
她说多思考…&lt;/p&gt;
&lt;h3 id=&#34;3工作内容&#34;&gt;③工作内容&lt;/h3&gt;
&lt;p&gt;分小组，一些偏实验设计，另一些偏业务建模不多（他们就是偏业务的），说看我简历其实做了很多数据挖掘方面的工作而非数据分析（感觉是暗示我换方向哈哈哈）&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;【总结】&lt;/h1&gt;
&lt;p&gt;翻车原因—— no 业务 sense （其实后来看了一下，这些都是产品优化的思维，虽然没有经验确实很难有业务sense，但是可以培养思考问题的方式，短时间培养不出来，就模仿来应对面试真的很有用！&lt;strong&gt;想要顺利面试真的还是要靠面经，靠提前准备而不是现场发挥&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最后借用爸爸的一句话“没关系啦，大家最开始都不知道面试的套路啥的，面试这种东西就是得经历过几次才能了解各种题型和套路的”~加油鸭&lt;/p&gt;
">第一次面试翻车记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/sql-han-shu-tiao-jian-yu-ju-shi-tu/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5&#34;&gt;第七章：常用函数、条件语句&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#71-%E6%95%B0%E5%80%BC%E5%87%BD%E6%95%B0-numeric-functions&#34;&gt;7.1 数值函数 numeric functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#72-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0-string-functions&#34;&gt;7.2 字符串函数  string functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#73-%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0&#34;&gt;7.3 日期函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#74-%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4-%E7%B1%BB%E4%BC%BC%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E8%BF%99%E6%A0%B7&#34;&gt;7.4 格式化日期和时间 类似格式化输出这样&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#75-%E8%AE%A1%E7%AE%97%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94&#34;&gt;7.5 计算日期和时间间隔&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#76-if-null-coalesec&#34;&gt;7.6 if null &amp;amp; coalesec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#77-if&#34;&gt;7.7 if&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#78-case-%E8%BF%90%E7%AE%97%E7%AC%A6&#34;&gt;7.8 case 运算符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E5%85%AB%E7%AB%A0%E8%A7%86%E5%9B%BE&#34;&gt;第八章：视图&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#81-%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE&#34;&gt;8.1 创建视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#83-%E5%8F%AF%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE&#34;&gt;8.3 可更新视图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#84-with-option-check&#34;&gt;8.4 with option check&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;第七章常用函数-条件语句&#34;&gt;第七章：常用函数、条件语句&lt;/h1&gt;
&lt;h2 id=&#34;71-数值函数-numeric-functions&#34;&gt;7.1 数值函数 numeric functions&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select round(3.14159, 2),  # 3.14
	ceiling(4.4),  # 5
	floor(4.4),    # 4
	abs(-2),        # 2
	rand();        # 生成0-1随机数
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;72-字符串函数-string-functions&#34;&gt;7.2 字符串函数  string functions&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select length(&#39;ysy&#39;),
	upper(&#39;ysy&#39;),
    lower(&#39;YSy&#39;),
    
    # 去空格
    ltrim(&#39;    y  sy  &#39;),   # 去掉字符前面的空格
    rtrim(&#39;    y  sy  &#39;),   # 去掉字符后面的空格
    trim(&#39;    y  sy  &#39;),    # 去掉前+后空格（中间的还在）
    
    # 截取 切片(py) / substr(r)
    left(&#39;Kindergarten&#39;, 4),   # 前4个
    right(&#39;Kindergarten&#39;, 6),  # 后6个
    substring(&#39;Kindergarten&#39;, 3, 2),   # 从第3个（起始位置）往后的2个字母
    
    # 寻找 in(py) / grep (r) 
    locate(&#39;瓜&#39;,&#39;想吃瓜的杨杨吃不到瓜&#39;), # 返回“瓜”第一次出现的位置3
    locate(&#39;寡&#39;,&#39;想吃瓜的杨杨吃不到瓜&#39;), # 找不到的话返回 0
    locate(&#39;吃瓜&#39;,&#39;想吃瓜的杨杨吃不到瓜&#39;), 
    
    # 替换 replace(py) / gsub(r)
    replace(&#39;Kindergarten&#39;, &#39;garten&#39;,&#39;garden&#39;),
    
    # 连接 +(py) / paste (r)
    concat(&#39;aa&#39;,&#39;+&#39;,&#39;bb&#39;)   # 输出aa+bb
;

use sql_store;
select concat(first_name, &#39; &#39;, last_name) as full_name,
	length(first_name) + length(last_name) as length_of_name,
    concat(&#39;customer&#39;,&#39;_&#39;,left(last_name,1))
from customers;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;73-日期函数&#34;&gt;7.3 日期函数&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select 
	# 获取当前时间
	now(),       # 获取当前time
	curdate(),   # 获取当前日期
    curtime(),   # 获取当前时刻
    
    # 提取时间的年月日
    year(now()),     # 同理还有 month day second
    dayname(now()),  # 获取星期几
    monthname(now()), # 获取月份名称
    
    # extract提取
    extract(year from now())-1;  

select year(order_date),
	monthname(order_date),
    day(order_date),
    dayname(order_date)
from orders;

select * 
from orders
where year(order_date) = year(now())-1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;74-格式化日期和时间-类似格式化输出这样&#34;&gt;7.4 格式化日期和时间 类似格式化输出这样&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select date_format(now(),&#39;%d-%m-%y&#39;),
	date_format(now(),&#39;%y年%m月%d日%p&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;75-计算日期和时间间隔&#34;&gt;7.5 计算日期和时间间隔&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select now(),
	# 前后几天/月/日
	date_add(now(), interval - 4 day),
    date_add(now(), interval 3 month),
    datediff(&#39;2020-12-12&#39;,now()),  # 还有38天过生日嘿嘿
    datediff(&#39;2020-12-12&#39;,&#39;1997-12-12&#39;);   # 已经活了8401天
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;76-if-null-coalesec&#34;&gt;7.6 if null &amp;amp; coalesec&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use sql_store;
select 
	order_id,
    # ifnull 其实就是 if x=null:then a; else:x
    ifnull(shipper_id, comments) as shipper_id_1,
    # coalesce(a,b,c)如果a列是空就用b列内容，如果ab都空就填c
    coalesce(shipper_id, comments, &#39;not assigned&#39;) as shipper_id_2
from orders;

select concat(first_name, &#39; &#39;, last_name) as customer,
	coalesce(phone,&#39;unknown&#39;)as phone
from customers;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;77-if&#34;&gt;7.7 if&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select 
	order_id,
    order_date,
	# if(expression, true, false)
	if(year(order_date) &amp;lt; 2019 ,&#39;archievd&#39;,&#39;active&#39;) as order_status
from orders;


select 
	p1.product_id,
	name,
    (select count(product_id) 
		from order_items 
        where product_id = p1.product_id) as order_num,
	if((select order_num) = 0, &#39;never&#39;, &#39;at least once&#39;) as freq
from products p1
order by order_num desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;78-case-运算符&#34;&gt;7.8 case 运算符&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select 
	order_id,
    order_date,
    case
		when year(order_date) = year(now()) - 1 then &#39;去年&#39;
        when year(order_date) = year(now()) - 2 then &#39;前年&#39;
        when year(order_date) &amp;lt;= year(now()) - 3 then &#39;老早之前&#39;
        else &#39;将来&#39;
	end as category
from orders;

select
	customer_id,
    concat(first_name, &#39; &#39;, last_name) as customer_name,
    case 
		when points &amp;gt;= 3000 then &#39;gold&#39;
        when points &amp;gt;= 2000 then &#39;silver&#39;
        else &#39;bronze&#39;
	end as category
from customers
order by points desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第八章视图&#34;&gt;第八章：视图&lt;/h1&gt;
&lt;p&gt;/*&lt;br&gt;
创建视图，很像数据透视表 ~ 注意视图不存储数据~&lt;br&gt;
更改或者删除视图&lt;br&gt;
可更新视图&lt;br&gt;
with option check&lt;/p&gt;
&lt;p&gt;视图的优点：&lt;br&gt;
方便简洁、减少改动带来的影响&lt;br&gt;
*/&lt;/p&gt;
&lt;h2 id=&#34;81-创建视图&#34;&gt;8.1 创建视图&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use sql_invoicing;
## 1.create
create view sales_by_client as
select 
	c.client_id,
    c.name,
    sum(invoice_total) as total_sales
from clients c
join invoices i using(client_id)
group by client_id;
## 2.使用
select * 
from sales_by_client
join clients using(client_id);

create view balance_client as
select
	client_id,
    name,
    sum(invoice_total - payment_total) as balance_total
from clients c
join invoices i using(client_id)
group by client_id;
select * from balance_client;


## 8.2 更改或删除视图
```{sql}
drop view balance_client;
create or replace view balance_client as
select
	client_id,
    name,
    sum(invoice_total - payment_total) as balance_total
from clients c
join invoices i using(client_id)
group by client_id;
### 保存方法——单独一个sql文件，文件名和视图名一样
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;83-可更新视图&#34;&gt;8.3 可更新视图&lt;/h2&gt;
&lt;p&gt;/*&lt;br&gt;
如果视图中没有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;distinct / 聚合函数 / group by / having / union&lt;br&gt;
那么叫做可更新视图（可以在insert update delete语句中使用)&lt;br&gt;
*/&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;create or replace view invoices_with_balance as
select
	invoice_id,
    number as phone_number,
    client_id,
    invoice_total,
    payment_total,
    invoice_total - payment_total as balance_total,
    invoice_date,
    due_date,
    payment_date
from invoices
where invoice_total &amp;gt; payment_total;
    
# 更新视图1
delete from invoices_with_balance
where invoice_id = 1;
# 更新视图2
update invoices_with_balance
set due_date = date_add(due_date, interval 2 day)
where invoice_id = 2;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;84-with-option-check&#34;&gt;8.4 with option check&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;update invoices_with_balance
set payment_total = invoice_total
where invoice_id = 3;     # 会发现因为balance=0，直接drop掉了

create or replace view invoices_with_balance as
select
	invoice_id,
    number as phone_number,
    client_id,
    invoice_total,
    payment_total,
    invoice_total - payment_total as balance_total,
    invoice_date,
    due_date,
    payment_date
from invoices
where invoice_total &amp;gt; payment_total
with check option;  # 加上这一行之后，防止行被删除
&lt;/code&gt;&lt;/pre&gt;
">sql 函数/条件语句/视图</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/tidy-data/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BC%98%E8%B5%B7&#34;&gt;缘起&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9A%E4%B9%89tidy-data&#34;&gt;定义tidy data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%B8%E8%A7%81%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C&#34;&gt;常见处理操作&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-pivot-data-from-wide-to-long&#34;&gt;1. Pivot data from wide to long&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BE%8B%E5%AD%901-income_religion&#34;&gt;例子1 income_religion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BE%8B%E5%AD%902-billboard&#34;&gt;例子2 billboard&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-dplyr&#34;&gt;2. dplyr&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-mutate-create-modify-and-delete-columns&#34;&gt;2.1 mutate: Create, modify, and delete columns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-arrange-order-a-data-frame-by-its-colums&#34;&gt;2.2 arrange: Order a data frame by its colums.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E5%82%A8%E5%AD%98%E5%9C%A8%E4%B8%80%E5%88%97&#34;&gt;3. 多个变量储存在一列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E5%8F%98%E9%87%8F%E6%97%A2%E5%9C%A8%E5%88%97%E4%B8%AD%E5%AD%98%E5%82%A8%E5%8F%88%E5%9C%A8%E8%A1%8C%E4%B8%AD%E5%AD%98%E5%82%A8&#34;&gt;4. 变量既在列中存储，又在行中存储。&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B0%8F%E6%80%BB%E7%BB%93&#34;&gt;小总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;缘起&#34;&gt;缘起&lt;/h1&gt;
&lt;p&gt;缘起还是这个长期存在的争议：R or python？昨天在cos八卦群里看到大佬们关于 pandas 和 tidy r 在数据清洗/预处理方面的讨论（这可太真实了哈哈哈！），突然想了解一下 Hadley Wickham 大佬关于 tidy data 的思想。正巧最近想要寻找实习，R 的数据结构和语句在课上基本了解了，不过数据处理这个关键部分还未涉猎，so~&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1604453056904.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;这篇文章地址：&lt;br&gt;
&lt;a href=&#34;https://vita.had.co.nz/papers/tidy-data.html&#34;&gt;Hadley Wickham&#39;s 《Tidy data》&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;定义tidy-data&#34;&gt;定义tidy data&lt;/h1&gt;
&lt;p&gt;Tidy data is a standard way of mapping the meaning of a dataset to its structure.  In tidy data:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Each variable forms a column.&lt;/li&gt;
&lt;li&gt;Each observation forms a row.&lt;/li&gt;
&lt;li&gt;Each type of observational unit forms a table.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在线尴尬，第一次更新R版本，没想到好多包也需要重装，磨磨唧唧一早上，哭唧唧&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;&amp;gt; library(tidyr)
Error: package or namespace load failed for ‘tidyr’ in loadNamespace(i, c(lib.loc, .libPaths()), versionCheck = vI[[i]]):
 namespace ‘rlang’ 0.3.1 is already loaded, but &amp;gt;= 0.4.0 is required
&amp;gt; R.version
               _                           
platform       x86_64-apple-darwin15.6.0   
arch           x86_64                      
os             darwin15.6.0                
system         x86_64, darwin15.6.0        
status                                     
major          3                           
minor          4.4                         
year           2018                        
month          03                          
day            15                          
svn rev        74408                       
language       R                           
version.string R version 3.4.4 (2018-03-15)
nickname       Someone to Lean On  

&amp;gt; R.version
               _                           
platform       x86_64-apple-darwin17.0     
arch           x86_64                      
os             darwin17.0                  
system         x86_64, darwin17.0          
status                                     
major          4                           
minor          0.3                         
year           2020                        
month          10                          
day            10                          
svn rev        79318                       
language       R                           
version.string R version 4.0.3 (2020-10-10)
nickname       Bunny-Wunnies Freak Out  
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;常见处理操作&#34;&gt;常见处理操作&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;dplyr包是Hadley Wickham的新作，主要用于数据清洗和整理&lt;/li&gt;
&lt;li&gt;tidyr包用于“tidy”数据，常跟dplyr结合使用&lt;/li&gt;
&lt;li&gt;注意&lt;strong&gt;链式操作(管道) %&amp;gt;% 或 %.%&lt;/strong&gt;，读作then，按数据处理的思路写代码，易写且易读（简直神仙R包，copss奖实至名归）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;提纲：&lt;br&gt;
&lt;a href=&#34;#jump1&#34;&gt;1.Pivot data from wide to long&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;#jump2&#34;&gt;2.dplyr&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;#jump3&#34;&gt;3.Multiple variables stored in one column&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;#jump4&#34;&gt;2.Variables are stored in both rows and columns&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span id=&#34;jump1&#34;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-pivot-data-from-wide-to-long&#34;&gt;1. Pivot data from wide to long&lt;/h2&gt;
&lt;p&gt;tidyr 包提供了 pivot_longer() 函数来实现。&lt;/p&gt;
&lt;h3 id=&#34;例子1-income_religion&#34;&gt;例子1 income_religion&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;原始数据：每个变量都是收入区间取值&lt;/li&gt;
&lt;li&gt;融合后：变量一列被重命名为income，值变成一列重命名为freq&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;raw %&amp;gt;%&lt;br&gt;
pivot_longer(- religion, names_to = &amp;quot;income&amp;quot;, values_to = &amp;quot;frequency&amp;quot;)&lt;br&gt;
含义：除了religion列，其余都变成income列，取值变为freq列&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;&amp;gt; library(tidyr)
&amp;gt; library(dplyr)
&amp;gt; head(raw)
            religion &amp;lt;$10k $10-20k $20-30k $30-40k $40-50k $50-75k $75-100k $100-150k
1           Agnostic    27      34      60      81      76     137      122       109
2            Atheist    12      27      37      52      35      70       73        59
3           Buddhist    27      21      30      34      33      58       62        39
4           Catholic   418     617     732     670     638    1116      949       792
5 Don’t know/refused    15      14      15      11      10      35       21        17
6   Evangelical Prot   575     869    1064     982     881    1486      949       723
  &amp;gt;150k Don&#39;t know/refused
1    84                 96
2    74                 76
3    53                 54
4   633               1489
5    18                116
6   414               1529
&amp;gt; raw %&amp;gt;% 
+   pivot_longer(- religion, names_to = &amp;quot;income&amp;quot;, values_to = &amp;quot;frequency&amp;quot;)
# A tibble: 180 x 3
   religion income             frequency
   &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;                  &amp;lt;int&amp;gt;
 1 Agnostic &amp;lt;$10k                     27
 2 Agnostic $10-20k                   34
 3 Agnostic $20-30k                   60
 4 Agnostic $30-40k                   81
 5 Agnostic $40-50k                   76
 6 Agnostic $50-75k                  137
 7 Agnostic $75-100k                 122
 8 Agnostic $100-150k                109
 9 Agnostic &amp;gt;150k                     84
10 Agnostic Don&#39;t know/refused        96
# … with 170 more rows
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;例子2-billboard&#34;&gt;例子2 billboard&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;原始数据2：歌曲上榜前100后的各周的排名&lt;/li&gt;
&lt;li&gt;融合后：列被转换为week&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;&amp;gt; head(billboard[, 1:10])
               artist                    track date.entered wk1 wk2 wk3 wk4 wk5 wk6 wk7
1     Destiny&#39;s Child Independent Women Part I   2000-09-23  78  63  49  33  23  15   7
2             Santana             Maria, Maria   2000-02-12  15   8   6   5   2   3   2
3       Savage Garden       I Knew I Loved You   1999-10-23  71  48  43  31  20  13   7
4             Madonna                    Music   2000-08-12  41  23  18  14   2   1   1
5 Aguilera, Christina        Come On Over Baby   2000-08-05  57  47  45  29  23  18  11
6               Janet    Doesn&#39;t Really Matter   2000-06-17  59  52  43  30  29  22  15
&amp;gt; billboard2 &amp;lt;- billboard %&amp;gt;% 
+   pivot_longer(
+     wk1:wk76,   # 需要变成一列的那些变量
+     names_to = &amp;quot;week&amp;quot;,   # 变成的列名 week
+     values_to = &amp;quot;rank&amp;quot;,   #  值 变成另一列 rank
+     values_drop_na = TRUE
+   )
&amp;gt; billboard2
# A tibble: 5,307 x 5
   artist          track                    date.entered week   rank
   &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;                    &amp;lt;chr&amp;gt;        &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt;
 1 Destiny&#39;s Child Independent Women Part I 2000-09-23   wk1      78
 2 Destiny&#39;s Child Independent Women Part I 2000-09-23   wk2      63
 3 Destiny&#39;s Child Independent Women Part I 2000-09-23   wk3      49
 4 Destiny&#39;s Child Independent Women Part I 2000-09-23   wk4      33
 5 Destiny&#39;s Child Independent Women Part I 2000-09-23   wk5      23
 6 Destiny&#39;s Child Independent Women Part I 2000-09-23   wk6      15
 7 Destiny&#39;s Child Independent Women Part I 2000-09-23   wk7       7
 8 Destiny&#39;s Child Independent Women Part I 2000-09-23   wk8       5
 9 Destiny&#39;s Child Independent Women Part I 2000-09-23   wk9       1
10 Destiny&#39;s Child Independent Women Part I 2000-09-23   wk10      1
# … with 5,297 more rows
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span id=&#34;jump2&#34;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-dplyr&#34;&gt;2. dplyr&lt;/h2&gt;
&lt;h3 id=&#34;21-mutate-create-modify-and-delete-columns&#34;&gt;2.1 mutate: Create, modify, and delete columns&lt;/h3&gt;
&lt;p&gt;dplyr 包括函数 mutate {dplyr} 整理每一列数据格式，常用:sqrt/log/ifelse/as.Date/....&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;&amp;gt; data(iris)
&amp;gt; iris2 &amp;lt;- iris %&amp;gt;%
+   group_by(Species) %&amp;gt;%
+     mutate(  # 会自动按照分组后的计算组均值
+       mean_slength = mean(Sepal.Length)
+     )
&amp;gt; table(iris2$mean_slength)

5.006 5.936 6.588 
   50    50    50 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;继续整理billboard 数据集，提取周的数字和具体日期&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;&amp;gt; billboard3 &amp;lt;- billboard2 %&amp;gt;%
+   mutate(
+     week = as.integer(gsub(&amp;quot;wk&amp;quot;, &amp;quot;&amp;quot;, week)),   # 把第xx周的数字提取出来
+     date = as.Date(date.entered) + 7 * (week - 1),  # 自动计算日期
+     date.entered = NULL    # 把原本 date.entered 列删掉
+   )
&amp;gt; billboard3
# A tibble: 5,307 x 5
   artist          track                     week  rank date      
   &amp;lt;chr&amp;gt;           &amp;lt;chr&amp;gt;                    &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;date&amp;gt;    
 1 Destiny&#39;s Child Independent Women Part I     1    78 2000-09-23
 2 Destiny&#39;s Child Independent Women Part I     2    63 2000-09-30
 3 Destiny&#39;s Child Independent Women Part I     3    49 2000-10-07
 4 Destiny&#39;s Child Independent Women Part I     4    33 2000-10-14
 5 Destiny&#39;s Child Independent Women Part I     5    23 2000-10-21
 6 Destiny&#39;s Child Independent Women Part I     6    15 2000-10-28
 7 Destiny&#39;s Child Independent Women Part I     7     7 2000-11-04
 8 Destiny&#39;s Child Independent Women Part I     8     5 2000-11-11
 9 Destiny&#39;s Child Independent Women Part I     9     1 2000-11-18
10 Destiny&#39;s Child Independent Women Part I    10     1 2000-11-25
# … with 5,297 more rows
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22-arrange-order-a-data-frame-by-its-colums&#34;&gt;2.2 arrange: Order a data frame by its colums.&lt;/h3&gt;
&lt;p&gt;对 dataframe 的排序，按照一些列的取值&lt;/p&gt;
&lt;p&gt;继续整理billboard 数据集，按照日期和排名进行排序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;&amp;gt; billboard4 &amp;lt;- billboard3 %&amp;gt;% 
+   arrange(date, rank) 
&amp;gt; billboard4[3351:3360, ]
# A tibble: 10 x 5
   artist           track                  week  rank date      
   &amp;lt;chr&amp;gt;            &amp;lt;chr&amp;gt;                 &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;date&amp;gt;    
 1 Janet            Doesn&#39;t Really Matter    11     1 2000-08-26
 2 Sisqo            Incomplete               10     2 2000-08-26
 3 matchbox twenty  Bent                     18     3 2000-08-26
 4 Destiny&#39;s Child  Jumpin&#39; Jumpin&#39;          16     4 2000-08-26
 5 Joe              I Wanna Know             35     5 2000-08-26
 6 N&#39;Sync           It&#39;s Gonna Be Me         17     6 2000-08-26
 7 Ruff Endz        No More                   9     7 2000-08-26
 8 Nine Days        Absolutely               17     8 2000-08-26
 9 Aaliyah          Try Again                24     9 2000-08-26
10 Vertical Horizon Everything You Want      32    10 2000-08-26
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span id=&#34;jump3&#34;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-多个变量储存在一列&#34;&gt;3. 多个变量储存在一列&lt;/h2&gt;
&lt;p&gt;原始数据：列变量名是性别(m, f) 、年龄（0-14, 15-25,...)的组合&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要宽表变长表&lt;/li&gt;
&lt;li&gt;需要把列变量名分割成为两部分——形成两个变量&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;&amp;gt; head(tb[, 1:10])
  iso2 year m04 m514 m014 m1524 m2534 m3544 m4554 m5564
1   AD 1989  NA   NA   NA    NA    NA    NA    NA    NA
2   AD 1990  NA   NA   NA    NA    NA    NA    NA    NA
3   AD 1991  NA   NA   NA    NA    NA    NA    NA    NA
4   AD 1992  NA   NA   NA    NA    NA    NA    NA    NA
5   AD 1993  NA   NA   NA    NA    NA    NA    NA    NA
6   AD 1994  NA   NA   NA    NA    NA    NA    NA    NA
&amp;gt; 
&amp;gt; # 方法一：使用 pivot_longer + separate 
&amp;gt; ### 1.第一步，宽变长，使用pivot_longer
&amp;gt; tb2 &amp;lt;- tb %&amp;gt;% 
+   pivot_longer(
+     !c(iso2, year), 
+     names_to = &amp;quot;demo&amp;quot;,    # 变量——&amp;gt; demo列
+     values_to = &amp;quot;n&amp;quot;,      # 取值——&amp;gt; n列
+     values_drop_na = TRUE
+   )
&amp;gt; tb2
# A tibble: 35,750 x 4
   iso2   year demo      n
   &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt;
 1 AD     1996 m014      0
 2 AD     1996 m1524     0
 3 AD     1996 m2534     0
 4 AD     1996 m3544     4
 5 AD     1996 m4554     1
 6 AD     1996 m5564     0
 7 AD     1996 m65       0
 8 AD     1996 f014      0
 9 AD     1996 f1524     1
10 AD     1996 f2534     1
# … with 35,740 more rows
&amp;gt; ### 2.第二步，把demo列字符分割为两部分，形成两列 sex 和 age
&amp;gt; tb3 &amp;lt;- tb2 %&amp;gt;% 
+   separate(demo, c(&amp;quot;sex&amp;quot;, &amp;quot;age&amp;quot;), 1)
&amp;gt; tb3
# A tibble: 35,750 x 5
   iso2   year sex   age       n
   &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt;
 1 AD     1996 m     014       0
 2 AD     1996 m     1524      0
 3 AD     1996 m     2534      0
 4 AD     1996 m     3544      4
 5 AD     1996 m     4554      1
 6 AD     1996 m     5564      0
 7 AD     1996 m     65        0
 8 AD     1996 f     014       0
 9 AD     1996 f     1524      1
10 AD     1996 f     2534      1
# … with 35,740 more rows
&amp;gt; 
&amp;gt; 
&amp;gt; # 方法二：使用更复杂的 pivot_longer
&amp;gt; tb %&amp;gt;% pivot_longer(
+   !c(iso2, year), 
+   names_to = c(&amp;quot;sex&amp;quot;, &amp;quot;age&amp;quot;), 
+   names_pattern = &amp;quot;(.)(.+)&amp;quot;,
+   values_to = &amp;quot;n&amp;quot;, 
+   values_drop_na = TRUE
+ )
# A tibble: 35,750 x 5
   iso2   year sex   age       n
   &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;int&amp;gt;
 1 AD     1996 m     014       0
 2 AD     1996 m     1524      0
 3 AD     1996 m     2534      0
 4 AD     1996 m     3544      4
 5 AD     1996 m     4554      1
 6 AD     1996 m     5564      0
 7 AD     1996 m     65        0
 8 AD     1996 f     014       0
 9 AD     1996 f     1524      1
10 AD     1996 f     2534      1
# … with 35,740 more rows
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;span id=&#34;jump4&#34;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-变量既在列中存储又在行中存储&#34;&gt;4. 变量既在列中存储，又在行中存储。&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;两个变量存储在行里：tmin和tmax&lt;/li&gt;
&lt;li&gt;每日日期储存在列里：d1, d2,...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里尝试用多次 %&amp;gt;% 把所有操作按部就班then连接在一起&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{r}&#34;&gt;&amp;gt; head(raw[,1:10])
       id year month element d1   d2   d3 d4   d5 d6
1 MX17004 2010     1    tmax NA   NA   NA NA   NA NA
2 MX17004 2010     1    tmin NA   NA   NA NA   NA NA
3 MX17004 2010     2    tmax NA 27.3 24.1 NA   NA NA
4 MX17004 2010     2    tmin NA 14.4 14.4 NA   NA NA
5 MX17004 2010     3    tmax NA   NA   NA NA 32.1 NA
6 MX17004 2010     3    tmin NA   NA   NA NA 14.2 NA
&amp;gt; raw %&amp;gt;%   # 1.首先处理列变量
+   pivot_longer(
+     d1:d31,
+     names_to = &amp;quot;day&amp;quot;,
+     values_to = &#39;value&#39;,
+     values_drop_na = TRUE
+   ) %&amp;gt;%   # 2.然后处理行变量
+     pivot_wider(
+       names_from = element, values_from = value
+       ) %&amp;gt;%  # 3.提取day中的数字部分
+         mutate(
+           day = as.integer(gsub(&amp;quot;d&amp;quot;, &amp;quot;&amp;quot;, day))
+           )
# A tibble: 33 x 6
   id       year month   day  tmax  tmin
   &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
 1 MX17004  2010     1    30  27.8  14.5
 2 MX17004  2010     2     2  27.3  14.4
 3 MX17004  2010     2     3  24.1  14.4
 4 MX17004  2010     2    11  29.7  13.4
 5 MX17004  2010     2    23  29.9  10.7
 6 MX17004  2010     3     5  32.1  14.2
 7 MX17004  2010     3    10  34.5  16.8
 8 MX17004  2010     3    16  31.1  17.6
 9 MX17004  2010     4    27  36.3  16.7
10 MX17004  2010     5    27  33.2  18.2
# … with 23 more rows
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;小总结&#34;&gt;小总结&lt;/h1&gt;
&lt;p&gt;似乎在数据清理方面，代码可读性&amp;amp;简洁性都满分 ~ 其实 python 并不会比R高贵，不要抱怨为什么学校只教 r 作业也需要 r 完成，因为确实好用（如果你觉得难用，只是因为不熟悉或者不适应👏当然现阶段，面临面试笔试的我们，当然还是需要两个都掌握（听到一些同学对 R 的偏见之后的小感慨.....&lt;/p&gt;
&lt;p&gt;最后放上李舰师兄的两句话，即使是coding初级选手，也要记得严格要求自己代码习惯呀，尤其是可读性方面：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1604469961992.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1604469988890.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">R | Tidy data</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/sql-zi-cha-xun/"" data-c="
          &lt;h1 id=&#34;第六章子查询&#34;&gt;第六章：子查询&lt;/h1&gt;
&lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%AD%90%E6%9F%A5%E8%AF%A2&#34;&gt;第六章：子查询&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#22-%E5%AD%90%E6%9F%A5%E8%AF%A2&#34;&gt;2.2 子查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-in-%E9%A2%84%E7%AE%97%E7%AC%A6&#34;&gt;2.3 IN 预算符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24-in-%E5%AD%90%E6%9F%A5%E8%AF%A2-vs-join%E5%86%85%E8%BF%9E%E6%8E%A5-%E5%92%8C-left-join%E5%A4%96%E8%BF%9E%E6%8E%A5&#34;&gt;2.4 in + 子查询     v.s.  join（内连接） 和 left join（外连接）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#25-all-%E5%85%B3%E9%94%AE%E5%AD%97&#34;&gt;2.5 all 关键字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#26-any-%E5%85%B3%E9%94%AE%E5%AD%97&#34;&gt;2.6 any 关键字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#27-%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2&#34;&gt;2.7 相关子查询!!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#28-exists-%E8%BF%90%E7%AE%97%E7%AC%A6alter&#34;&gt;2.8 exists 运算符alter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#29-select-%E5%AD%90%E5%8F%A5%E4%B8%AD%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2&#34;&gt;2.9 select 子句中的子查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#210-from-%E5%AD%90%E5%8F%A5%E4%B8%AD%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2&#34;&gt;2.10 from 子句中的子查询&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h2 id=&#34;22-子查询&#34;&gt;2.2 子查询&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use sql_store;
select *
from products
where unit_price &amp;gt;= (select unit_price
					from products
					where name regexp &#39;lettuce&#39;);
                    
use sql_hr;
select *
from employees
where salary &amp;gt; (select avg(salary)
				from employees);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;23-in-预算符&#34;&gt;2.3 IN 预算符&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use sql_store;
select * from products
where product_id not in (
	select distinct product_id
-- 	select product_id
	from order_items
);

use sql_invoicing;
select * 
from clients
where client_id not in (
	select distinct client_id
	from invoices
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;24-in-子查询-vs-join内连接-和-left-join外连接&#34;&gt;2.4 in + 子查询     v.s.  join（内连接） 和 left join（外连接）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select *
from clients
left join invoices using(client_id)
where invoice_id is NULL;   # 和前面in+子查询效果一样

use sql_store;  # 多个表格的连接
select distinct customer_id, first_name, last_name
from customers
left join orders using(customer_id)
left join order_items using (order_id)
where product_id in (select product_id
					from products
					where name regexp &#39;lettuce&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;25-all-关键字&#34;&gt;2.5 all 关键字&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use sql_invoicing;
select *
from invoices
where invoice_total &amp;gt;  all (  # 大于一列数，其实就是大于一列数的最大值
	select invoice_total
-- where invoice_total &amp;gt; (  #  和上面是等价的
-- 	select max(invoice_total)
	from invoices
	where client_id = 3
);

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;26-any-关键字&#34;&gt;2.6 any 关键字&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select *
from clients
-- where client_id in (
where client_id = any (   # = any 等价于 in
	select client_id
	from invoices
	group by client_id
	having count(*) &amp;gt; 2
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;27-相关子查询&#34;&gt;2.7 相关子查询!!&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use sql_hr;
select *
from employees e 
where salary &amp;gt; (
	select avg(salary)
	from employees
	where office_id = e.office_id   # 关联子查询
);

use sql_invoicing;
select *
from invoices i
where invoice_total &amp;gt; (
	select avg(invoice_total)
    from invoices
    where client_id = i.client_id
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;28-exists-运算符alter&#34;&gt;2.8 exists 运算符alter&lt;/h2&gt;
&lt;p&gt;/*&lt;br&gt;
第一种方法：in + distinct&lt;br&gt;
第二种方法：exists&lt;br&gt;
1.第一种方法，先运行括号里子查询，结果返回给where子句【空间复杂度增加】&lt;br&gt;
2.第二种方法，返回一个指令，对于每一位客户，子查询检查是否符合条件，找到一个就会返回True&lt;br&gt;
*/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select *
from clients
where client_id in (
	select distinct client_id
    from clients
);

select *    
from clients c        # 连接+存在 
where exists (
	select client_id
    from invoices
    where client_id = c.client_id
);

use sql_store;
select *
from products p
where not exists(
	select product_id
    from order_items
    where product_id = p.product_id
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;29-select-子句中的子查询&#34;&gt;2.9 select 子句中的子查询&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;###  之前所有都是在where后面加子查询
use invoicing;
select invoice_id,
	invoice_total,
    (select avg(invoice_total) from invoices)
		as mean_invoice,  # 把均值变成一列
	(select mean_invoice),
	invoice_total - (select mean_invoice) as diff 
from invoices;

select
	name,
    (select sum(invoice_total) 
		from invoices 
        where client_id = c.client_id) as total_sales,
    (select avg(invoice_total) from invoices) as average, 
    (select total_sales - average)
from clients c; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;210-from-子句中的子查询&#34;&gt;2.10 from 子句中的子查询&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select *
from (
	select
		client_id,
		name,
		(select sum(invoice_total) 
			from invoices 
			where client_id = c.client_id) as total_sales,
		(select avg(invoice_total) from invoices) as average, 
		(select total_sales - average)
	from clients c
) as sales_summary;
&lt;/code&gt;&lt;/pre&gt;
">sql 子查询</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1102/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC198%E9%A2%98%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D&#34;&gt;第198题，打家劫舍&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E7%AD%94%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92&#34;&gt;解答：动态规划&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC206%E9%A2%98%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8&#34;&gt;第206题，翻转链表&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E7%AD%94%E6%A0%88&#34;&gt;解答：栈&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC226%E9%A2%98%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;第226题，翻转二叉树&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E7%AD%94%E7%AE%80%E5%8D%95%E9%80%92%E5%BD%92&#34;&gt;解答：简单递归&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC234%E9%A2%98%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8&#34;&gt;第234题，回文链表&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%9B%B4%E7%99%BD%E8%A7%A3%E6%B3%95&#34;&gt;直白解法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC283%E9%A2%98%E7%A7%BB%E5%8A%A8%E9%9B%B6&#34;&gt;第283题，移动零&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%9B%B4%E7%99%BD%E8%A7%A3%E6%B3%95-2&#34;&gt;直白解法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%82%E8%80%83%E9%A2%98%E8%A7%A3%E5%88%A9%E7%94%A8pop%E5%92%8Cappend&#34;&gt;参考题解：利用pop和append&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;leetcode简单题 day3&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;【198】打家劫舍——动态规划&lt;/li&gt;
&lt;li&gt;【206】反转链表——链表&lt;/li&gt;
&lt;li&gt;【226】翻转二叉树——二叉树&lt;/li&gt;
&lt;li&gt;【234】回文链表——链表&lt;/li&gt;
&lt;li&gt;【283】移动零&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;第198题打家劫舍&#34;&gt;第198题，打家劫舍&lt;/h1&gt;
&lt;p&gt;计划偷窃沿街的房屋，如果&lt;strong&gt;两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警&lt;/strong&gt;。给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：[2, 7, 9, 3, 2, 6,1]&lt;/li&gt;
&lt;li&gt;2 9 2 1&lt;/li&gt;
&lt;li&gt;2 9 6  √&lt;/li&gt;
&lt;li&gt;2 3 6&lt;/li&gt;
&lt;li&gt;2 4 1&lt;/li&gt;
&lt;li&gt;2 2 1&lt;/li&gt;
&lt;li&gt;7 3 6&lt;/li&gt;
&lt;li&gt;7 2 1&lt;/li&gt;
&lt;li&gt;7 6&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解答动态规划&#34;&gt;解答：动态规划&lt;/h2&gt;
&lt;p&gt;计算一个rob list，保存截止到第i家时最高的偷窃金额&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从第三家开始：面对第i家，如果偷——num i + f i-2；如果不偷——f i-1，max做出权衡&lt;/li&gt;
&lt;li&gt;如果&amp;lt;=2家：max&lt;/li&gt;
&lt;li&gt;如果没有：return 0&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 动态规划
def rob(nums):
    n = len(nums)
    if n == 0 :
        return 0
    elif n &amp;lt;= 2:
        return max(nums)
    else:
        amount = [0] * n
        amount[0] = nums[0]
        amount[1] = max(nums[0], nums[1])
        for i in range(2, n):
            amount[i] = max(amount[i - 2] + nums[i], amount[i-1])
        print(amount)
        return amount.pop()

rob([])
rob([3, 1]) 
rob([2, 1, 1, 2])
rob([2, 7, 9, 3, 2, 6, 1])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0






3



[2, 2, 3, 4]





4



[2, 7, 11, 11, 13, 17, 17]





17
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第206题翻转链表&#34;&gt;第206题，翻转链表&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;/li&gt;
&lt;li&gt;输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解答栈&#34;&gt;解答：栈&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 解答
def reverseList(head):
    if (head == None) or (head.next == None):
        return head
    node = head
    node_list = []
    # 顺序遍历
    while node:
        node_list.append(node)
        node = node.next
    n = len(node_list)
    # 倒序设置next
    for i in range(1, n):
        node_list[n-i].next = node_list[n-1-i]
    node_list[0].next = None
    return node_list.pop()



# 测试：
# 定义链表
class ListNode:
     def __init__(self, x):
            self.val = x
            self.next = None
node1 = ListNode(1)
node2 = ListNode(2)
node3 = ListNode(3)
node4 = ListNode(4)
node5 = ListNode(5)
node1.next = node2; node2.next = node3; node3.next = node4; node4.next = node5
node5,reverseList(node1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(&amp;lt;__main__.ListNode at 0x1026fbfd0&amp;gt;, &amp;lt;__main__.ListNode at 0x1026fbfd0&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第226题翻转二叉树&#34;&gt;第226题，翻转二叉树&lt;/h1&gt;
&lt;h2 id=&#34;解答简单递归&#34;&gt;解答：简单递归&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for a binary tree node.
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None

def invertTree(self, root: TreeNode) -&amp;gt; TreeNode:
    # 停止条件
    if root == None:
        return None
    left_child = root.left
    right_child = root.right
    root.left = self.invertTree(right_child)
    root.right = self.invertTree(left_child)
    return root
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第234题回文链表&#34;&gt;第234题，回文链表&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1&lt;/li&gt;
&lt;li&gt;输出: true&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;直白解法&#34;&gt;直白解法&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def isPalindrome(head):
    node = head
    nodelist = []
    while node:
        nodelist.append(node)
        node = node.next
    result = True
    
    while (len(nodelist)&amp;gt;=2) and result:
        first = nodelist.pop(0)
        last = nodelist.pop()
        if not first.val == last.val:
            result = False
    #if len(nodelist) &amp;gt; 0 :
    #    result = False
    return result
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第283题移动零&#34;&gt;第283题，移动零&lt;/h1&gt;
&lt;p&gt;给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
&lt;p&gt;输入: [0,1,0,3,12]&lt;br&gt;
输出: [1,3,12,0,0]&lt;/p&gt;
&lt;h2 id=&#34;直白解法-2&#34;&gt;直白解法&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#### 要求：必须在原数组上操作，不能拷贝额外的数组。
nums = [1,3,12,0,0,4,5,12]
n = len(nums)
for i in range(n):
    if nums[i] == 0 and i&amp;lt; n-1:
        for j in range(i+1, n):
            if nums[j] != 0:
                break
        nums[i] = nums[j]
        nums[j] = 0
print(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1, 3, 12, 4, 5, 12, 0, 0]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;参考题解利用pop和append&#34;&gt;参考题解：利用pop和append&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nums = [1,3,12,0,0,4,5,12]
n = len(nums)
zero_num = 0 
for i in range(n):
    idx = i - zero_num  
    if nums[idx] == 0:
        nums.pop(idx)
        nums.append(0)
        zero_num += 1
print(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0






0



[1, 3, 12, 4, 5, 12, 0, 0]
&lt;/code&gt;&lt;/pre&gt;
">练习题 Day3</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/sql-1102-insert-update-delete/"" data-c="
          &lt;p&gt;/*&lt;br&gt;
表格的列属性:&lt;br&gt;
pk: primary key 主键&lt;br&gt;
nn: not null 非空&lt;br&gt;
uq: unique 不能重复&lt;br&gt;
bin: binary 是否/成功失败/&lt;br&gt;
ai: auto increment 适用于id列，自动加1&lt;br&gt;
default: 默认值&lt;br&gt;
*/&lt;/p&gt;
&lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E5%9B%9B%E7%AB%A0insert-update-delete&#34;&gt;第四章：Insert update delete&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#42-%E6%8F%92%E5%85%A5%E5%8D%95%E8%A1%8C&#34;&gt;4.2 插入单行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#43-%E6%8F%92%E5%85%A5%E5%A4%9A%E8%A1%8C&#34;&gt;4.3 插入多行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#44-%E6%8F%92%E5%85%A5%E5%88%86%E5%B1%82%E8%A1%8C%E5%BE%80%E5%A4%9A%E8%A1%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE&#34;&gt;4.4 插入分层行（（往多表插入数据）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#45-%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%A4%8D%E5%88%B6&#34;&gt;4.5 创建表复制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#46-%E6%9B%B4%E6%96%B0%E5%8D%95%E8%A1%8C&#34;&gt;4.6 更新单行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#47-%E6%9B%B4%E6%96%B0%E5%A4%9A%E8%A1%8C&#34;&gt;4.7 更新多行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#48-update-%E4%B8%AD%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2&#34;&gt;4.8 update 中用子查询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#49-%E5%88%A0%E9%99%A4%E8%A1%8C&#34;&gt;4.9 删除行&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%B1%87%E6%80%BB%E6%95%B0%E6%8D%AE&#34;&gt;第五章 汇总数据&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#51-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0&#34;&gt;5.1 聚合函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#52-group-by&#34;&gt;5.2 group by&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%95%E5%88%97%E7%9A%84group-by&#34;&gt;单列的group by&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%9A%E5%88%97%E7%9A%84group-by&#34;&gt;多列的group by&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#53-having-%E5%AD%90%E5%8F%A5&#34;&gt;5.3 having 子句&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#54-rollup-%E8%BF%90%E7%AE%97%E7%AC%A6&#34;&gt;5.4 rollup 运算符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;第四章insert-update-delete&#34;&gt;第四章：Insert update delete&lt;/h1&gt;
&lt;h2 id=&#34;42-插入单行&#34;&gt;4.2 插入单行&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use sql_store;
insert into customers
values (
	default, 
	&#39;yang&#39;, 
    &#39;shuyi&#39;,
    &#39;1997-01-01&#39;, 
    null,
    &#39;sjtu&#39;,
    &#39;shanghai&#39;,
    &#39;C&#39;,
    &#39;0&#39;
    );
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;43-插入多行&#34;&gt;4.3 插入多行&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;insert into shippers(name)
values (&#39;shipper1&#39;),
	(&#39;shipper2&#39;),
    (&#39;shipper3&#39;);

use sql_inventory;
insert into products(name, quantity_in_stock, unit_price)
values(&#39;product1&#39;, 10, 1.95),
	(&#39;product2&#39;, 11, 1.95),
    (&#39;product3&#39;, 12, 1.95);
    
select * from products;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;44-插入分层行往多表插入数据&#34;&gt;4.4 插入分层行（（往多表插入数据）&lt;/h2&gt;
&lt;p&gt;/*&lt;br&gt;
增加一个新订单，orders 和 order_items 两个表都要变动&lt;br&gt;
*/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use sql_store;
insert into orders(customer_id,order_date, status)
values(1, &#39;2020-11-02&#39;, 1);  # 新order id 自动生成
select last_insert_id();    # 获取新的id
insert into order_items     # 把生成的新id插入另一张表
values(last_insert_id(), 4,2,2.22),
	(last_insert_id(), 2,2,2.22),
    (last_insert_id(), 3,2,2.22);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;45-创建表复制&#34;&gt;4.5 创建表复制&lt;/h2&gt;
&lt;p&gt;create table orders_archived as   #创建新表 create table xxx as&lt;br&gt;
select * from orders;  # 把一个表所有内容复制过去&lt;br&gt;
/*&lt;br&gt;
1.注意，新表和旧表的区别在于：&lt;br&gt;
主键、自动递增（ai）这些标记都没有了&lt;br&gt;
2.选择一个表，然后右键，truncate可以把表格所有内容清空&lt;br&gt;
*/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;insert into orders_archived 
select * from orders
where order_date &amp;lt; &#39;2019-01-01&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;46-更新单行&#34;&gt;4.6 更新单行&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use invoicing;

update invoices
set payment_total = 10, payment_date  = &#39;2019-01-02&#39;
where invoice_id = 1;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;47-更新多行&#34;&gt;4.7 更新多行&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;update invoices
set payment_total = invoice_total * 0.2 , payment_date  = due_date
where invoice_id in ( 3, 4 );

use sql_store;
update customers
set points = points + 50
where birth_date &amp;lt; &#39;1990-01-01&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;48-update-中用子查询&#34;&gt;4.8 update 中用子查询&lt;/h2&gt;
&lt;p&gt;/*&lt;br&gt;
注意把select子查询用括号框起来，这样首先执行子查询&lt;br&gt;
最好用缩进更加清晰&lt;br&gt;
*/&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use invoicing;
update invoices
set payment_total = invoice_total * 0.2 , payment_date  = due_date
where invoice_id = 
			(select client_id
			from clients
			where name = &#39;myworks&#39;);

update invoices
set payment_total = invoice_total * 0.2 , payment_date  = due_date
where invoice_id in
			(select client_id
			from clients
			where state in (&#39;ny&#39;,&#39;ca&#39;));

use sql_store;
update orders
set comments = &#39;gold customer&#39;
where customer_id in
			(select customer_id
            from customers
            where points &amp;gt; 3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;49-删除行&#34;&gt;4.9 删除行&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use invoicing;
delete from invoices
where client_id in 
		(select client_id
		from clients
		where name = &#39;Myworks&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第五章-汇总数据&#34;&gt;第五章 汇总数据&lt;/h1&gt;
&lt;p&gt;/*&lt;br&gt;
第五章 汇总数据&lt;br&gt;
1.聚合函数——描述统计 max min avg sum count(返回非空)&lt;br&gt;
2.group by&lt;br&gt;
3.having 子句&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;rollup 运算符&lt;br&gt;
*/&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;51-聚合函数&#34;&gt;5.1 聚合函数&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use invoicing;
select max(invoice_total) as highest,
	min(invoice_total) as lowest,
    avg(invoice_total) as average,
    count(payment_date) as number_of_payment,    # null不计入
    count( * ) as number_records,    # 总行数
    count(distinct client_id)as unique_id_numers,  # 取unique
    avg(invoice_total) * count(invoice_total) as sum,
    sum(invoice_total + 1)
from invoices
where invoice_date &amp;gt; &#39;2019-05-01&#39;;

select &#39;First half of 2019&#39; as date_range,
	sum(invoice_total) as total_sales,
    sum(payment_total) as total_payment,
    sum(invoice_total) -  sum(payment_total) as what_we_expect
from invoices
where invoice_date between &#39;2019-01-01&#39; and &#39;2019-06-30&#39;
union
select &#39;Second half of 2019&#39; as date_range,
	sum(invoice_total) as total_sales,
    sum(payment_total) as total_payment,
    sum(invoice_total) -  sum(payment_total) as what_we_expect
from invoices
where invoice_date between &#39;2019-07-01&#39; and &#39;2019-12-31&#39;
union
select &#39;Year 2019&#39; as date_range,
	sum(invoice_total) as total_sales,
    sum(payment_total) as total_payment,
    sum(invoice_total) -  sum(payment_total) as what_we_expect
from invoices;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;52-group-by&#34;&gt;5.2 group by&lt;/h2&gt;
&lt;h3 id=&#34;单列的group-by&#34;&gt;单列的group by&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select 
	client_id,
	sum(invoice_total) as total_sales
from invoices
group by client_id
order by total_sales desc;   # 记得orderby在groupby之后alter
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;多列的group-by&#34;&gt;多列的group by&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select 
	state, city,
    sum(invoice_total) as total_sales
from invoices
join clients using (client_id)
group by state, city;

select 
	date, 
    name as payment_method,
    sum(amount) as total_payment
from payments p
join payment_methods pm
where p.payment_method = pm.payment_method_id
group by date, name
order by date;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;53-having-子句&#34;&gt;5.3 having 子句&lt;/h2&gt;
&lt;p&gt;对于聚合函数计算之后的数据进行的筛选——having&lt;br&gt;
/*&lt;br&gt;
having v.s. where 不同点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;group by 前后用&lt;br&gt;
2.where 中的列可以不在select 里面&lt;br&gt;
having 中的列需要在select 里面&lt;br&gt;
*/&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select 
	client_id,
	sum(invoice_total) as total_sales,
    count(*) as numbers
from invoices
-- where total_sales &amp;gt; 500    # 会报错因为 total_sales 必须在groupby之后
group by client_id
having total_sales &amp;gt; 800;     # 分组之后的筛选


use sql_store;
select 
	c.customer_id,
    c.first_name,
    c.last_name,
	sum( unit_price * quantity) as total_pay
from customers c
join orders o using(customer_id)
join order_items using(order_id)
where state = &#39;va&#39;
group by c.customer_id
having total_pay &amp;gt; 100;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;54-rollup-运算符&#34;&gt;5.4 rollup 运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;末尾增加一行汇总结果&lt;/li&gt;
&lt;li&gt;注意，这个运算符仅仅在mysql里有！sql server 就没法用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use invoicing ;
select
	client_id,
    sum(invoice_total) as total_sales,
    avg(invoice_total) as avg_sales
from invoices
group by client_id with rollup;
&lt;/code&gt;&lt;/pre&gt;
">sql 1102 更新插入/描述统计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/zi-wo-jie-zhi-gan/"" data-c="
          &lt;p&gt;真正的自我价值感是发自内心的，通过被表扬或者好成绩获得的价值感只会是短暂的，随后仍然处于自我怀疑和焦虑，面对无法解决的事情只会想要逃避。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;原谅&lt;br&gt;
已经发生过的事情不要太过纠结，原谅自己，要学会向前看呀。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接受&lt;br&gt;
接受自己，接受真实的自己。embrace你的缺点。不能总依赖别人传递负面情绪，自我消化，多给自己一些善意。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同理心&lt;br&gt;
敢于承认自己的脆弱，会发现你并不孤单。当然也要记得面对别人传递的负面情绪多一些同理心，不要只顾着judge，尝试连接自己的感受feeling with u，才能真正帮到对方。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;要么被卷死，要么成为卷王？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;请接受和信任自己直觉感受到的快乐，少一点理性。&lt;/li&gt;
&lt;li&gt;放下对快乐的警觉，更勇敢一些直觉想要的事情，要勇敢！&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;一直冲&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前几天看到朋友说，人生其实就是一直冲，总是要准备各种各样的事情，所以要勇敢面对冲冲冲呀（偶尔停下来休息给自己放个假也八错哈哈哈&lt;/p&gt;
">自我价值感</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1031/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#cart-%E5%9B%9E%E5%BD%92%E6%A0%91&#34;&gt;cart 回归树&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E9%81%8D%E5%8E%86%E9%80%89%E5%8F%96%E6%9C%80%E4%BC%98%E5%88%86%E5%89%B2%E6%96%B9%E5%BC%8F&#34;&gt;1.遍历选取最优分割方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E6%8C%89%E7%85%A7%E6%8C%87%E5%AE%9A%E6%96%B9%E5%BC%8F%E5%88%86%E5%89%B2%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86&#34;&gt;2.按照指定方式分割后的数据集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E5%AE%9A%E4%B9%89%E8%8A%82%E7%82%B9&#34;&gt;3.定义节点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%E9%80%92%E5%BD%92%E7%94%9F%E6%88%90%E6%A0%91&#34;&gt;4.递归生成树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5%E9%80%92%E5%BD%92%E6%89%93%E5%8D%B0%E6%A0%91&#34;&gt;5.递归打印树&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;实现gbdt或者xgboost 之前，先完成回归树，和先前的ID3算法基本流程一致，所以很简单：&lt;/p&gt;
&lt;h1 id=&#34;cart-回归树&#34;&gt;cart 回归树&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;最小二乘回归树生成算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;思路——递归，参考《统计学习方法》李航&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;结束条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有特征了&lt;/li&gt;
&lt;li&gt;没有样本了（说明上一步归入了同一类——把父节点标记为叶节点）&lt;/li&gt;
&lt;li&gt;所有样本的y都是一样的（说明上一步归入了同一类——把父节点标记为叶节点）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;遍历&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遍历特征集合 + 遍历所有可能的阈值&lt;/li&gt;
&lt;li&gt;计算切分后落在左右的离差平方和之和&lt;/li&gt;
&lt;li&gt;找到使得“方差之和”最小的特征、阈值、左右均值/预测值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于左右两部分数据集递归调用算法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 使用boston 房价数据
from keras.datasets import boston_housing
(train_x, train_y), (test_x, test_y) = boston_housing.load_data()
train_x.shape, test_x.shape

## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;((404, 13), (102, 13))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;train_x.shape
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(404, 13)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1遍历选取最优分割方式&#34;&gt;1.遍历选取最优分割方式&lt;/h2&gt;
&lt;p&gt;输出：分割特征、阈值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd
import numpy as np


def square_loss(x):
    xx  = x - np.mean(x)
    return np.dot(xx, xx.T)


def argmin_col_val(data_x, data_y):
    p = data_x.shape[1]
    n = data_x.shape[0]
    if n &amp;lt;= 5:
        return None, None, 0
        
    
    # 1. 遍历所有特征
    for i in range(p):
        col0 = [x[i] for x in data_x]
        values = np.unique(col0)
        feature_values = [v for v in values if (not v==np.min(values)) and \
                          (not v==np.max(values))]
        square_parent = square_loss(data_y) 
        square_new = square_parent
        
        # 2. 遍历该特征所有取值
        for v in feature_values:
            col1 = [data_x[x][i] &amp;gt;= v for x in range(n)]
            col2 = [data_x[x][i] &amp;lt; v for x in range(n)]
            tmp = square_loss(data_y[col1]) + square_loss(data_y[col2])
            # 找到平方和最小的分割方式
            if tmp &amp;lt;= square_new:
                square_new = tmp
                min_col = i
                min_value = v
                mean_right  = np.mean(data_y[col1])
                mean_left = np.mean(data_y[col2])
    # 输出最优分割特征、阈值、左右均值（预测）、分割前后平方和的变化量
    return min_col, min_value, square_parent - square_new
    
    
# 进行第一次划分：
col_1, value_1, square_change = argmin_col_val(train_x, train_y)
print(col_1, value_1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;12 9.64
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2按照指定方式分割后的数据集&#34;&gt;2.按照指定方式分割后的数据集&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 按照指定方式分割，输出分割后的data
def split_data(data_x, data_y, min_col, min_value):
    col1 = [x[min_col] &amp;gt;= min_value for x in data_x]
    col2 = [x[min_col] &amp;lt; min_value for x in data_x]
    data_x = np.array([np.delete(x, min_col) for x in data_x])
    subset_left_x = data_x[col1]
    subset_right_x = data_x[col2]
    subset_left_y = data_y[col1]
    subset_right_y = data_y[col2]
    return subset_left_x, subset_right_x, subset_left_y,subset_right_y
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3定义节点&#34;&gt;3.定义节点&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Node:                       # 定义树节点  
    def __init__(self, name):
        self.name = name
        self.connections = {}    
            
    def connect(self, label, node):   # 节点对应多个子节点
        self.connections[label] = node 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4递归生成树&#34;&gt;4.递归生成树&lt;/h2&gt;
&lt;p&gt;这我直接设置最小square_change为300（以免过拟合）懒得加参数了...&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def bulid_cart(train_x, train_y, parent_node, parent_connection_label):
    min_col, min_val, square_change = argmin_col_val(train_x, train_y)
    # 1.结束条件
    if (not min_col)  or  (square_change &amp;lt; 300): 
        node = Node(np.mean(train_y))
        parent_node.connect(parent_connection_label, node)   # 设置为叶节点
        return

    #print(&amp;quot;最优分割列{} 阈值{} 损失降低{}&amp;quot;.format(min_col, min_val, square_change))
    # 2.生成新节点
    node = Node(min_col)       # 生成新节点
    parent_node.connect(parent_connection_label, node)
    
    # 3.对左右递归
    subset_left_x, subset_right_x, subset_left_y, subset_right_y = split_data(train_x, train_y, min_col, min_val)
    bulid_cart(subset_left_x, subset_left_y, node, &amp;quot;列&amp;quot;+str(min_col) +&amp;quot;&amp;lt;&amp;quot; +str(min_val) )
    bulid_cart(subset_right_x, subset_right_y, node,  &amp;quot;列&amp;quot;+str(min_col) +&amp;quot;&amp;gt;=&amp;quot; +str(min_val))
    

root = Node(&#39;root&#39;)
bulid_cart(train_x, train_y, root, &amp;quot;&amp;quot;)  
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5递归打印树&#34;&gt;5.递归打印树&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def print_tree(node, tabs):
    print(str(tabs) + str(node.name))        
    for connection, child_node in node.connections.items():
        print(str(tabs) + &amp;quot;\t&amp;quot; + &amp;quot;(&amp;quot; + str(connection) + &amp;quot;)&amp;quot;)
        print_tree(child_node, str(tabs) + &amp;quot;\t\t&amp;quot;) 

print_tree(root,&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;root
	()
		12
			(列12&amp;lt;9.64)
				11
					(列11&amp;lt;288.99)
						10
							(列10&amp;lt;19.7)
								16.116190476190475
							(列10&amp;gt;=19.7)
								20.366666666666667
					(列11&amp;gt;=288.99)
						13.183333333333332
			(列12&amp;gt;=9.64)
				11
					(列11&amp;lt;395.58)
						10
							(列10&amp;lt;19.6)
								21.5
							(列10&amp;gt;=19.6)
								27.7452380952381
					(列11&amp;gt;=395.58)
						10
							(列10&amp;lt;14.8)
								9
									(列9&amp;lt;430.0)
										38.75555555555556
									(列9&amp;gt;=430.0)
										8
											(列8&amp;lt;7.0)
												7
													(列7&amp;lt;4.148)
														26.928571428571427
													(列7&amp;gt;=4.148)
														38.230000000000004
											(列8&amp;gt;=7.0)
												27.894915254237286
							(列10&amp;gt;=14.8)
								9
									(列9&amp;lt;264.0)
										38.306250000000006
									(列9&amp;gt;=264.0)
										49.625
&lt;/code&gt;&lt;/pre&gt;
">实现最小二乘回归树</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/sql-1030-lian-jie/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%9E%E6%8E%A5&#34;&gt;连接&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-%E5%86%85%E8%BF%9E%E6%8E%A5&#34;&gt;3.1 内连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-%E8%B7%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5&#34;&gt;3.2 跨数据库连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#34-%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5&#34;&gt;3.4 多表连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#35-%E5%A4%8D%E5%90%88%E8%BF%9E%E6%8E%A5%E6%9D%A1%E4%BB%B6&#34;&gt;3.5 复合连接条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#36-%E9%9A%90%E5%BC%8F%E8%BF%9E%E6%8E%A5&#34;&gt;3.6 隐式连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#37-%E5%A4%96%E8%BF%9E%E6%8E%A5&#34;&gt;3.7 外连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#38-%E5%A4%9A%E8%A1%A8%E5%A4%96%E8%BF%9E%E6%8E%A5&#34;&gt;3.8 多表外连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#39-%E8%87%AA%E5%A4%96%E8%BF%9E%E6%8E%A5&#34;&gt;3.9 自外连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#310-using%E7%AE%80%E5%8C%96join&#34;&gt;3.10 using——简化join&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#311-%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5%E8%87%AA%E5%8A%A8%E6%8A%8A%E7%9B%B8%E5%90%8Ccol%E4%BD%9C%E4%B8%BA%E5%90%88%E5%B9%B6%E6%9D%A1%E4%BB%B6&#34;&gt;3.11 自然连接，自动把相同col作为合并条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#312-%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5&#34;&gt;3.12 交叉连接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#313-union-%E8%A1%8C%E7%9A%84combine&#34;&gt;3.13 union 行的combine&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;连接&#34;&gt;连接&lt;/h1&gt;
&lt;p&gt;/*&lt;br&gt;
第三章：表的连接&lt;br&gt;
*/&lt;/p&gt;
&lt;h2 id=&#34;31-内连接&#34;&gt;3.1 内连接&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use sql_store;
select order_id, o.customer_id, first_name, last_name
from orders o   # 使用缩写
join customers c  # 根据 customer_id 连接
	on o.customer_id = c.customer_id 
order by order_id;


select order_id, oi.product_id, quantity, oi.unit_price
from order_items oi
join products p
	on oi.product_id = p.product_id;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;32-跨数据库连接&#34;&gt;3.2 跨数据库连接&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select * 
from order_items oi
join sql_inventory.products p   # 不在current db里的需要加前缀
	on oi.product_id = p.product_id;

## 3.3 自连接 self join
use sql_hr;

select e.employee_id,e.first_name, m.first_name as manager_name
from employees e
join employees m  # 员工之间的从属关系
	on e.reports_to = m.employee_id;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;34-多表连接&#34;&gt;3.4 多表连接&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use sql_store;
select 
	o.order_id, 
    o.order_date,
    c.first_name,
    c.last_name,
    os.name as status
from orders o 
join customers c 
	on o.customer_id = c.customer_id
join order_statuses os
	on os.order_status_id = o.status
order by o.order_id;

use invoicing;
select payment_id,date, amount,
	c.name as customer_name,
    pm.name as payment_method
from payments p
join clients c
	on p.client_id = c.client_id
join payment_methods pm
	on pm.payment_method_id = p.payment_method
order by p.date desc;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;35-复合连接条件&#34;&gt;3.5 复合连接条件&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use sql_store;
情况（复合主键）:每一个订单有多个产品，需要用订单+产品两列来作为唯一标示（复合主键）
select *
from order_items oi
join order_item_notes oin
	on oi.order_id = oin.order_id
    and oi.product_id = oin.product_id;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;36-隐式连接&#34;&gt;3.6 隐式连接&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;其实就是 全连接/交叉连接 + where条件
最好不要用，还是用Join
select *
from orders o, customers c   
where o.customer_id = c.customer_id;  
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;37-外连接&#34;&gt;3.7 外连接&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;/*
join：inner join
left / right join ：outer join
*/
select   # 这是一个inner join
	c.customer_id,
    c.first_name,
    o.order_id
from customers c
join orders o
	on o.customer_id = c.customer_id
order by c.customer_id;    # 只有部分customers（有order的）


select   # 这是一个outer join
	c.customer_id,
    c.first_name,
    o.order_id
from customers c left join orders o   # c中所有customer都会返回
	on o.customer_id = c.customer_id  # on里的条件只对o起作用
order by c.customer_id;    


select    # 练习
	p.product_id,
    p.name,
    oi.quantity
from products p
left join order_items oi
on p.product_id = oi.product_id;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;38-多表外连接&#34;&gt;3.8 多表外连接&lt;/h2&gt;
&lt;p&gt;多次连接最好只用 left join 方便第三人理解&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select   # 这是一个outer join
   c.customer_id,
   c.first_name as customer_name,
   o.order_id,
   o.shipper_id,
   sh.name as shipper_name
from customers c 
left join orders o   
   on o.customer_id = c.customer_id 
left join shippers sh  # 多次外连接
   on sh.shipper_id = o.shipper_id
order by c.customer_id;    
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;39-自外连接&#34;&gt;3.9 自外连接&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use sql_hr;
select   
	e.employee_id,
    e.first_name,
    m.first_name as manager_name
from employees e
left join employees m   # 老板没有reports_to，leftjoin才能出现
	on e.reports_to = m.employee_id;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;310-using简化join&#34;&gt;3.10 using——简化join&lt;/h2&gt;
&lt;p&gt;但是只有列名相同之后才能用！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use sql_store;
select 
	o.order_id,
    c.first_name,
    sh.name as shipper_name
from orders o
join customers c
	using (customer_id) 
join shippers sh
	using (shipper_id);


select *  # 前面那个复合主键的问题如何用using
from order_items oi
join order_item_notes oin
	-- on oi.order_id = oin.order_id
    -- and oi.product_id = oin.product_id;
    using (order_id, product_id);
    
    
use invoicing;
select
	p.date,
    c.name as client_name,
    p.amount,
	pm.name as payment_method
from payments p
join clients c 
	using (client_id)
join payment_methods pm
	on pm.payment_method_id = p.payment_method;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;311-自然连接自动把相同col作为合并条件&#34;&gt;3.11 自然连接，自动把相同col作为合并条件&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;use sql_store;
select
	o.order_id,
    c.first_name
from orders o
natural join customers c; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;312-交叉连接&#34;&gt;3.12 交叉连接&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select 
	c.first_name as customer,
	p.name as product
-- from customers c, products p  # 方法1
from customers c
cross join products p   # 方法2. 都不需要条件
order by first_name;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;313-union-行的combine&#34;&gt;3.13 union 行的combine&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select 
	order_id,
    order_date,
    &#39;active&#39; as status
from orders
where order_date &amp;gt;= &#39;2019-01-01&#39;
union   # 行的combine
select 
	order_id,
    order_date,
    &#39;archived&#39; as status
from orders
where order_date &amp;lt; &#39;2019-01-01&#39;;

select 
	customer_id,
    first_name,
    points,
    &#39;Gold&#39; as type
from customers
where points &amp;gt; 3000
union
select 
	customer_id,
    first_name,
    points,
    &#39;Silver&#39; as type
from customers
where points &amp;lt;= 3000 and points &amp;gt; 2000
union
select 
	customer_id,
    first_name,
    points,
    &#39;Bronze&#39; as type
from customers
where points &amp;lt;= 2000;
&lt;/code&gt;&lt;/pre&gt;
">sql 1030 join</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/sklearn-or-decision-tree-and-random_forest/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#1%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE&#34;&gt;1.读入数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E6%8F%8F%E8%BF%B0%E7%BB%9F%E8%AE%A1&#34;&gt;2.描述统计&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21%E8%BF%9E%E7%BB%AD%E5%8F%98%E9%87%8F&#34;&gt;2.1连续变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%E7%9B%B8%E5%85%B3%E7%9F%A9%E9%98%B5&#34;&gt;2.2 相关矩阵&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23-%E5%88%86%E7%B1%BB%E5%8F%98%E9%87%8F&#34;&gt;2.3 分类变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24-%E6%98%AF%E5%90%A6%E7%A6%BB%E8%81%8C&#34;&gt;2.4 是否离职&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%A6%BB%E8%81%8C%E7%8E%87&#34;&gt;离职率&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%BB%A1%E6%84%8F%E5%BA%A6-%E7%A6%BB%E8%81%8C-vs-%E6%9C%AA%E7%A6%BB%E8%81%8C&#34;&gt;满意度 - 离职 V.S. 未离职&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%A9%E6%95%88%E8%AF%84%E4%BC%B0-%E7%A6%BB%E8%81%8C-vs-%E6%9C%AA%E7%A6%BB%E8%81%8C&#34;&gt;绩效评估 - 离职 V.S. 未离职&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E5%BB%BA%E6%A8%A1&#34;&gt;3. 建模&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#31-%E9%A2%84%E5%A4%84%E7%90%86&#34;&gt;3.1 预处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#32-%E5%86%B3%E7%AD%96%E6%A0%91&#34;&gt;3.2 决策树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#33-rf&#34;&gt;3.3 rf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#34-%E5%AF%B9%E6%AF%94%E5%86%B3%E7%AD%96%E6%A0%91%E5%92%8C%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97&#34;&gt;3.4 对比决策树和随机森林&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%98%E9%87%8F%E9%87%8D%E8%A6%81%E6%80%A7%E6%96%B9%E9%9D%A2&#34;&gt;变量重要性方面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#roc&#34;&gt;roc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;一个实例 with rf&lt;/p&gt;
&lt;p&gt;rf原理很简单，不多赘述，懒得实现直接调包吧&lt;/p&gt;
&lt;h1 id=&#34;1读入数据&#34;&gt;1.读入数据&lt;/h1&gt;
&lt;p&gt;数据来自https://www.kaggle.com/ludobenistant/hr-analytics&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;satisfaction_level : 满意度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;last_evaluation : 绩效评估&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;number_project : 完成项目数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;average_montly_hours : 平均月度工作时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;time_spend_company : 服务年限&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Work_accident : 是否有工伤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;left : 是否离职（选这个作为因变量，简陋的员工流失分析哈哈）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;promotion_last_5years: 过去5年是否有升职&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sales : 工作部门&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;salary：薪资水平&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd
import numpy as np
import os
%matplotlib inline

## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    

## 读入
os.chdir(&amp;quot;/Users/mac/Desktop/快乐研一/python/机器学习/集成学习-例子&amp;quot;)
df0 = pd.read_csv(&amp;quot;HR_comma_sep.csv&amp;quot;)
df = df0.rename(columns={&#39;sales&#39; : &#39;department&#39;}) # 部门


## 检查缺失
df.isnull().any()
df.head()
df.shape
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(14999, 10)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2描述统计&#34;&gt;2.描述统计&lt;/h1&gt;
&lt;h2 id=&#34;21连续变量&#34;&gt;2.1连续变量&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;df.describe()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;satisfaction_level&lt;/th&gt;
      &lt;th&gt;last_evaluation&lt;/th&gt;
      &lt;th&gt;number_project&lt;/th&gt;
      &lt;th&gt;average_montly_hours&lt;/th&gt;
      &lt;th&gt;time_spend_company&lt;/th&gt;
      &lt;th&gt;Work_accident&lt;/th&gt;
      &lt;th&gt;left&lt;/th&gt;
      &lt;th&gt;promotion_last_5years&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;count&lt;/th&gt;
      &lt;td&gt;14999.000000&lt;/td&gt;
      &lt;td&gt;14999.000000&lt;/td&gt;
      &lt;td&gt;14999.000000&lt;/td&gt;
      &lt;td&gt;14999.000000&lt;/td&gt;
      &lt;td&gt;14999.000000&lt;/td&gt;
      &lt;td&gt;14999.000000&lt;/td&gt;
      &lt;td&gt;14999.000000&lt;/td&gt;
      &lt;td&gt;14999.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;mean&lt;/th&gt;
      &lt;td&gt;0.612834&lt;/td&gt;
      &lt;td&gt;0.716102&lt;/td&gt;
      &lt;td&gt;3.803054&lt;/td&gt;
      &lt;td&gt;201.050337&lt;/td&gt;
      &lt;td&gt;3.498233&lt;/td&gt;
      &lt;td&gt;0.144610&lt;/td&gt;
      &lt;td&gt;0.238083&lt;/td&gt;
      &lt;td&gt;0.021268&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;std&lt;/th&gt;
      &lt;td&gt;0.248631&lt;/td&gt;
      &lt;td&gt;0.171169&lt;/td&gt;
      &lt;td&gt;1.232592&lt;/td&gt;
      &lt;td&gt;49.943099&lt;/td&gt;
      &lt;td&gt;1.460136&lt;/td&gt;
      &lt;td&gt;0.351719&lt;/td&gt;
      &lt;td&gt;0.425924&lt;/td&gt;
      &lt;td&gt;0.144281&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;min&lt;/th&gt;
      &lt;td&gt;0.090000&lt;/td&gt;
      &lt;td&gt;0.360000&lt;/td&gt;
      &lt;td&gt;2.000000&lt;/td&gt;
      &lt;td&gt;96.000000&lt;/td&gt;
      &lt;td&gt;2.000000&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;25%&lt;/th&gt;
      &lt;td&gt;0.440000&lt;/td&gt;
      &lt;td&gt;0.560000&lt;/td&gt;
      &lt;td&gt;3.000000&lt;/td&gt;
      &lt;td&gt;156.000000&lt;/td&gt;
      &lt;td&gt;3.000000&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;50%&lt;/th&gt;
      &lt;td&gt;0.640000&lt;/td&gt;
      &lt;td&gt;0.720000&lt;/td&gt;
      &lt;td&gt;4.000000&lt;/td&gt;
      &lt;td&gt;200.000000&lt;/td&gt;
      &lt;td&gt;3.000000&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;75%&lt;/th&gt;
      &lt;td&gt;0.820000&lt;/td&gt;
      &lt;td&gt;0.870000&lt;/td&gt;
      &lt;td&gt;5.000000&lt;/td&gt;
      &lt;td&gt;245.000000&lt;/td&gt;
      &lt;td&gt;4.000000&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;max&lt;/th&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;7.000000&lt;/td&gt;
      &lt;td&gt;310.000000&lt;/td&gt;
      &lt;td&gt;10.000000&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;22-相关矩阵&#34;&gt;2.2 相关矩阵&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;corr = df.corr()
import seaborn as sns

sns.heatmap(corr, 
            xticklabels=corr.columns.values,
            yticklabels=corr.columns.values)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1604028074671.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;社畜真实，绩效和花费时间、项目数成正相关&lt;/p&gt;
&lt;h2 id=&#34;23-分类变量&#34;&gt;2.3 分类变量&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;print(df.department.value_counts() / len(df), &amp;quot;\n&amp;quot;)   # 哪些部门
print(df.salary.value_counts() / len(df))   # 工资水平分布
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;sales          0.276018
technical      0.181345
support        0.148610
IT             0.081805
product_mng    0.060137
marketing      0.057204
RandD          0.052470
accounting     0.051137
hr             0.049270
management     0.042003
Name: department, dtype: float64 

low       0.487766
medium    0.429762
high      0.082472
Name: salary, dtype: float64
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;24-是否离职&#34;&gt;2.4 是否离职&lt;/h2&gt;
&lt;h3 id=&#34;离职率&#34;&gt;离职率&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 离职率
print(&amp;quot;离职率: {}&amp;quot;.format(df.left.mean()))

# 按是否left group by自变量
df.groupby(&#39;left&#39;).mean()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;离职率: 0.2380825388359224
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;satisfaction_level&lt;/th&gt;
      &lt;th&gt;last_evaluation&lt;/th&gt;
      &lt;th&gt;number_project&lt;/th&gt;
      &lt;th&gt;average_montly_hours&lt;/th&gt;
      &lt;th&gt;time_spend_company&lt;/th&gt;
      &lt;th&gt;Work_accident&lt;/th&gt;
      &lt;th&gt;promotion_last_5years&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;left&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;0.666810&lt;/td&gt;
      &lt;td&gt;0.715473&lt;/td&gt;
      &lt;td&gt;3.786664&lt;/td&gt;
      &lt;td&gt;199.060203&lt;/td&gt;
      &lt;td&gt;3.380032&lt;/td&gt;
      &lt;td&gt;0.175009&lt;/td&gt;
      &lt;td&gt;0.026251&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;0.440098&lt;/td&gt;
      &lt;td&gt;0.718113&lt;/td&gt;
      &lt;td&gt;3.855503&lt;/td&gt;
      &lt;td&gt;207.419210&lt;/td&gt;
      &lt;td&gt;3.876505&lt;/td&gt;
      &lt;td&gt;0.047326&lt;/td&gt;
      &lt;td&gt;0.005321&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;p&gt;大致看出，离职的人不咋满意、工作更长、没得到晋升&lt;/p&gt;
&lt;p&gt;下面看看是否left（两个总体）在一些自变量上的分布是否存在差异&lt;/p&gt;
&lt;h3 id=&#34;满意度-离职-vs-未离职&#34;&gt;满意度 - 离职 V.S. 未离职&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pyplot as plt
import matplotlib.font_manager as mfm
font_path = r&amp;quot;/Users/mac/Library/Fonts/字体管家方萌简（非商业使用）v1.1.ttf&amp;quot;
prop = mfm.FontProperties(fname = font_path)

fig = plt.figure(figsize=(15,4),)
ax1 = sns.kdeplot(df.loc[(df[&#39;left&#39;] == 0), &#39;satisfaction_level&#39;] , color=&#39;orange&#39;, shade=True, label=&#39;not left&#39;)
ax1 = sns.kdeplot(df.loc[(df[&#39;left&#39;] == 1), &#39;satisfaction_level&#39;] , color=&#39;dodgerblue&#39;, shade=True, label=&#39;left&#39;)
ax1.set(xlabel = &#39;satisfaction&#39;, ylabel = &#39;freq&#39;)
plt.title(&#39;满意度 - 离职 V.S. 未离职&#39;, fontproperties = prop, fontsize = 30)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1604028027148.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;绩效评估-离职-vs-未离职&#34;&gt;绩效评估 - 离职 V.S. 未离职&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(15,4),)
ax1 = sns.kdeplot(df.loc[(df[&#39;left&#39;] == 0), &#39;last_evaluation&#39;] , color = &#39;orange&#39;, shade = True, label = &#39;not left&#39;)
ax1 = sns.kdeplot(df.loc[(df[&#39;left&#39;] == 1), &#39;last_evaluation&#39;] , color = &#39;dodgerblue&#39;, shade = True, label = &#39;left&#39;)
ax1.set(xlabel = &#39;satisfaction&#39;, ylabel = &#39;freq&#39;)
plt.title(&#39;绩效评估 - 离职 V.S. 未离职&#39;, fontproperties = prop, fontsize = 30)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1604028022188.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;懂了，废物和大佬跑路之后，留在公司的都是混子&lt;/p&gt;
&lt;h1 id=&#34;3-建模&#34;&gt;3. 建模&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 1.预处理的：
from sklearn.model_selection import train_test_split

# 2.建立决策树和rf
from sklearn import tree  # decision tree
from sklearn.ensemble import RandomForestClassifier  # rf
from sklearn.metrics import accuracy_score # 计算预测准确率
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;31-预处理&#34;&gt;3.1 预处理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;提取xy&lt;/li&gt;
&lt;li&gt;把分类变量 string 调整为 category，再编码&lt;/li&gt;
&lt;li&gt;切分训练和测试&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 1.提取特征
feature_names = [col for col in df.columns if col != &#39;left&#39;]   
X = df.drop(&#39;left&#39;, axis = 1)
y = df[&#39;left&#39;]


# 2.处理字符串变量
print(dict(enumerate(df[&amp;quot;department&amp;quot;].astype(&#39;category&#39;).cat.categories)))  
X[&amp;quot;department&amp;quot;] = X[&amp;quot;department&amp;quot;].astype(&#39;category&#39;).cat.codes
X[&amp;quot;salary&amp;quot;] = X[&amp;quot;salary&amp;quot;].astype(&#39;category&#39;).cat.codes


# 3.分为训练和测试数据集
# 注意参数 stratify = y 意味着在产生训练和测试数据中, 离职的员工的百分比等于原来总的数据中的离职的员工的百分比
X_train, X_test, y_train, y_test = train_test_split( X, y, test_size = 0.2, stratify = y)
X_train.shape, X_test.shape
X_train.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{0: &#39;IT&#39;, 1: &#39;RandD&#39;, 2: &#39;accounting&#39;, 3: &#39;hr&#39;, 4: &#39;management&#39;, 5: &#39;marketing&#39;, 6: &#39;product_mng&#39;, 7: &#39;sales&#39;, 8: &#39;support&#39;, 9: &#39;technical&#39;}


((11999, 9), (3000, 9))
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;satisfaction_level&lt;/th&gt;
      &lt;th&gt;last_evaluation&lt;/th&gt;
      &lt;th&gt;number_project&lt;/th&gt;
      &lt;th&gt;average_montly_hours&lt;/th&gt;
      &lt;th&gt;time_spend_company&lt;/th&gt;
      &lt;th&gt;Work_accident&lt;/th&gt;
      &lt;th&gt;promotion_last_5years&lt;/th&gt;
      &lt;th&gt;department&lt;/th&gt;
      &lt;th&gt;salary&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;13660&lt;/th&gt;
      &lt;td&gt;0.50&lt;/td&gt;
      &lt;td&gt;0.77&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;267&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5606&lt;/th&gt;
      &lt;td&gt;0.66&lt;/td&gt;
      &lt;td&gt;0.92&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;239&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12322&lt;/th&gt;
      &lt;td&gt;0.61&lt;/td&gt;
      &lt;td&gt;0.47&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;253&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;0.11&lt;/td&gt;
      &lt;td&gt;0.88&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;272&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;587&lt;/th&gt;
      &lt;td&gt;0.80&lt;/td&gt;
      &lt;td&gt;0.83&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;211&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;32-决策树&#34;&gt;3.2 决策树&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# decision tree
clf = tree.DecisionTreeClassifier(
    criterion = &#39;gini&#39;,   # entropy_熵 也就是id3
    max_depth = 5,   # 树的深度限制
    min_weight_fraction_leaf = 0.005  # 叶子节点最少包含样本量
)
clf = clf.fit(X_train, y_train)     # 训练
clf.score(X_train, y_train)       # 拟合
y_pred_clf = clf.predict(X_test)    # 预测
accuracy_score(y_pred_clf, y_test)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0.9674139511625969

0.9646666666666667
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 可视化：
from sklearn.externals.six import StringIO
from sklearn.tree import export_graphviz
import pydotplus 
from IPython.display import Image

dot_data = StringIO()
export_graphviz(clf, out_file = dot_data,  
                filled = True, rounded = True,
                special_characters = True,
                feature_names = feature_names,
                class_names = [&#39;0&#39;,&#39;1&#39;])
graph = pydotplus.graph_from_dot_data(dot_data.getvalue())    # 生成graph
Image(graph.create_png())     # 显示图片
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1604027997331.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;33-rf&#34;&gt;3.3 rf&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# decision tree
rf = RandomForestClassifier(
    criterion=&#39;gini&#39;,
    n_estimators = 10,     # 一共建立10颗树
    max_depth = None,      
    min_samples_split = 5, 
)

rf = rf.fit(X_train, y_train)     # 训练
rf.score(X_train, y_train)       # 拟合
y_pred_rf = rf.predict(X_test)    # 预测
accuracy_score(y_pred_rf, y_test)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0.9947495624635386

0.9866666666666667
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;34-对比决策树和随机森林&#34;&gt;3.4 对比决策树和随机森林&lt;/h2&gt;
&lt;h3 id=&#34;变量重要性方面&#34;&gt;变量重要性方面&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# importances 按照分割前后熵/gini_index的减少量算的
importances = pd.DataFrame({&amp;quot;feature&amp;quot;: feature_names,  &amp;quot;rf_importances&amp;quot;: rf.feature_importances_, &amp;quot;tree_importances&amp;quot;: clf.feature_importances_})
importances

plt.figure(figsize = (12, 6))
plt.title(&amp;quot;Feature importances by RandomForest&amp;quot;)
plt.bar(range(len(importances)), importances[&#39;rf_importances&#39;], color=&#39;lightblue&#39;,  align=&amp;quot;center&amp;quot;)
plt.step(range(len(importances)), np.cumsum(importances[&#39;rf_importances&#39;]), where=&#39;mid&#39;, label=&#39;Cumulative&#39;)
plt.xticks(range(len(importances)), feature_names, rotation=&#39;vertical&#39;, fontsize=14)
plt.xlim([-1, len(importances)])
plt.show()

plt.figure(figsize = (12, 6))
plt.title(&amp;quot;Feature importances by RandomForest&amp;quot;)
plt.bar(range(len(importances)), importances[&#39;tree_importances&#39;], color=&#39;lightblue&#39;,  align=&amp;quot;center&amp;quot;)
plt.step(range(len(importances)), np.cumsum(importances[&#39;tree_importances&#39;]), where=&#39;mid&#39;, label=&#39;Cumulative&#39;)
plt.xticks(range(len(importances)), feature_names, rotation=&#39;vertical&#39;, fontsize=14)
plt.xlim([-1, len(importances)])
plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;feature&lt;/th&gt;
      &lt;th&gt;rf_importances&lt;/th&gt;
      &lt;th&gt;tree_importances&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;satisfaction_level&lt;/td&gt;
      &lt;td&gt;0.343161&lt;/td&gt;
      &lt;td&gt;0.563355&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;last_evaluation&lt;/td&gt;
      &lt;td&gt;0.145291&lt;/td&gt;
      &lt;td&gt;0.141229&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;number_project&lt;/td&gt;
      &lt;td&gt;0.173969&lt;/td&gt;
      &lt;td&gt;0.101539&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;average_montly_hours&lt;/td&gt;
      &lt;td&gt;0.136404&lt;/td&gt;
      &lt;td&gt;0.054792&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;time_spend_company&lt;/td&gt;
      &lt;td&gt;0.176457&lt;/td&gt;
      &lt;td&gt;0.138497&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;Work_accident&lt;/td&gt;
      &lt;td&gt;0.008887&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;td&gt;promotion_last_5years&lt;/td&gt;
      &lt;td&gt;0.000986&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;department&lt;/td&gt;
      &lt;td&gt;0.009074&lt;/td&gt;
      &lt;td&gt;0.000589&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;8&lt;/th&gt;
      &lt;td&gt;salary&lt;/td&gt;
      &lt;td&gt;0.005771&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1604027966064.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1604027971812.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;可以看出，随机森林特征重要性相对比较均匀&lt;/p&gt;
&lt;p&gt;是由于每次分割遍历的特征集合是个 random choose 的特征子集，给了一些原本不太重要的属性more chance作为分割属性。&lt;/p&gt;
&lt;h3 id=&#34;roc&#34;&gt;roc&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sklearn.metrics import roc_curve
rf_fpr, rf_tpr, rf_thresholds = roc_curve(y_test, rf.predict_proba(X_test)[:,1])
dt_fpr, dt_tpr, dt_thresholds = roc_curve(y_test, clf.predict_proba(X_test)[:,1])

plt.figure()
plt.plot(rf_fpr, rf_tpr, label=&#39;Random Forest&#39;)
plt.plot(dt_fpr, dt_tpr, label=&#39;Decision Tree&#39;)
plt.title(&#39;ROC Graph&#39;)
plt.legend(loc=&amp;quot;lower right&amp;quot;)
plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1604027983283.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">sklearn | 决策树 & 随机森林</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/mysql1/"" data-c="
          &lt;p&gt;参考资料：&lt;a href=&#34;https://www.bilibili.com/video/BV1UE41147KC?p=5&#34;&gt;中字 | mysql教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;sql学习大致计划，使用mysql&lt;br&gt;
开始时间：2020.10.29&lt;br&gt;
结束时间：未完成&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/sql-1029/&#34;&gt;在单一表格中select | 2020.10.29&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/sql-1030-lian-jie/&#34;&gt;内外连接等 join | 2020.10.30&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/sql-1102-insert-update-delete/&#34;&gt;插入更新和删除数据 | 2020.11.02&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/sql-1102-insert-update-delete/&#34;&gt;汇总数据 | 2020.11.02&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/sql-zi-cha-xun/&#34;&gt;复杂子查询 | 2020.11.03&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/sql-han-shu-tiao-jian-yu-ju-shi-tu&#34;&gt;基本函数 | 2020.11.04&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/sql-han-shu-tiao-jian-yu-ju-shi-tu&#34;&gt;视图 | 2020.11.04&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;存储过程&lt;/li&gt;
&lt;li&gt;触发器&lt;/li&gt;
&lt;li&gt;事务和并发&lt;/li&gt;
&lt;li&gt;数据类型&lt;/li&gt;
&lt;li&gt;数据库设计&lt;/li&gt;
&lt;li&gt;索引&lt;/li&gt;
&lt;li&gt;用户与权限&lt;/li&gt;
&lt;/ol&gt;
">【系列】SQL</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/sql-1029/"" data-c="
          &lt;h1 id=&#34;select&#34;&gt;select&lt;/h1&gt;
&lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#select&#34;&gt;select&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-where&#34;&gt;2.1 where&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-order-by&#34;&gt;2.2 ORDER BY&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#23&#34;&gt;2.3 &amp;lt;=&amp;gt;!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#24-and-or-not-in-between&#34;&gt;2.4 and or not in between&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#27-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-like&#34;&gt;2.7 正则表达式匹配 like&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#28-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-regexp-%E5%8C%85%E5%90%AB%E6%9F%90%E4%B8%AA%E5%AD%97%E7%AC%A6%E5%8D%95%E8%AF%8D&#34;&gt;2.8 正则表达式匹配  regexp 包含某个字符/单词/..&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#29-%E7%A9%BA%E5%80%BC-is-null&#34;&gt;2.9 空值 IS NULL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#210-order-by-%E9%BB%98%E8%AE%A4%E5%8D%87%E5%BA%8F%E5%8A%A0%E4%B8%8Adesc%E5%B0%B1%E6%98%AF%E9%99%8D%E5%BA%8F&#34;&gt;2.10 order by （默认升序，加上desc就是降序）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#211-limit%E8%BF%94%E5%9B%9E%E5%89%8D%E5%87%A0%E6%9D%A1&#34;&gt;2.11 limit，返回前几条&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;USE sql_store;
/*
多行运行（所有结果都ouput）command + shift + enter
*/
-- SELECT * FROM sql_store.orders;     # 取出sql_store下面的orders这个表
SELECT * FROM sql_store.customers;     # 取出sql_store下面的customers这个表
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;/*&lt;br&gt;
第二章：SELECT&lt;br&gt;
*/&lt;/p&gt;
&lt;h2 id=&#34;21-where&#34;&gt;2.1 where&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;SELECT first_name, last_name  # 指定列
FROM customers
WHERE points &amp;gt; 2000;    # 条件查询，遍历逐个对比，然后返回
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22-order-by&#34;&gt;2.2 ORDER BY&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;SELECT *
FROM customers
-- WHERE state = &amp;quot;MA&amp;quot;    # where 要在 order by 前面
ORDER BY first_name;    # 按照first name 排序


SELECT
	last_name, 
    first_name, 
    points, 
    points * 1.1 + 100 AS &#39;new points&#39;,
    points % 10 AS &#39;整除&#39;
FROM customers
ORDER BY points;


SELECT DISTINCT state     # np.unique
FROM customers;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;23&#34;&gt;2.3 &amp;lt;=&amp;gt;!&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;SELECT *
FROM customers
WHERE state !=&#39;va&#39;;        # 字符大小写相同


SELECT *
FROM customers
WHERE birth_date &amp;lt; &#39;1980-01-01&#39;;   # 日期也是可以对比大小的
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;24-and-or-not-in-between&#34;&gt;2.4 and or not in between&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;SELECT *
FROM customers
-- WHERE birth_date &amp;gt; &#39;1990-01-01&#39; and points &amp;gt; 1000;
-- WHERE birth_date &amp;gt; &#39;1990-01-01&#39; or points &amp;gt; 1000;
-- WHERE NOT (birth_date &amp;gt; &#39;1990-01-01&#39; OR points &amp;gt; 1000);
WHERE (birth_date &amp;gt; &#39;1990-01-01&#39; OR points &amp;gt; 1000) AND
 	state = &#39;VA&#39;;
  
  
SELECT *, unit_price * quantity AS totle_price
FROM order_items
WHERE order_id = 6 AND unit_price * quantity &amp;gt;30;


SELECT *
FROM customers
-- WHERE customer_id IN (1,4,7);
-- WHERE state IN (&#39;va&#39;,&#39;fl&#39;,&#39;ga&#39;);   
WHERE state NOT IN (&#39;va&#39;,&#39;fl&#39;,&#39;ga&#39;);

SELECT *
FROM customers
-- WHERE points BETWEEN 2000 AND 3000
WHERE birth_date BETWEEN &amp;quot;1990-01-01&amp;quot; and &amp;quot;1999-12-31&amp;quot; ;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;27-正则表达式匹配-like&#34;&gt;2.7 正则表达式匹配 like&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;SELECT *
FROM customers
-- WHERE last_name LIKE &#39;b%&#39;;  # 正则表达式：b开头
-- WHERE last_name LIKE &#39;%o%&#39;;  # 正则表达式：包含o
-- WHERE last_name LIKE &#39;%y&#39;;  # 正则表达式：包含o
-- WHERE last_name LIKE &#39;b____y&#39;;  # 正则表达式：b+4个字母+y
WHERE last_name LIKE &#39;b%y&#39;;  # 正则表达式：b+字母+y

SELECT * 
FROM customers
WHERE phone LIKE &amp;quot;%9%&amp;quot; AND
	address LIKE &#39;%trail%&#39; OR &#39;%avenue%&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;28-正则表达式匹配-regexp-包含某个字符单词&#34;&gt;2.8 正则表达式匹配  regexp 包含某个字符/单词/..&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;SELECT * 
FROM customers
-- WHERE last_name REGEXP &#39;field|MAC|rose&#39;;   # 匹配包含
-- WHERE last_name REGEXP &#39;^field|MAC|rose&#39;;   # 匹配开头
-- WHERE last_name REGEXP &#39;[gim]e&#39;;     # 匹配包含ge/ie/me
WHERE last_name REGEXP &#39;[a-h]e&#39;;    # 匹配包含“a-h的单词+e”
/*
基本规则：
^ beginning
$ end
| or
[] any characters in []
[-] range
*/
小练习
SELECT * 
FROM customers
-- WHERE first_name IN (&#39;elka&#39;,&#39;ambur&#39;);
-- WHERE last_name REGEXP &#39;^my|se&#39;;
WHERE last_name REGEXP &#39;b[ru]&#39;;   # 包含br or bu
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;29-空值-is-null&#34;&gt;2.9 空值 IS NULL&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select * from customers
-- where phone is not null;
where phone is null;

select * from orders
where (shipped_date is null) or (comments is null);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;210-order-by-默认升序加上desc就是降序&#34;&gt;2.10 order by （默认升序，加上desc就是降序）&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;mysql 独有的：orderby可以用表中任意列，无论列是否在select中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select customer_id,first_name,state,10 from customers
-- order by first_name;
-- order by birth_date desc;
order by state desc, first_name;   #首先按state降序排，再按firstname升序排

### 更复杂的情况，可以用列的运算来排序：
select * from order_items
where order_id = 2
order by (quantity * unit_price) desc;  # 用单位价格*销量来排序
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;211-limit返回前几条&#34;&gt;2.11 limit，返回前几条&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-{sql}&#34;&gt;select * from customers
limit 6,3 ;  # 跳过前6条，选择3条

select *, quantity * unit_price as total_price 
from order_items
order by (quantity * unit_price) desc
limit 5;  # 选取总额最高的三个
&lt;/code&gt;&lt;/pre&gt;
">sql 1029 select</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/java/"" data-c="
          &lt;p&gt;所有的code放在project里，基础知识就用这个记录吧~&lt;/p&gt;
&lt;h1 id=&#34;java基础知识20201029&#34;&gt;java基础知识（20201029）&lt;/h1&gt;
&lt;p&gt;package practice1029;&lt;/p&gt;
&lt;h2 id=&#34;一-数据类型&#34;&gt;一、数据类型：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;整数&lt;br&gt;
Byte 基本存储单位 =8bit（8位数字） Short Integer Long&lt;/li&gt;
&lt;li&gt;浮点数（科学计数法）&lt;br&gt;
Float Double&lt;/li&gt;
&lt;li&gt;布尔值&lt;br&gt;
boolean（默认false)&lt;/li&gt;
&lt;li&gt;字符&lt;br&gt;
char（默认0）字母、数字、汉字、符号都算，注意用单引号表示&lt;/li&gt;
&lt;li&gt;字符串&lt;br&gt;
String（默认null）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二-数据类型转化&#34;&gt;二、数据类型转化&lt;/h2&gt;
&lt;p&gt;整型、常量、字符型数据可以混合运算&lt;br&gt;
强制类型转化：&lt;br&gt;
(int)23.7 == 23;&lt;br&gt;
(byte)123;&lt;br&gt;
自动类型转换：&lt;br&gt;
int-&amp;gt;float；char-&amp;gt;int；注意boolean不能转换&lt;br&gt;
char c1=&#39;a&#39;;&lt;br&gt;
int i1 = c1;&lt;/p&gt;
&lt;p&gt;三、变量类型&lt;br&gt;
变量在使用前必须声明（名字不能重复）&lt;br&gt;
e.g.数据类型 变量名 = 值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类变量：独立于方法之外的变量，用 static 修饰&lt;/li&gt;
&lt;li&gt;实例变量：独立于方法之外的变量，不过没有 static 修饰。&lt;/li&gt;
&lt;li&gt;局部变量：类的方法中的变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四-运算符&#34;&gt;四、运算符&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;/ % ++ -- ——运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;amp;&amp;amp; ||  ! ——逻辑运算符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;?:  —— 条件运算符&lt;br&gt;
e.g.variable x = (expression) ? value if true : value if false&lt;br&gt;
e.g.b = ( a==1 ) ? 20 : 30  如果a=1取20否则取30&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;instanceof —— 检查对象的数据类型/class&lt;br&gt;
e.g.( Object reference variable ) instanceof  (class/interface type)&lt;br&gt;
e.g.var1 instanceof String  var1是不是字符串&lt;br&gt;
e.g.a instanceof class1 a是不是class1类的实例&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;五-循环&#34;&gt;五、循环&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;while&lt;br&gt;
while(条件){&lt;br&gt;
//代码语句;&lt;br&gt;
}&lt;/li&gt;
&lt;li&gt;do while&lt;br&gt;
do{&lt;br&gt;
//代码语句;&lt;br&gt;
}while(条件);&lt;br&gt;
do while 和 while 的差别：do while 至少会执行一次&lt;/li&gt;
&lt;li&gt;for&lt;br&gt;
for(初始化; 布尔表达式; 更新) {&lt;br&gt;
//代码语句&lt;br&gt;
}&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;六-条件语句&#34;&gt;六、条件语句&lt;/h2&gt;
&lt;p&gt;（?:  —— 条件运算符）&lt;br&gt;
if...else...&lt;/p&gt;
">Java</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/b-zhan-s10-shi-pin-dan-mu-fen-xi/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%E7%88%AC%E5%8F%96%E5%BC%B9%E5%B9%95&#34;&gt;第一部分：爬取弹幕&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E7%88%AC%E5%8F%96%E5%85%B3%E4%BA%8Es10%E7%9A%84%E8%A7%86%E9%A2%91%E6%A0%87%E9%A2%98%E5%92%8C%E9%93%BE%E6%8E%A5&#34;&gt;1.爬取关于s10的视频标题和链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E8%8E%B7%E5%8F%96%E5%BC%B9%E5%B9%95%E5%9C%B0%E5%9D%80&#34;&gt;2.获取弹幕地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E7%88%AC%E5%8F%96%E5%BC%B9%E5%B9%95%E5%86%85%E5%AE%B9&#34;&gt;3.爬取弹幕内容&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E6%8F%8F%E8%BF%B0%E5%88%86%E6%9E%90&#34;&gt;第二部分 描述分析&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E8%AF%8D&#34;&gt;分词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%98%E5%88%B6%E8%AF%8D%E4%BA%91%E5%9B%BE&#34;&gt;绘制词云图&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%BA%E5%90%8D%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0&#34;&gt;人名出现次数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%98%9F%E4%BC%8D%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0&#34;&gt;队伍出现次数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90&#34;&gt;情感分析&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E8%AE%A1%E7%AE%97%E6%AF%8F%E4%B8%80%E5%8F%A5%E5%BC%B9%E5%B9%95%E7%9A%84%E6%83%85%E6%84%9F%E5%88%86%E6%95%B0&#34;&gt;1. 计算每一句弹幕的情感分数：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E7%BB%9F%E8%AE%A1%E6%AF%8F%E4%B8%80%E5%8F%A5%E5%BC%B9%E5%B9%95%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E9%98%9F%E4%BC%8D%E5%90%8D%E7%A7%B0&#34;&gt;2. 统计每一句弹幕是否包含队伍名称：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E7%BB%98%E5%88%B6%E7%AE%B1%E7%BA%BF%E5%9B%BE%E5%AF%B9%E6%AF%94%E5%9B%9B%E6%94%AF%E9%98%9F%E4%BC%8D%E7%9A%84%E6%83%85%E6%84%9F%E5%BE%97%E5%88%86&#34;&gt;3. 绘制箱线图对比四支队伍的情感得分&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;第一部分爬取弹幕&#34;&gt;第一部分：爬取弹幕&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;b站搜索“s10”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;https://search.bilibili.com/all?keyword=s10&amp;amp;from_source=nav_suggest_new&amp;amp;order=totalrank&amp;amp;duration=0&amp;amp;tids_1=4&amp;amp;page=1&lt;/p&gt;
&lt;p&gt;改变page= 就可以翻页，从而爬取每个视频的title和网址&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;b站弹幕文件以 XML 文档式存储&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对每一个视频：比如【总决赛抽签】:https://www.bilibili.com/video/BV1Ci4y1j7Gs&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以根据cid找到id——比如&amp;quot;cid&amp;quot;:244696952&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从而找到弹幕：&lt;br&gt;
http://comment.bilibili.com/244696952.xml&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;爬取弹幕并提取&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1爬取关于s10的视频标题和链接&#34;&gt;1.爬取关于s10的视频标题和链接&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import requests        #导入requests包
from lxml import etree   # xpath
from bs4 import BeautifulSoup as BS

headers={&#39;user-agent&#39;:&#39;Opera/12.80 (Windows NT 5.1; U; en) Presto/2.10.289 Version/12.02&#39;}

urls = []
titles = []
for num in range(1, 11):
    url1 = &amp;quot;https://search.bilibili.com/all?keyword=s10&amp;amp;from_source=nav_suggest_new&amp;amp;order=totalrank&amp;amp;duration=0&amp;amp;tids_1=4&amp;amp;page=&amp;quot;+str(num)
    r = requests.get(url1, headers = headers) #获取数据
    html = etree.HTML(r.text)  # 处理为xpath可以操作的格式
    li_tmp = html.xpath(&amp;quot;//ul[@class=&#39;video-list clearfix&#39;]/li&amp;quot;)   # 得到所有li
    for li in li_tmp:
        urls.append((&amp;quot;http:&amp;quot;+li.xpath(&amp;quot;./a/@href&amp;quot;)[0]))   # 提取视频网址
        titles.append(li.xpath(&amp;quot;./a/@title&amp;quot;)[0])  # 提取标题
          
len(titles)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;200
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2获取弹幕地址&#34;&gt;2.获取弹幕地址&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import re
# 根据网址找到视频的弹幕地址
danmu = []
i = 0
for urli in urls:
    i += 1 
    if i % 20==0: print(i)
    r = requests.get(urli, headers = headers) #获取数据
    pattern =&#39;&amp;quot;cid&amp;quot;:(\d+)&#39;
    cid = re.findall(pattern, r.text)
    if cid == []:
        danmu.append(None)
    else:
        danmu.append(&amp;quot;http://comment.bilibili.com/&amp;quot; + str(cid[0]) + &amp;quot;.xml&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;20
40
60
80
100
120
140
160
180
200
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 查看概况
import pandas as pd
data_raw = pd.DataFrame({&#39;视频标题&#39;:titles, &#39;网址&#39;:urls,&#39;弹幕地址&#39;:danmu})
data_raw.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;视频标题&lt;/th&gt;
      &lt;th&gt;网址&lt;/th&gt;
      &lt;th&gt;弹幕地址&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;《S10四分之一女装决赛》&lt;/td&gt;
      &lt;td&gt;http://www.bilibili.com/video/BV1cf4y1z73L?fro...&lt;/td&gt;
      &lt;td&gt;http://comment.bilibili.com/249115320.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;S10采访有多难？余霜说前期准备都得双语份！【魔都电竞人】EP17&lt;/td&gt;
      &lt;td&gt;http://www.bilibili.com/video/BV1Nr4y1w74z?fro...&lt;/td&gt;
      &lt;td&gt;http://comment.bilibili.com/248319821.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;【S10】2020LOL全球总决赛BGM 歌单合集（收录中）&lt;/td&gt;
      &lt;td&gt;http://www.bilibili.com/video/BV1bf4y1D7ea?fro...&lt;/td&gt;
      &lt;td&gt;http://comment.bilibili.com/240498380.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;S10半决赛SN:TES  二路解说 （米勒娃娃）&lt;/td&gt;
      &lt;td&gt;http://www.bilibili.com/video/BV1XZ4y1G754?fro...&lt;/td&gt;
      &lt;td&gt;http://comment.bilibili.com/249474964.xml&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;【英雄联盟】S10主题曲《所向无前》MV时间线重剪版&lt;/td&gt;
      &lt;td&gt;http://www.bilibili.com/video/BV1ci4y1E7sx?fro...&lt;/td&gt;
      &lt;td&gt;http://comment.bilibili.com/237519965.xml&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
os.chdir(&amp;quot;/Users/mac/Desktop/快乐研一/python/data/s10视频弹幕&amp;quot;)
data_raw.to_csv(&amp;quot;data_raw.csv&amp;quot;, index_label = &amp;quot;index_label&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3爬取弹幕内容&#34;&gt;3.爬取弹幕内容&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from bs4 import BeautifulSoup as BS

r = requests.get(danmu[0], headers = headers) 
r.encoding = &#39;utf-8&#39;
soup = BS(r.text,&#39;lxml&#39;)
all_d = soup.find_all(&#39;d&#39;)
all_d[:10]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&amp;lt;d p=&amp;quot;79.48700,4,25,16777215,1603804760,0,9a617a42,40193273772900355&amp;quot;&amp;gt;怎么感觉在憋笑&amp;lt;/d&amp;gt;,
 &amp;lt;d p=&amp;quot;54.45200,1,25,16777215,1603804757,0,e4f81dba,40193271883890693&amp;quot;&amp;gt;欧成也太行啦&amp;lt;/d&amp;gt;,
 &amp;lt;d p=&amp;quot;14.95900,1,25,16777215,1603804266,0,e23a3f97,40193014642507781&amp;quot;&amp;gt;？？？。&amp;lt;/d&amp;gt;,
 &amp;lt;d p=&amp;quot;40.74000,1,25,16777215,1603803807,0,2b973602,40192773830737927&amp;quot;&amp;gt;哈哈哈&amp;lt;/d&amp;gt;,
 &amp;lt;d p=&amp;quot;27.46000,1,25,16777215,1603803789,0,2b973602,40192764451225603&amp;quot;&amp;gt;爱了爱了&amp;lt;/d&amp;gt;,
 &amp;lt;d p=&amp;quot;14.70000,1,25,16777215,1603803768,0,2b973602,40192753333698565&amp;quot;&amp;gt;冲冲冲&amp;lt;/d&amp;gt;,
 &amp;lt;d p=&amp;quot;8.54000,1,25,16777215,1603802300,0,2c556204,40191984122986501&amp;quot;&amp;gt;咖哥太美了吧&amp;lt;/d&amp;gt;,
 &amp;lt;d p=&amp;quot;9.85900,1,25,16777215,1603802164,0,2c556204,40191912440758275&amp;quot;&amp;gt;咖哥绝没&amp;lt;/d&amp;gt;,
 &amp;lt;d p=&amp;quot;64.51200,1,25,16777215,1603802021,0,20a366fa,40191837825138693&amp;quot;&amp;gt;裂开&amp;lt;/d&amp;gt;,
 &amp;lt;d p=&amp;quot;45.40700,1,25,16777215,1603802002,0,20a366fa,40191827817005063&amp;quot;&amp;gt;草&amp;lt;/d&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 写入文件夹
count = 1
for url_danmu in danmu:
    r = requests.get(url_danmu,  headers = headers)
    r.encoding = &#39;utf-8&#39;
    soup = BS(r.text, &#39;lxml&#39;)
    all_d = soup.find_all(&#39;d&#39;)
    with open(&#39;{}.txt&#39;.format(count), &#39;w&#39;, encoding=&#39;utf-8&#39;) as f:
        for d in all_d:
            f.write(d.get_text()+&#39;\n&#39;)
    if count%30 == 1: 
        print(&#39;第{}个视频弹幕写入完毕&#39;.format(count))
    count += 1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;第1个视频弹幕写入完毕
第31个视频弹幕写入完毕
第61个视频弹幕写入完毕
第91个视频弹幕写入完毕
第121个视频弹幕写入完毕
第151个视频弹幕写入完毕
第181个视频弹幕写入完毕
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第二部分-描述分析&#34;&gt;第二部分 描述分析&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;jieba 分词&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;粗略学了一遍数据结构似乎理解这句话了：&lt;/p&gt;
&lt;p&gt;基于前缀词典实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图 (DAG)&lt;/p&gt;
&lt;p&gt;采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import jieba
import os
import pandas as pd

os.chdir(&amp;quot;/Users/mac/Desktop/快乐研一/python/data/s10视频弹幕&amp;quot;)
jieba.load_userdict(&#39;人物.txt&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;分词&#34;&gt;分词&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 对所有文章的弹幕进行分词合并
words = []
punctuation = &#39;!！,;:?？&amp;quot;\&#39;、，；\n…。 #$&amp;amp;()\+\-\%\*\./￥&#39;

# 1.对于所有的200个视频：
for n in range(1,201):  # 对于所有的200个视频：
    lines_n = open(str(n)+&amp;quot;.txt&amp;quot;,&amp;quot;r&amp;quot;,encoding = &amp;quot;utf-8&amp;quot;).readlines()   # 读入 
    # 2. 对一个视频的所有弹幕：
    for i in range(len(lines_n)):  
        # 删除标点符号
        line = re.sub(r&#39;[{}]+&#39;.format(punctuation),&#39;&#39;,lines_n[i])
        # 结巴分词
        poss = jieba.cut(line)
        words += [j for j in poss]

len(words)
words[:20]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;500919






[&#39;怎么&#39;,
 &#39;感觉&#39;,
 &#39;在&#39;,
 &#39;憋&#39;,
 &#39;笑&#39;,
 &#39;欧成&#39;,
 &#39;也&#39;,
 &#39;太行&#39;,
 &#39;啦&#39;,
 &#39;哈哈哈&#39;,
 &#39;爱&#39;,
 &#39;了&#39;,
 &#39;爱&#39;,
 &#39;了&#39;,
 &#39;冲冲&#39;,
 &#39;冲&#39;,
 &#39;咖哥&#39;,
 &#39;太美&#39;,
 &#39;了&#39;,
 &#39;吧&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;绘制词云图&#34;&gt;绘制词云图&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#导入WordCloud和matplotlib包
from wordcloud import WordCloud
import matplotlib.pyplot as plt

# 在jupyter 里显示图片
import numpy as np
%matplotlib inline

# 生成一个matplot对象，传入一个字体位置的路径和背景颜色即可
wordcloud = WordCloud(
        font_path=&#39;/Users/mac/Library/Fonts/字体管家方萌简（非商业使用）v1.1.ttf&#39;,
        background_color=&#39;white&#39;,
        width=1800,
        height=1500,
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;人名出现次数&#34;&gt;人名出现次数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;roles = [ i.replace(&#39;\n&#39;,&#39;&#39;).split(&amp;quot;|&amp;quot;) for i in open(&#39;人物.txt&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;).readlines()]
d_role = dict()
for role in roles:
    times = 0
    for name in role:
        if name in words:
            times += words.count(name)
    d_role[role[0]] = times
#d_role
pd.DataFrame({&amp;quot;人名&amp;quot;:list(d_role.keys()), &amp;quot;次数&amp;quot;:list(d_role.values())}).sort_values(by=&#39;次数&#39;, ascending=False).head()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;人名&lt;/th&gt;
      &lt;th&gt;次数&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;9&lt;/th&gt;
      &lt;td&gt;Jackeylove&lt;/td&gt;
      &lt;td&gt;851&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;10&lt;/th&gt;
      &lt;td&gt;369&lt;/td&gt;
      &lt;td&gt;614&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12&lt;/th&gt;
      &lt;td&gt;Knight&lt;/td&gt;
      &lt;td&gt;547&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;11&lt;/th&gt;
      &lt;td&gt;Karsa&lt;/td&gt;
      &lt;td&gt;515&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;Caps&lt;/td&gt;
      &lt;td&gt;377&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(9,9))   # 创建画布
wordcloud.fit_words(d_role)
plt.imshow(wordcloud)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603847510914.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;队伍出现次数&#34;&gt;队伍出现次数&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;teams = [ i.replace(&#39;\n&#39;,&#39;&#39;).split(&amp;quot;|&amp;quot;) for i in open(&#39;队伍.txt&#39;,&#39;r&#39;,encoding=&#39;utf-8&#39;).readlines()]
d_team = dict()
for team in teams:
    times = 0
    for name in team:
        if name in words:
            times += words.count(name)
    d_team[team[0]] = times
#d_team
pd.DataFrame({&amp;quot;队伍&amp;quot;:list(d_team.keys()), &amp;quot;次数&amp;quot;:list(d_team.values())}).sort_values(by=&#39;次数&#39;, ascending=False).head()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;队伍&lt;/th&gt;
      &lt;th&gt;次数&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;IG&lt;/td&gt;
      &lt;td&gt;1931&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;G2&lt;/td&gt;
      &lt;td&gt;1872&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;TES&lt;/td&gt;
      &lt;td&gt;1638&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;SN&lt;/td&gt;
      &lt;td&gt;1206&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;8&lt;/th&gt;
      &lt;td&gt;DRX&lt;/td&gt;
      &lt;td&gt;803&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(9,9))   # 创建画布
wordcloud.fit_words(d_team)
plt.imshow(wordcloud)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603847486973.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;情感分析&#34;&gt;情感分析&lt;/h2&gt;
&lt;p&gt;snownlp 这个模块可以对每个单词得出情感得分。&lt;/p&gt;
&lt;p&gt;训练数据主要是买卖东西时的评价，所以&lt;strong&gt;效果不好，暂且用它思考使用方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有点慢，就随便挑了几期视频&lt;/p&gt;
&lt;h3 id=&#34;1-计算每一句弹幕的情感分数&#34;&gt;1. 计算每一句弹幕的情感分数：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from snownlp import SnowNLP

scores = []
sentences = []
punctuation = &#39;!！,;:?？&amp;quot;\&#39;、，；\n…。 #$&amp;amp;()\+\-\%\*\./￥&#39;
# 1.对于所有的200个视频：
for n in range(100,130):  # 对于所有的200个视频：
    lines_n = open(str(n)+&amp;quot;.txt&amp;quot;,&amp;quot;r&amp;quot;,encoding = &amp;quot;utf-8&amp;quot;).readlines()   # 读入 
    # 2. 对一个视频的所有弹幕：
    for i in range(len(lines_n)):  
        line = re.sub(r&#39;[{}]+&#39;.format(punctuation),&#39;&#39;,lines_n[i])
        if len(list(line))==0:
            scores.append(None)
        else:
            scores.append(SnowNLP(line).sentiments)
        sentences.append(line)
    if n%5 == 1:
        print(&amp;quot;处理完第{}个视频&amp;quot;.format(n))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;处理完第101个视频
处理完第106个视频
处理完第111个视频
处理完第116个视频
处理完第121个视频
处理完第126个视频
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Sentiment_df = pd.DataFrame({&amp;quot;句子&amp;quot;:sentences,&amp;quot;情感&amp;quot;:scores})
Sentiment_df.iloc[6040:6060,:]
Sentiment_df.shape
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;句子&lt;/th&gt;
      &lt;th&gt;情感&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;6040&lt;/th&gt;
      &lt;td&gt;牙膏这里是不是想跟鳄鱼一块包夹的&lt;/td&gt;
      &lt;td&gt;0.649372&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6041&lt;/th&gt;
      &lt;td&gt;仔细看首富卡视野和烬的平a细啊&lt;/td&gt;
      &lt;td&gt;0.971794&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6042&lt;/th&gt;
      &lt;td&gt;富富富&lt;/td&gt;
      &lt;td&gt;0.553155&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6043&lt;/th&gt;
      &lt;td&gt;熬到8点&lt;/td&gt;
      &lt;td&gt;0.300529&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6044&lt;/th&gt;
      &lt;td&gt;有g2内鬼&lt;/td&gt;
      &lt;td&gt;0.522977&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6045&lt;/th&gt;
      &lt;td&gt;这波huanfeng真的顶太吓人了&lt;/td&gt;
      &lt;td&gt;0.306918&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6048&lt;/th&gt;
      &lt;td&gt;sofm太猛了&lt;/td&gt;
      &lt;td&gt;0.729795&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6049&lt;/th&gt;
      &lt;td&gt;京东plus会员还续费吗&lt;/td&gt;
      &lt;td&gt;0.389347&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6050&lt;/th&gt;
      &lt;td&gt;年轻人不讲武德啊&lt;/td&gt;
      &lt;td&gt;0.915804&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6051&lt;/th&gt;
      &lt;td&gt;这波硬头皮打大龙就3：0了&lt;/td&gt;
      &lt;td&gt;0.831243&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6052&lt;/th&gt;
      &lt;td&gt;男枪一套秒了女枪&lt;/td&gt;
      &lt;td&gt;0.748254&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6053&lt;/th&gt;
      &lt;td&gt;g2下半区打韩国抗韩奇兵亮一下咋了&lt;/td&gt;
      &lt;td&gt;0.093364&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6054&lt;/th&gt;
      &lt;td&gt;必须比莎比亚好&lt;/td&gt;
      &lt;td&gt;0.631785&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6055&lt;/th&gt;
      &lt;td&gt;焕峰的烬太强了&lt;/td&gt;
      &lt;td&gt;0.822812&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6056&lt;/th&gt;
      &lt;td&gt;zoom拦个女的直接开始折磨&lt;/td&gt;
      &lt;td&gt;0.235975&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6057&lt;/th&gt;
      &lt;td&gt;公爵难受啊&lt;/td&gt;
      &lt;td&gt;0.415783&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;(9052, 2)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-统计每一句弹幕是否包含队伍名称&#34;&gt;2. 统计每一句弹幕是否包含队伍名称：&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;include_g2 = []
include_tes = []
include_sn = []
include_dwg = []
for sentence in sentences:
    tmp = False
    for team in teams[2]:
        if team in sentence:
            tmp = True
    include_g2.append(tmp)
    tmp = False
    for team in teams[3]:
        if team in sentence:
            tmp = True
    include_tes.append(tmp)
    tmp = False
    for team in teams[5]:
        if team in sentence:
            tmp = True
    include_sn.append(tmp)
    tmp = False
    for team in teams[7]:
        if team in sentence:
            tmp = True
    include_dwg.append(tmp)

Sentiment_df[&#39;G2&#39;] = include_g2
Sentiment_df[&#39;TES&#39;] = include_tes
Sentiment_df[&#39;SN&#39;] = include_sn
Sentiment_df[&#39;DWG&#39;] = include_dwg
Sentiment_df.iloc[100:110,:]
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;句子&lt;/th&gt;
      &lt;th&gt;情感&lt;/th&gt;
      &lt;th&gt;G2&lt;/th&gt;
      &lt;th&gt;TES&lt;/th&gt;
      &lt;th&gt;SN&lt;/th&gt;
      &lt;th&gt;DWG&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;100&lt;/th&gt;
      &lt;td&gt;胖了&lt;/td&gt;
      &lt;td&gt;0.384615&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;101&lt;/th&gt;
      &lt;td&gt;哈哈哈哈哈哈&lt;/td&gt;
      &lt;td&gt;0.975135&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;102&lt;/th&gt;
      &lt;td&gt;呸&lt;/td&gt;
      &lt;td&gt;0.526233&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;103&lt;/th&gt;
      &lt;td&gt;TES输了&lt;/td&gt;
      &lt;td&gt;0.807744&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;104&lt;/th&gt;
      &lt;td&gt;胖了&lt;/td&gt;
      &lt;td&gt;0.384615&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;105&lt;/th&gt;
      &lt;td&gt;胖的跟个鬼一样&lt;/td&gt;
      &lt;td&gt;0.198050&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;106&lt;/th&gt;
      &lt;td&gt;之前都是异地登录打野账号&lt;/td&gt;
      &lt;td&gt;0.894432&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;107&lt;/th&gt;
      &lt;td&gt;三语翻译厉害呀&lt;/td&gt;
      &lt;td&gt;0.471007&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;108&lt;/th&gt;
      &lt;td&gt;送走了哈哈哈&lt;/td&gt;
      &lt;td&gt;0.885148&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;109&lt;/th&gt;
      &lt;td&gt;人机赛打架可以看看DWG打G2第4局&lt;/td&gt;
      &lt;td&gt;0.892714&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h3 id=&#34;3-绘制箱线图对比四支队伍的情感得分&#34;&gt;3. 绘制箱线图对比四支队伍的情感得分&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;team_sentiment = dict()
team_sentiment[&#39;G2&#39;] = Sentiment_df[Sentiment_df[&#39;G2&#39;]][&#39;情感&#39;]
team_sentiment[&#39;TES&#39;] =  Sentiment_df[Sentiment_df[&#39;TES&#39;]][&#39;情感&#39;]
team_sentiment[&#39;SN&#39;] =  Sentiment_df[Sentiment_df[&#39;SN&#39;]][&#39;情感&#39;]
team_sentiment[&#39;DWG&#39;] = Sentiment_df[Sentiment_df[&#39;DWG&#39;]][&#39;情感&#39;]
pd.DataFrame(team_sentiment).describe()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;G2&lt;/th&gt;
      &lt;th&gt;TES&lt;/th&gt;
      &lt;th&gt;SN&lt;/th&gt;
      &lt;th&gt;DWG&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;count&lt;/th&gt;
      &lt;td&gt;258.000000&lt;/td&gt;
      &lt;td&gt;75.000000&lt;/td&gt;
      &lt;td&gt;151.000000&lt;/td&gt;
      &lt;td&gt;116.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;mean&lt;/th&gt;
      &lt;td&gt;0.586540&lt;/td&gt;
      &lt;td&gt;0.617380&lt;/td&gt;
      &lt;td&gt;0.723949&lt;/td&gt;
      &lt;td&gt;0.573803&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;std&lt;/th&gt;
      &lt;td&gt;0.254834&lt;/td&gt;
      &lt;td&gt;0.281933&lt;/td&gt;
      &lt;td&gt;0.269218&lt;/td&gt;
      &lt;td&gt;0.249054&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;min&lt;/th&gt;
      &lt;td&gt;0.031252&lt;/td&gt;
      &lt;td&gt;0.001094&lt;/td&gt;
      &lt;td&gt;0.066510&lt;/td&gt;
      &lt;td&gt;0.000180&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;25%&lt;/th&gt;
      &lt;td&gt;0.457284&lt;/td&gt;
      &lt;td&gt;0.387117&lt;/td&gt;
      &lt;td&gt;0.528126&lt;/td&gt;
      &lt;td&gt;0.457027&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;50%&lt;/th&gt;
      &lt;td&gt;0.561343&lt;/td&gt;
      &lt;td&gt;0.669569&lt;/td&gt;
      &lt;td&gt;0.835424&lt;/td&gt;
      &lt;td&gt;0.475006&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;75%&lt;/th&gt;
      &lt;td&gt;0.802808&lt;/td&gt;
      &lt;td&gt;0.849809&lt;/td&gt;
      &lt;td&gt;0.938778&lt;/td&gt;
      &lt;td&gt;0.802086&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;max&lt;/th&gt;
      &lt;td&gt;0.999967&lt;/td&gt;
      &lt;td&gt;0.999884&lt;/td&gt;
      &lt;td&gt;0.999836&lt;/td&gt;
      &lt;td&gt;0.999823&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603847454202.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">b站s10视频弹幕分析</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/xi-lie-shu-ju-fen-xi-xiao-xiang-mu/"" data-c="
          &lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/b-zhan-s10-shi-pin-dan-mu-fen-xi/&#34;&gt;b站s10弹幕&lt;/a&gt;&lt;br&gt;
关键词：爬虫、分词、统计词频、词云图&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/0920-ACompleteExample/&#34;&gt;高考数据分析&lt;/a&gt;&lt;br&gt;
关键词：数据预处理、哑变量、逻辑回归&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">【系列】数据分析小项目</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1027/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%AE%9A%E4%B9%89%E6%A0%91%E6%A1%A9%E5%BC%B1%E5%88%86%E7%B1%BB%E5%99%A8&#34;&gt;第一步，定义树桩（弱分类器）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E5%B0%8F%E4%BE%8B%E5%AD%90&#34;&gt;第二步，小例子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%89%E6%AD%A5%E5%A4%9A%E4%B8%AA%E7%89%B9%E5%BE%81%E7%9A%84%E9%97%AE%E9%A2%98&#34;&gt;第三步，多个特征的问题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B2%BF%E7%94%A8dating%E6%95%B0%E6%8D%AE%E9%9B%86&#34;&gt;沿用Dating数据集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%80%90%E4%B8%AA%E8%AE%AD%E7%BB%83%E5%BC%B1%E5%AD%A6%E4%B9%A0%E5%99%A8&#34;&gt;逐个训练弱学习器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E5%90%88%E9%A2%84%E6%B5%8B&#34;&gt;组合预测&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E5%9B%9B%E6%AD%A5%E5%AE%9A%E4%B9%89class&#34;&gt;第四步，定义class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%BA%94%E6%AD%A5%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E7%B1%BB%E7%95%8C%E9%99%90&#34;&gt;第五步，可视化分类界限&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;adaboost 基本原理 &lt;a href=&#34;https://www.bilibili.com/video/BV1iA411e76Y?from=search&amp;amp;seid=15172169135136756185&#34;&gt;B站5分钟机器学习&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;具体算法参考《统计学习方法》&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义一个树桩——作为弱分类器&lt;/li&gt;
&lt;li&gt;遍历数据集特征，根据最小分类误差率选择划分最优模型&lt;/li&gt;
&lt;li&gt;计算弱分类器的权重、更新样本权重&lt;/li&gt;
&lt;li&gt;线性组合弱分类器&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;第一步定义树桩弱分类器&#34;&gt;第一步，定义树桩（弱分类器）&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class DecisionStump():
    def __init__(self):
        self.polarity = 1                 # 分类结果（标识方向）
        # 1代表大于阈值判定为1，小于阈值判断为-1，-1反过来
        
        self.feature = None  # 使用的特征
        self.threshold = None        # 使用的阈值
        self.alpha = None             # 该分类器的权重
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第二步小例子&#34;&gt;第二步，小例子&lt;/h1&gt;
&lt;p&gt;跟着《统计学习方法》8.1.3 adaboost的例子（只有一个特征）&lt;/p&gt;
&lt;p&gt;梳理一下算法流程，做3个弱分类器的结合，可以完美拟合该数据&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np
import math

# 数据
x = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
y = np.array([1, 1, 1, -1, -1, -1, 1, 1, 1 ,-1])

# 初始化数据权值
w = [1 / len(x)] * len(x)

# 单个弱学习器的预测结果
def prediction(G, x):
    predictions = np.ones(np.shape(x))
    negative_idx = (G.polarity * x &amp;lt; G.polarity * G.threshold)
    predictions[negative_idx] = -1
    return predictions


######     第1个弱分类器     ######
G1 = DecisionStump()  

# 1.找出分类误差率最低的阈值，保存为第一个弱分类器
error_ratio_old = 1.1   
thresholds = np.arange(0.5, 9, 1)
for threshold in thresholds:
    polarity = 1   
    res_error = (x &amp;lt;= threshold) * (y == polarity) + (x &amp;gt; threshold) * (y == -polarity)     # 分类错误
    error_ratio = np.dot(res_error, w)     # 误差率
    # 2.如果误差率大于0.5，说明方向反了
    if error_ratio &amp;gt; 0.5:  
        polarity = -1
        error_ratio = 1 - error_ratio
    # 3.记录最小误差到第一个决策树桩
    if error_ratio &amp;lt; error_ratio_old:
        error_ratio_old = error_ratio
        G1.polarity = polarity
        G1.threshold = threshold
        G1.alpha = 1/2 * math.log((1 - error_ratio)/error_ratio)
        
# 4.对第一个弱分类器的测试，结果与书上一致
print(&amp;quot;\n第一个弱分类器系数{}, 阈值{}, 方向{}&amp;quot;.format(G1.alpha,G1.threshold,G1.polarity))
pred1 = prediction(G1, x)




######     第2个弱分类器     ######
G2 = DecisionStump()  

# 1 .更新数据权值
def update_w(w, res, error_ratio):
    if res: return (0.5 * w / (1-error_ratio))
    else: return (0.5 * w / error_ratio)
print(&amp;quot;\n更新数据权值：&amp;quot;)
w1 = [update_w(w[i], pred1[i]==y[i], error_ratio_old) for i in range(len(w))]
w1

# 2.找出分类误差率最低的阈值，保存为第2个弱分类器
error_ratio_old = 1.1   
for threshold in thresholds:
    polarity = 1   
    res_error = (x &amp;lt;= threshold) * (y == polarity) + (x &amp;gt; threshold) * (y == -polarity)  
    error_ratio = np.dot(res_error, w1)     # 误差率
    if error_ratio &amp;gt; 0.5:  
        polarity = -1
        error_ratio = 1 - error_ratio
    if error_ratio &amp;lt; error_ratio_old:
        error_ratio_old = error_ratio
        G2.polarity = polarity
        G2.threshold = threshold
        G2.alpha = 1/2 * math.log((1 - error_ratio)/error_ratio)
        
pred2 = prediction(G2, x)
print(&amp;quot;\n第二个弱分类器系数{}, 阈值{}, 方向{}&amp;quot;.format(G2.alpha,G2.threshold,G2.polarity))





######     第3个弱分类器     ######
G3 = DecisionStump()  
# 1 .更新数据权值
print(&amp;quot;\n更新数据权值：&amp;quot;)
w2 = [update_w(w1[i], pred2[i]==y[i], error_ratio_old) for i in range(len(w1))]
w2
# 2.找出分类误差率最低的阈值，保存为第2个弱分类器
error_ratio_old = 1.1   
for threshold in thresholds:
    polarity = 1   
    res_error = (x &amp;lt;= threshold) * (y == polarity) + (x &amp;gt; threshold) * (y == -polarity)  
    error_ratio = np.dot(res_error, w2)     # 误差率
    if error_ratio &amp;gt; 0.5:  
        polarity = -1
        error_ratio = 1 - error_ratio
    if error_ratio &amp;lt; error_ratio_old:
        error_ratio_old = error_ratio
        G3.polarity = polarity
        G3.threshold = threshold
        G3.alpha = 1/2 * math.log((1 - error_ratio)/error_ratio)
        
pred3 = prediction(G3, x)
print(&amp;quot;\n第三个弱分类器系数{}, 阈值{}, 方向{}&amp;quot;.format(G3.alpha,G3.threshold,G3.polarity))




######     结合两个弱分类器     ######
# 组合预测值
pred_y = np.ones(np.shape(x))
fx = pred1 * G1.alpha + pred2 * G2.alpha + pred3 * G3.alpha
negative_idx = (fx &amp;lt; 0)
pred_y[negative_idx] = -1
print(&amp;quot;\n\n真实值：{}&amp;quot;.format(y))
print(&amp;quot;\nadaboost 预测值：{}&amp;quot;.format(pred_y))
print(&amp;quot;\n预测误差 = {}&amp;quot;.format(np.mean(pred_y!=y)))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;第一个弱分类器系数0.4236489301936017, 阈值2.5, 方向-1

更新数据权值：





[0.07142857142857144,
 0.07142857142857144,
 0.07142857142857144,
 0.07142857142857144,
 0.07142857142857144,
 0.07142857142857144,
 0.16666666666666666,
 0.16666666666666666,
 0.16666666666666666,
 0.07142857142857144]




第二个弱分类器系数0.64964149206513, 阈值8.5, 方向-1

更新数据权值：





[0.04545454545454547,
 0.04545454545454547,
 0.04545454545454547,
 0.1666666666666666,
 0.1666666666666666,
 0.1666666666666666,
 0.10606060606060608,
 0.10606060606060608,
 0.10606060606060608,
 0.04545454545454547]




第三个弱分类器系数0.7520386983881369, 阈值5.5, 方向1


真实值：[ 1  1  1 -1 -1 -1  1  1  1 -1]

adaboost 预测值：[ 1.  1.  1. -1. -1. -1.  1.  1.  1. -1.]

预测误差 = 0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第三步多个特征的问题&#34;&gt;第三步，多个特征的问题&lt;/h1&gt;
&lt;p&gt;核心：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遍历数据集特征和阈值，选择最小误差的特征和阈值，记录为该学习器&lt;/li&gt;
&lt;li&gt;更新数据权值，重复上一步建立一个新的学习器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;预测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组合学习器计算最终预测值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;沿用dating数据集&#34;&gt;沿用Dating数据集&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import matplotlib.pyplot as plt
import pandas as pd

dating = pd.read_csv(&amp;quot;Speed Dating Data.csv&amp;quot;, encoding = &amp;quot;gbk&amp;quot;)

## 提取变量——是否接受dec（因变量0-1）、好感度like、吸引力attr
dating = dating[[&#39;like&#39;,&#39;attr&#39;,&#39;dec&#39;]]
dating[&#39;dec&#39;][dating[&amp;quot;dec&amp;quot;]==0] = -1   # 处理为0-1变量
dating.head()

## 缺失问题
dating.isnull().sum(axis=0)  # 缺失比例
dating.dropna(axis = 0, how=&#39;any&#39;, thresh = None, subset = None, inplace=True)   # omit na值
print(&amp;quot;去掉缺失之后总样本量{}&amp;quot;.format(len(dating)))

## 分为训练集和测试集
sample = np.random.choice(range(len(dating)), int(len(dating)*0.8), replace= False).tolist()
dating_train = dating.iloc[sample, :]
dating_test = dating.iloc[[x for x in range(len(dating)) if x not in sample], :]
print(&amp;quot;训练集样本量 = {}, 测试集样本量 = {}&amp;quot;.format(len(dating_train),len(dating_test)))
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;like&lt;/th&gt;
      &lt;th&gt;attr&lt;/th&gt;
      &lt;th&gt;dec&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;6.0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;5.0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;6.0&lt;/td&gt;
      &lt;td&gt;5.0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;like    240
attr    202
dec       0
dtype: int64



去掉缺失之后总样本量8122
训练集样本量 = 6497, 测试集样本量 = 1625
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;逐个训练弱学习器&#34;&gt;逐个训练弱学习器&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;n_train = len(dating_train)
features = [&#39;like&#39;,&#39;attr&#39;]
train_y = dating_train[&amp;quot;dec&amp;quot;]


# 1.初始化权重1/N
w = np.full(n_train, (1/n_train))

# 2.逐个训练弱学习器
estimators = []   # 保存所有学习器
n_estimators = 6 # 准备造n_estimators个学习器
for _ in range(n_estimators):   
    # 2.1 初始化
    G =  DecisionStump()  
    error_ratio_min = 1.0   
    # 2.2 遍历所有特征
    for feature in features:
        feature_values = dating_train[feature]
        unique_values = np.unique(feature_values)
        # 2.3 遍历该特征所有分类阈值
        for threshold in unique_values:
            polarity = 1  # 初始方向
            prediction = np.ones(n_train)
            prediction[feature_values &amp;lt; threshold] = -1
            error_ratio = sum(w[train_y != prediction])  # 误差率
            if error_ratio &amp;gt; 0.5:
                error_ratio = 1 - error_ratio
                polarity = -1
            
            if error_ratio &amp;lt; error_ratio_min:
                G.polarity = polarity
                G.threshold = threshold
                G.feature = feature
                G.alpha = 1/2 * math.log((1 - error_ratio)/error_ratio)
                error_ratio_min = error_ratio
        
    # 3.遍历结束之后
    # 3.1记录得到的学习器
    estimators.append(G)
    # 3.2 更新样本权值，以便下一个学习器的训练
    predictions = np.ones(n_train)
    negative_idx = (G.polarity * dating_train[G.feature] &amp;lt; G.polarity * G.threshold)
    predictions[negative_idx] = -1
    w *= np.exp(-G.alpha * train_y * predictions)
    w /= np.sum(w)
    
# 打印各个学习器的情况  
for i in range(n_estimators):
    print(&amp;quot;\n第{}个弱分类器\n特征{}，系数{}, 阈值{}, 方向{}&amp;quot;.format(i+1, \
                                              estimators[i].feature, estimators[i].alpha,estimators[i].threshold,estimators[i].polarity))

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;第1个弱分类器
特征like，系数0.5286878072409954, 阈值6.5, 方向1

第2个弱分类器
特征attr，系数0.2728648772469795, 阈值6.5, 方向1

第3个弱分类器
特征attr，系数0.1335036849107031, 阈值8.5, 方向1

第4个弱分类器
特征like，系数0.1361143472990432, 阈值6.5, 方向-1

第5个弱分类器
特征like，系数0.1783049598789307, 阈值5.5, 方向1

第6个弱分类器
特征like，系数0.10796016782025766, 阈值8.5, 方向1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;组合预测&#34;&gt;组合预测&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 组合预测
fx = np.zeros(n_train)
for g in estimators:
    predictions = np.ones(n_train)
    negative_idx = (g.polarity * dating_train[g.feature] &amp;lt; g.polarity * g.threshold)
    predictions[negative_idx] = -1
    # 线性预测各个分类器的预测结果：
    fx += g.alpha * predictions


y_pred = np.ones(n_train)
index = (fx &amp;lt; 0)
y_pred[index] = -1
print(&amp;quot;\n预测准确率 = {}&amp;quot;.format(np.mean(y_pred==train_y)))

# 加载库画混淆矩阵
from sklearn.metrics import confusion_matrix
confusion_matrix(train_y, y_pred)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;预测准确率 = 0.7434200400184701





array([[2742,  931],
       [ 736, 2088]])
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第四步定义class&#34;&gt;第四步，定义class&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Adaboost():
    # 弱分类器
    def __init__(self, n_estimators = 5):
        self.n_estimators = n_estimators
        self.estimators = []
    
    # 拟合函数
    def fit(self, train_x, train_y, features):
        # 1.初始化权重1/N
        n_train = len(train_y)
        w = np.full(n_train, (1/n_train))

        # 2.逐个训练弱学习器
        for _ in range(self.n_estimators):   
            # 2.1 初始化
            G =  DecisionStump()  
            error_ratio_min = 1.0   
            # 2.2 遍历所有特征
            for feature in features:
                feature_values = train_x[feature]
                unique_values = np.unique(feature_values)
                # 2.3 遍历该特征所有分类阈值
                for threshold in unique_values:
                    polarity = 1    
                    prediction = np.ones(n_train)
                    prediction[feature_values &amp;lt; threshold] = -1
                    error_ratio = sum(w[train_y != prediction]) 
                    if error_ratio &amp;gt; 0.5:
                        error_ratio = 1 - error_ratio
                        polarity = -1
                    if error_ratio &amp;lt; error_ratio_min:
                        G.polarity = polarity
                        G.threshold = threshold
                        G.feature = feature
                        G.alpha = 1/2 * math.log((1 - error_ratio)/error_ratio)
                        error_ratio_min = error_ratio
        
            # 3.遍历结束之后
            # 3.1 记录得到的学习器
            self.estimators.append(G)
            # 3.2 更新样本权值，以便下一个学习器的训练
            predictions = np.ones(n_train)
            negative_idx = (G.polarity * train_x[G.feature] &amp;lt; G.polarity * G.threshold)
            predictions[negative_idx] = -1
            w *= np.exp( - G.alpha * train_y * predictions)
            w /= np.sum(w)
        
    
    # 组合预测函数
    def prediction(self, test):
        n = len(test)
        fx = np.zeros(n)
        for g in self.estimators:
            predictions = np.ones(n)
            negative_idx = (g.polarity * test[g.feature] &amp;lt; g.polarity * g.threshold)
            predictions[negative_idx] = -1
            fx += g.alpha * predictions  # 预测值
            
        # 根据预测值做出决策：
        y_pred = np.ones(n)
        index = (fx &amp;lt; 0)
        y_pred[index] = -1
        return fx, y_pred
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不同学习器数量的预测结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;myada1 = Adaboost(1)
myada1.fit(train_x = dating_train, train_y = dating_train[&amp;quot;dec&amp;quot;], features = [&#39;like&#39;,&#39;attr&#39;])
test_fx, test_pred = myada1.prediction(dating_test)
print(&amp;quot;\n包含1个学习器的adaboost，预测集上准确率 = {}&amp;quot;.format(np.mean(test_pred==dating_test[&amp;quot;dec&amp;quot;])))

myada2 = Adaboost(2)
myada2.fit(train_x = dating_train, train_y = dating_train[&amp;quot;dec&amp;quot;], features = [&#39;like&#39;,&#39;attr&#39;])
test_fx, test_pred = myada2.prediction(dating_test)
print(&amp;quot;\n包含7个学习器的adaboost，预测集上准确率 = {}&amp;quot;.format(np.mean(test_pred==dating_test[&amp;quot;dec&amp;quot;])))

myada15 = Adaboost(15)
myada15.fit(train_x = dating_train, train_y = dating_train[&amp;quot;dec&amp;quot;], features = [&#39;like&#39;,&#39;attr&#39;])
test_fx, test_pred = myada15.prediction(dating_test)
print(&amp;quot;\n包含15个学习器的adaboost，预测集上准确率 = {}&amp;quot;.format(np.mean(test_pred==dating_test[&amp;quot;dec&amp;quot;])))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;包含1个学习器的adaboost，预测集上准确率 = 0.7341538461538462

包含2个学习器的adaboost，预测集上准确率 = 0.7569230769230769

包含15个学习器的adaboost，预测集上准确率 = 0.7796923076923077
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第五步可视化分类界限&#34;&gt;第五步，可视化分类界限&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def plot_meshgrid(myada):
    # 1.生成网格点数据
    xx1, xx2 = np.meshgrid(np.arange(0, 10, 0.15), np.arange(0, 10, 0.15))   # 生成自变量的数据
    xx = pd.DataFrame({&#39;like&#39;:xx1.ravel(),&#39;attr&#39;:xx2.ravel()})                        # 拉直后合并为df
    yy_fx, yy_pred_ = myada.prediction(xx)
    yy_pred = np.array(yy_pred_).reshape(xx1.shape)                  # reshape为网格/矩阵

    # 2.画图
    fig = plt.figure(figsize=(8,7))   # 创建一张8*6的画布
    # 2.1背景网格点
    color = [&amp;quot;#e2a653&amp;quot; if c==1 else &amp;quot;#6cabe6&amp;quot; for c in yy_pred_] 
    plt.scatter(xx1, xx2, c = color, alpha = 0.4, marker= &amp;quot;.&amp;quot;)

    # 2.2原始数据的点
    color = [&amp;quot;orange&amp;quot; if c==1 else &amp;quot;dodgerblue&amp;quot; for c in dating_train[&#39;dec&#39;]] 
    plt.scatter(dating_train[&#39;like&#39;],dating_train[&#39;attr&#39;], c=color, marker= &amp;quot;s&amp;quot;)

    # 3.图例
    plt.title(&#39;黄色-约会成功\n蓝色-约会失败&#39;, fontproperties=prop, fontsize=30)  
    plt.xlabel(&amp;quot;好感度 like&amp;quot;, fontproperties=prop, fontsize=20)
    plt.ylabel(&amp;quot;吸引力 attr&amp;quot;, fontproperties=prop, fontsize=20)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plot_meshgrid(myada1)
plot_meshgrid(myada2)
plot_meshgrid(myada15)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603772827417.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603773559043.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603773438879.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">手动实现adaboost</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1026/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%A2%98%E7%9B%AE101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;题目101 对称二叉树&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%B8%80%E9%80%92%E5%BD%92%E6%AF%94%E5%AF%B9&#34;&gt;解法一：递归比对&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%A2%98%E7%9B%AE104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6&#34;&gt;题目104 二叉树的最大深度&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E7%AD%94%E4%B8%80%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%E8%A7%A3%E7%AD%94&#34;&gt;解答一：经典递归解答：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%A2%98%E7%9B%AE121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA&#34;&gt;题目121 买卖股票的最佳时机&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E7%AD%94%E4%B8%80%E9%81%8D%E5%8E%86&#34;&gt;解答一，遍历&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%A2%98%E7%9B%AE136-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97&#34;&gt;题目136 只出现一次的数字&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%B8%80%E5%AD%97%E5%85%B8&#34;&gt;解法一，字典&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%BA%8C%E5%BC%95%E5%85%A5%E5%BC%82%E6%88%96%E7%9A%84%E6%A6%82%E5%BF%B5&#34;&gt;解法二：引入“异或”的概念&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%A2%98%E7%9B%AE141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8&#34;&gt;题目141 环形链表&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%B8%80%E9%81%8D%E5%8E%86%E5%AD%97%E5%85%B8&#34;&gt;解法一，遍历+字典&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%BA%8C%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88&#34;&gt;解法二，快慢指针&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%A2%98%E7%9B%AE155-%E6%9C%80%E5%B0%8F%E6%A0%88&#34;&gt;题目155 最小栈&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E8%BE%85%E5%8A%A9%E6%A0%88&#34;&gt;解法——辅助栈&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%A2%98%E7%9B%AE169-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0&#34;&gt;题目169 多数元素&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%B8%80%E5%AD%97%E5%85%B8-2&#34;&gt;解法一：字典&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%BA%8C%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E6%B3%95&#34;&gt;解法二：多数投票法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/two-sum/&#34;&gt;热门题目&amp;amp;简单题 23道&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;题目101-对称二叉树&#34;&gt;题目101 对称二叉树&lt;/h1&gt;
&lt;h2 id=&#34;解法一递归比对&#34;&gt;解法一：递归比对&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;结束条件：1.两个节点有空——都空T 否则F；2.两个节点数值不同——F&lt;/li&gt;
&lt;li&gt;递归部分：两个节点数值相同——递归往两侧递归&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是没有看到特别的其他解法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#Definition for a binary tree node:
#class TreeNode:
#    def __init__(self, x):
#        self.val = x
#        self.left = None
#        self.right = None

def isSymmetric(root):
    if root==None:
        return True
        
    def is_mirror(left, right):
        if (left == None) or (right == None):
            return (left == None) and (right == None)
        elif left.val !=right.val:
            return False
        else:
            return (is_mirror(left.right, right.left) and is_mirror(left.left, right.right))

    return is_mirror(root.left, root.right)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目104-二叉树的最大深度&#34;&gt;题目104 二叉树的最大深度&lt;/h1&gt;
&lt;h2 id=&#34;解答一经典递归解答&#34;&gt;解答一：经典递归解答：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;结束条件：==None&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同样没有看到特别的其他解法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def maxDepth(root):
    if root==None:
        return 0
    
    else:
        depth1 = maxDepth(root.left)+1
        depth2 = maxDepth(root.right)+1
        
    if depth1&amp;gt;depth2:
        return depth1
    else:
        return depth2
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目121-买卖股票的最佳时机&#34;&gt;题目121 买卖股票的最佳时机&lt;/h1&gt;
&lt;p&gt;给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。&lt;/p&gt;
&lt;p&gt;如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。&lt;/p&gt;
&lt;p&gt;注意：你不能在买入股票前卖出股票。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;输入: [7,1,5,3,6,4]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出: 5&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&lt;br&gt;
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入: [7,6,4,3,1]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出: 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解答一遍历&#34;&gt;解答一，遍历&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def maxprofit(prices):
    maxprofit = 0
    minprice = float(&#39;inf&#39;)   # 无穷大
    
    for price in prices:
        minprice = min(minprice, price)
        maxprofit = max(price-minprice, maxprofit)
    return maxprofit

maxprofit([7,1,5,3,6,4])
maxprofit([7,6,4,3,1])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目136-只出现一次的数字&#34;&gt;题目136 只出现一次的数字&lt;/h1&gt;
&lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p&gt;
&lt;p&gt;你的算法应该具有线性时间复杂度。 你可以&lt;strong&gt;不使用额外空间来实现&lt;/strong&gt;吗？&lt;/p&gt;
&lt;p&gt;输入: [4,1,2,1,2]&lt;/p&gt;
&lt;p&gt;输出: 4&lt;/p&gt;
&lt;h2 id=&#34;解法一字典&#34;&gt;解法一，字典&lt;/h2&gt;
&lt;p&gt;随便写了一个&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def singleNumber(numlist):
    d = dict()
    
    for i in numlist:
        if i in d:
            d[i] += 1
        else:
            d[i] = 1
            
    for j in d.keys():
        if d[j] == 1:
            break
    
    return j

singleNumber([4,1,2,1,2])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;4
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解法二引入异或的概念&#34;&gt;解法二：引入“异或”的概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;两个数字异或的结果a^b——将 a 和 b 的二进制每一位进行运算&lt;/li&gt;
&lt;li&gt;任何数和本身异或: 0&lt;/li&gt;
&lt;li&gt;任何数和 0 异或: 本身&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时间击败94% 内存击败67%！&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def singleNumber(numlist):
    single = 0
    for i in numlist:
        single ^= i
    return single

singleNumber([4,1,2,1,2])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;4
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目141-环形链表&#34;&gt;题目141 环形链表&lt;/h1&gt;
&lt;p&gt;给定一个链表，判断链表中是否有环。&lt;/p&gt;
&lt;p&gt;如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。&lt;/p&gt;
&lt;p&gt;为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。&lt;/p&gt;
&lt;p&gt;输入：head = [3,2,0,-4], pos = 1&lt;br&gt;
输出：true&lt;br&gt;
解释：链表中有一个环，其尾部连接到第二个节点。&lt;/p&gt;
&lt;h2 id=&#34;解法一遍历字典&#34;&gt;解法一，遍历+字典&lt;/h2&gt;
&lt;p&gt;第一反应，遍历过的node +1；第二次next经过有就return True&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

def hasCycle(head):
    d = dict()
    node = head
    while node:
        if node in d:
            return True
        else:
            d[node] = None
        node = node.next
        
    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解法二快慢指针&#34;&gt;解法二，快慢指针&lt;/h2&gt;
&lt;p&gt;快慢指针（龟兔赛跑，空间复杂度O(1)）&lt;/p&gt;
&lt;p&gt;**要点：**枚举时添加一个慢一拍的指针（指针对应的是节点），如果有环最终两个指针会相遇&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def hasCycle(head):
    rabbit = head
    turtle = head
    tmp = False

    while rabbit:
        if tmp:   # 乌龟走一步停一步
            turtle = turtle.next
            tmp = False
        else:
            tmp = True
                
        rabbit = rabbit.next
        
        if rabbit==turtle:
            return True
    
    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目155-最小栈&#34;&gt;题目155 最小栈&lt;/h1&gt;
&lt;p&gt;设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push(x) —— 将元素 x 推入栈中。&lt;/li&gt;
&lt;li&gt;pop() —— 删除栈顶的元素。&lt;/li&gt;
&lt;li&gt;top() —— 获取栈顶元素。&lt;/li&gt;
&lt;li&gt;getMin() —— 检索栈中的最小元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解法辅助栈&#34;&gt;解法——辅助栈&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关键点&lt;/strong&gt;删除栈顶时候最小元素会变动，因此不能只保留最小值，要保留前i个中最小值序列（辅助栈），这样删除时把最小序列的栈顶也pop就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MinStack:
    def __init__(self):
        self.stack = []
        self.min_s = [math.inf]

    def push(self, x):
        self.stack.append(x)
        self.min_s.append(min(x, self.min_s[-1]))

    def pop(self):
        self.stack.pop()
        self.min_s.pop()

    def top(self):  
        return self.stack[-1]

    def getMin(self):
        return self.min_s[-1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目169-多数元素&#34;&gt;题目169 多数元素&lt;/h1&gt;
&lt;p&gt;给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。&lt;/p&gt;
&lt;p&gt;你可以假设数组是非空的，并且给定的数组总是存在多数元素。&lt;/p&gt;
&lt;h2 id=&#34;解法一字典-2&#34;&gt;解法一：字典&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def majorityElement(self, nums: List[int]) -&amp;gt; int:
        d = dict()
        for i in nums:
            if i in d:
                d[i] += 1
            else:
                d[i] = 1
        for j in d.keys():
            if d[j]&amp;gt;len(nums)/2:
                return j
                break
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解法二多数投票法&#34;&gt;解法二：多数投票法&lt;/h2&gt;
&lt;p&gt;候选人(cand_num)初始化为nums[0]，票数count初始化为1。&lt;br&gt;
当遇到与cand_num相同的数，则票数count = count + 1，否则票数count = count - 1。&lt;br&gt;
当票数count为0时，更换候选人，并将票数count重置为1。&lt;br&gt;
遍历完数组后，cand_num即为最终答案。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def majorityElement(nums):
    major = 0
    count = 0
    
    for n in nums:
        if count == 0:
            count = 1
            major = n
        elif n == major:
            count += 1
        else:
            count -= 1
    
    return major

majorityElement([2,2,1,1,1,2,2,3,2])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2
&lt;/code&gt;&lt;/pre&gt;
">练习题 DAY2</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/jiao-lu-xiao-ji/"" data-c="
          &lt;h2 id=&#34;学业&#34;&gt;学业&lt;/h2&gt;
&lt;p&gt;原来大家都没有学得很认真。其实谈到专硕应该好好学习吗，这个问题并没有标准答案。即便是准备就业，在学校里好好学习也是不错的选择，虽然这些知识在实际工作中不会用到，但这也是一种收获，一种特殊的坚持，或者可能是完美主义。&lt;/p&gt;
&lt;h2 id=&#34;实习&#34;&gt;实习&lt;/h2&gt;
&lt;p&gt;原来大家都没有满意的实习经历。我以为本院本科的同学实习经历应该挺丰富，然鹅...似乎上海这边非金融行业相比北京还是差了一截，或者可能是上海实习机会多，我却没有足够的资源接触到哭唧唧。至于实习经历影响就业，与其为了还没发生的事发愁，不如学习。学习真香。还是要平静下来，尽可能的做些准备吧，祝自己和朋友们可以在年底/明年初找到一份好实习。&lt;/p&gt;
&lt;h2 id=&#34;外形&#34;&gt;外形&lt;/h2&gt;
&lt;p&gt;原来大家都会为了身材焦虑。一度无法面对开学不到两个月胖了15斤的我，现在平静接受了这个事实，安慰自己双下巴也蛮可爱。开学入手了一个三倍镜子，看着镜子突然焦虑爆炸，可以清晰看到毛孔黑眼圈还有些痘印和细纹，现在也会安慰自己脸蛋软软滑滑的就挺好。自信一点吧🐑🐑，多笑笑也会更开心的哇。&lt;/p&gt;
&lt;h2 id=&#34;恋爱&#34;&gt;恋爱&lt;/h2&gt;
&lt;p&gt;原来大家都在为恋爱焦虑，即使是看起来很social 很懂恋爱的人。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我只喜欢喜欢别人的感觉，不喜欢被人喜欢，也不喜欢谈恋爱&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天被q初恋，其实本身对于母胎solo这事没什么抗拒情绪，但是令别人惊讶了难免觉得心情有些不妙。还有人暗戳戳问过是不是原生家庭或者受过刺激，害，我爸妈非常幸福自己也从来没受过伤害。只是觉得，其实如果打心眼里觉得单身真香，那就没必要谈恋爱。和朋友聊了聊自己之后的一些想法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不愿花费时间在恋爱上，却幻想收获恋爱幸福感，简单来说可以有男朋友但是不想恋爱。&lt;/li&gt;
&lt;li&gt;被人喜欢让自己觉得被特别关注了，压力增加会不自在，好吧据说这是核心原因。&lt;/li&gt;
&lt;li&gt;只喜欢喜欢别人的感觉&lt;/li&gt;
&lt;li&gt;害怕恋爱脑&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;蟹蟹喜欢过我的人，说到底似乎我更爱我自己&lt;/p&gt;
">焦虑小记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1024/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%AC%E4%B8%9C%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF%E7%88%AC%E5%8F%96&#34;&gt;京东商品信息爬取&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%8E%B7%E5%8F%96%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9&#34;&gt;获取页面内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#user-agent&#34;&gt;user-agent&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#xpath%E8%8E%B7%E5%8F%96%E5%86%85%E5%AE%B9&#34;&gt;xpath获取内容&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%80%E6%AD%A5-%E8%8E%B7%E5%8F%96ul%E6%A0%87%E7%AD%BE%E4%B8%8B%E6%89%80%E6%9C%89%E7%9A%84li&#34;&gt;第一步、获取ul标签下所有的li&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%BA%8C%E6%AD%A5-%E8%8E%B7%E5%8F%96li%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%90%84%E9%A1%B9%E4%BF%A1%E6%81%AF&#34;&gt;第二步、获取li下面的各项信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%89%E6%AD%A5-%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E8%AF%84%E8%AE%BA%E6%95%B0%E8%8E%B7%E5%8F%96&#34;&gt;第三步、动态加载问题解决评论数获取&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%B4%E7%90%86%E6%88%90%E4%B8%BA%E5%BE%AA%E7%8E%AF%E6%89%B9%E9%87%8F%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%B9%B6%E6%95%B4%E7%90%86&#34;&gt;整理成为循环，批量获取数据，并整理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多图预警👀&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;字 数&lt;br&gt;
1740&lt;br&gt;
预计阅读时间&lt;br&gt;
8m 24s&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;京东商品信息爬取&#34;&gt;京东商品信息爬取&lt;/h1&gt;
&lt;p&gt;根据b站视频京东耳机数据爬虫改造的——口红数据爬取~&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://search.jd.com/Search?keyword=%E5%8F%A3%E7%BA%A2&amp;amp;qrst=1&amp;amp;wq=%E5%8F%A3%E7%BA%A2&amp;amp;stock=1&amp;amp;psort=3&amp;amp;click=0&#34;&gt;&lt;strong&gt;京东搜索“口红”（按销量排行）&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;尝试提取：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;价格&lt;/li&gt;
&lt;li&gt;名称&lt;/li&gt;
&lt;li&gt;评论数&lt;/li&gt;
&lt;li&gt;配送信息&lt;/li&gt;
&lt;li&gt;优惠信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;获取页面内容&#34;&gt;获取页面内容&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import requests
from bs4 import BeautifulSoup

# 1.获取页面源代码
url = &amp;quot;https://search.jd.com/Search?keyword=%E5%8F%A3%E7%BA%A2&amp;amp;qrst=1&amp;amp;wq=%E5%8F%A3%E7%BA%A2&amp;amp;stock=1&amp;amp;psort=3&amp;amp;click=0&amp;quot;
r = requests.get(url)
print(r)            # 打印出了状态码
print(r.text)      # 要你进入登录页面
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Response [200]&amp;gt;
&amp;lt;script&amp;gt;window.location.href=&#39;https://passport.jd.com/uc/login&#39;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;状态码：&lt;/strong&gt;&lt;br&gt;
200（说明ok）/404/403/301/302&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;window.location&lt;/strong&gt;&lt;br&gt;
要你进入登录界面，如何解决：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模拟登陆&lt;/li&gt;
&lt;li&gt;浏览器可以访问，说明被反爬虫了，模拟浏览器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;user-agent&#34;&gt;user-agent&lt;/h2&gt;
&lt;p&gt;如何做？user-agent（实例1里做过了）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;url = &amp;quot;https://search.jd.com/Search?keyword=%E5%8F%A3%E7%BA%A2&amp;amp;qrst=1&amp;amp;wq=%E5%8F%A3%E7%BA%A2&amp;amp;stock=1&amp;amp;psort=3&amp;amp;click=0&amp;quot;

header = {  
&#39;user-agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#39;
}

r = requests.get(url, headers = header) 
soup = BeautifulSoup(r.text,&#39;html.parser&#39;)
len(soup)
# print(soup)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;12
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;xpath获取内容&#34;&gt;xpath获取内容&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603469325307.jpg&#34; alt=&#34;寻找需要内容&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;第一步-获取ul标签下所有的li&#34;&gt;第一步、获取ul标签下所有的li&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;什么好获取——id是唯一的&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ul不好获取，但是上面的div有唯一属性id = &amp;quot;J_goodsList&amp;quot;，&lt;/li&gt;
&lt;li&gt;可以先找到这个 div，在下面找到 ul 和下面的所有 li&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603469297174.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from lxml import etree   # xpath

# 1.获取所有li
html = etree.HTML(r.text)  # 处理为xpath可以操作的格式
li_list = html.xpath(&amp;quot;//div[@id=&#39;J_goodsList&#39;]/ul/li&amp;quot;)   # 得到所有li
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;第二步-获取li下面的各项信息&#34;&gt;第二步、获取li下面的各项信息&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;价格和名字直接根据结构写xpath找到&lt;br&gt;
&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603469481814.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;评论呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 2.获取各项信息
li0 = li_list[0]  # 取第一个商品
# 价格
price = li0.xpath(&amp;quot;.//div[@class=&#39;p-price&#39;]/strong/i/text()&amp;quot;)
# 名字
titles_ =  li0.xpath(&amp;quot;.//div[@class=&#39;p-name p-name-type-2&#39;]/a/em/text()&amp;quot;)
titles = [&amp;quot;&amp;quot;.join(titles_)]
print(price, titles)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&#39;330.00&#39;] [&#39;迪奥（Dior）烈艳蓝金哑光999# 3.5g 传奇红（ 迪奥999  传奇正红 精美礼盒/礼袋随机）&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;第三步-动态加载问题解决评论数获取&#34;&gt;第三步、动态加载问题解决评论数获取&lt;/h3&gt;
&lt;p&gt;评论数量是变化的，所以是动态加载出来的，如果找到呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参考操作 &lt;a href=&#34;https://www.bilibili.com/video/BV1Az4y1X7dx?p=3&#34;&gt;python 京东页面提取&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603469419748.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;p&gt;https://club.jd.com/comment/productCommentSummaries.action?referenceIds=100011323932,100001991065,100006262957,1500761,3950523,100012754240,100008341435,100006079301,8309688,4564204,51014202575,100005929347,100005185544,100002478996,5153444,5120482,100012976226,875858,51014202569,100013500996,8683285,63512766378,100006965554,5051885,100013038018,100008029287,5469830,100014924764,100007090981,100006979685&amp;amp;callback=jQuery9688568&amp;amp;_=1603461054566&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;如果把后面的&amp;quot;&amp;amp;callback=jQuery9688568&amp;amp;_=1603461054566&amp;quot;都去掉，会变成这样（可以进行request)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;https://club.jd.com/comment/productCommentSummaries.action?referenceIds=100011323932,100001991065,100006262957,1500761,3950523,100012754240,100008341435,100006079301,8309688,4564204,51014202575,100005929347,100005185544,100002478996,5153444,5120482,100012976226,875858,51014202569,100013500996,8683285,63512766378,100006965554,5051885,100013038018,100008029287,5469830,100014924764,100007090981,100006979685&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;接着就可以对这个新的url进行内容获取&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现评论对应着商品id（SkuId），它其实是每一个li标签的一个属性data-sku的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发现评论的网址格式为https://club.jd.com/comment/productCommentSummaries.action?referenceIds=商品id1,商品id2,....  因此可以根据id生成url，从而获取评论数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;stu = li0.xpath(&amp;quot;@data-sku&amp;quot;)[0]
# 生成0号商品的评论数网址
url_comment = &amp;quot;https://club.jd.com/comment/productCommentSummaries.action?referenceIds={}&amp;quot;.format(str(stu))
print(url_comment)
comment = requests.get(url_comment, headers = header).json()
comments = comment[&#39;CommentsCount&#39;][0]
print(comment)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;https://club.jd.com/comment/productCommentSummaries.action?referenceIds=100011323932
{&#39;CommentsCount&#39;: [{&#39;SkuId&#39;: 100011323932, &#39;ProductId&#39;: 100011323932, &#39;ShowCount&#39;: 10450, &#39;ShowCountStr&#39;: &#39;1万+&#39;, &#39;CommentCountStr&#39;: &#39;68万+&#39;, &#39;CommentCount&#39;: 684913, &#39;AverageScore&#39;: 5, &#39;DefaultGoodCountStr&#39;: &#39;55万+&#39;, &#39;DefaultGoodCount&#39;: 555723, &#39;GoodCountStr&#39;: &#39;13万+&#39;, &#39;GoodCount&#39;: 131212, &#39;AfterCount&#39;: 1776, &#39;OneYear&#39;: 0, &#39;AfterCountStr&#39;: &#39;1700+&#39;, &#39;VideoCount&#39;: 423, &#39;VideoCountStr&#39;: &#39;400+&#39;, &#39;GoodRate&#39;: 0.96, &#39;GoodRateShow&#39;: 96, &#39;GoodRateStyle&#39;: 144, &#39;GeneralCountStr&#39;: &#39;1800+&#39;, &#39;GeneralCount&#39;: 1840, &#39;GeneralRate&#39;: 0.013, &#39;GeneralRateShow&#39;: 1, &#39;GeneralRateStyle&#39;: 2, &#39;PoorCountStr&#39;: &#39;2900+&#39;, &#39;PoorCount&#39;: 2979, &#39;SensitiveBook&#39;: 0, &#39;PoorRate&#39;: 0.027, &#39;PoorRateShow&#39;: 3, &#39;PoorRateStyle&#39;: 4}]}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;整理成为循环批量获取数据并整理&#34;&gt;整理成为循环，批量获取数据，并整理&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np

# 1.定义函数——输入: li，输出: 商品stuid、评论相关变量
def comment_info(li):
    # 1. 获取商品id
    stu = li.xpath(&amp;quot;@data-sku&amp;quot;)[0]
    
    # 2.生成商品的评论数网址
    url_comment = &amp;quot;https://club.jd.com/comment/productCommentSummaries.action?referenceIds={}&amp;quot;.format(str(stu))
    comment = requests.get(url_comment, headers = header).json()
    comments = comment[&#39;CommentsCount&#39;][0]
    
    # 3.获取评论相关变量
    CommentCount = comments[&#39;CommentCount&#39;]    # 评价总数
    DefaultGoodCount = comments[&#39;DefaultGoodCount&#39;]   # 默认好评数
    GoodCount = comments[&#39;GoodCount&#39;]           # 好评数
    GeneralCount = comments[&#39;GeneralCount&#39;]    # 中评数
    PoorCount = comments[&#39;PoorCount&#39;]            # 差评数
    AfterCount = comments[&#39;AfterCount&#39;]           # 追评
    VideoCount = comments[&#39;VideoCount&#39;]         # 视频评价数
    GoodRate = comments[&#39;GoodRate&#39;]              # 好评率
    
    return stu,CommentCount,DefaultGoodCount,GoodCount,GeneralCount,PoorCount,AfterCount,VideoCount,GoodRate


# 2.定义函数——输入li，输出商品名称和价格
def nameprice_info(li):
    # 获取商品价格
    price = np.float(li.xpath(&amp;quot;.//div[@class=&#39;p-price&#39;]/strong/i/text()&amp;quot;)[0])
    # 获取商品名称
    titles_ =  li.xpath(&amp;quot;.//div[@class=&#39;p-name p-name-type-2&#39;]/a/em/text()&amp;quot;)
    titles = [&amp;quot;&amp;quot;.join(titles_)][0].replace(&amp;quot;  &amp;quot;,&amp;quot;&amp;quot;).replace(&amp;quot;\t\n&amp;quot;,&amp;quot;&amp;quot;)
    labels = li.xpath(&amp;quot;.//div/i/text()&amp;quot;)
    return titles, price,labels


# 测试
li0 = li_list[0] 
titles, price, labels = nameprice_info(li0)
stuid,CommentCount,DefaultGoodCount,GoodCount,GeneralCount,PoorCount,AfterCount,VideoCount,GoodRate = comment_info(li0)
titles, stuid, price, labels, CommentCount,DefaultGoodCount,GoodCount,GeneralCount,PoorCount,AfterCount,VideoCount,GoodRate
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(&#39;迪奥（Dior）烈艳蓝金哑光999# 3.5g 传奇红（ 迪奥999传奇正红 精美礼盒/礼袋随机）&#39;,
 &#39;100011323932&#39;,
 330.0,
 [&#39;自营&#39;, &#39;品质溯源&#39;, &#39;满300-40&#39;],
 684915,
 555719,
 131218,
 1840,
 2979,
 1776,
 423,
 0.96)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# all变量
lipsticks = []

for i in range(len(li_list)):
    li = li_list[i]
    tmp = [None]*12
    tmp[1], tmp[2], tmp[3] = nameprice_info(li)
    tmp[0], tmp[4], tmp[5], tmp[6], tmp[7], tmp[8], tmp[9], tmp[10], tmp[11]= comment_info(li)
    lipsticks.append(tmp)
    
import pandas as pd
lipsticks_df = pd.DataFrame(lipsticks, columns= [&amp;quot;stuid&amp;quot;,&amp;quot;titles&amp;quot;,&amp;quot;price&amp;quot;,&amp;quot;labels&amp;quot;,&amp;quot;CommentCount评价总数&amp;quot;,\
                                                 &amp;quot;DefaultGoodCount默认好评数&amp;quot;,&amp;quot;GoodCount好评数&amp;quot;,&amp;quot;GeneralCount中评数&amp;quot;,&amp;quot;PoorCount差评数&amp;quot;,&amp;quot;AfterCount追评数&amp;quot;,&amp;quot;VideoCount视频评论数&amp;quot;,&amp;quot;GoodRate好评率&amp;quot;]) 
print(&amp;quot;京东口红商品信息爬取成功：&amp;quot;)
lipsticks_df.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;京东口红商品信息爬取成功：
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;stuid&lt;/th&gt;
      &lt;th&gt;titles&lt;/th&gt;
      &lt;th&gt;price&lt;/th&gt;
      &lt;th&gt;labels&lt;/th&gt;
      &lt;th&gt;CommentCount评价总数&lt;/th&gt;
      &lt;th&gt;DefaultGoodCount默认好评数&lt;/th&gt;
      &lt;th&gt;GoodCount好评数&lt;/th&gt;
      &lt;th&gt;GeneralCount中评数&lt;/th&gt;
      &lt;th&gt;PoorCount差评数&lt;/th&gt;
      &lt;th&gt;AfterCount追评数&lt;/th&gt;
      &lt;th&gt;VideoCount视频评论数&lt;/th&gt;
      &lt;th&gt;GoodRate好评率&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;100011323932&lt;/td&gt;
      &lt;td&gt;迪奥（Dior）烈艳蓝金哑光999# 3.5g 传奇红（ 迪奥999传奇正红 精美礼盒/礼袋随机）&lt;/td&gt;
      &lt;td&gt;330.0&lt;/td&gt;
      &lt;td&gt;[自营, 品质溯源, 满300-40]&lt;/td&gt;
      &lt;td&gt;684915&lt;/td&gt;
      &lt;td&gt;555717&lt;/td&gt;
      &lt;td&gt;131220&lt;/td&gt;
      &lt;td&gt;1840&lt;/td&gt;
      &lt;td&gt;2979&lt;/td&gt;
      &lt;td&gt;1776&lt;/td&gt;
      &lt;td&gt;423&lt;/td&gt;
      &lt;td&gt;0.96&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;100001991065&lt;/td&gt;
      &lt;td&gt;圣罗兰（YSL）细管纯2.2g 21#复古正红 小金条复古哑光&lt;/td&gt;
      &lt;td&gt;328.0&lt;/td&gt;
      &lt;td&gt;[自营, 放心购, 品质溯源, 秒杀, 满300-50]&lt;/td&gt;
      &lt;td&gt;282034&lt;/td&gt;
      &lt;td&gt;231553&lt;/td&gt;
      &lt;td&gt;49332&lt;/td&gt;
      &lt;td&gt;661&lt;/td&gt;
      &lt;td&gt;938&lt;/td&gt;
      &lt;td&gt;702&lt;/td&gt;
      &lt;td&gt;204&lt;/td&gt;
      &lt;td&gt;0.96&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;100006262957&lt;/td&gt;
      &lt;td&gt;迪奥（Dior）烈艳蓝金唇膏滋润999# 3.5g 经典正红色 ( 迪奥 迪奥999 赠礼盒...&lt;/td&gt;
      &lt;td&gt;330.0&lt;/td&gt;
      &lt;td&gt;[自营, 品质溯源, 满300-40]&lt;/td&gt;
      &lt;td&gt;684915&lt;/td&gt;
      &lt;td&gt;555717&lt;/td&gt;
      &lt;td&gt;131220&lt;/td&gt;
      &lt;td&gt;1840&lt;/td&gt;
      &lt;td&gt;2979&lt;/td&gt;
      &lt;td&gt;1776&lt;/td&gt;
      &lt;td&gt;423&lt;/td&gt;
      &lt;td&gt;0.96&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;1500761&lt;/td&gt;
      &lt;td&gt;纪梵希（Givenchy）小羊皮306#3.4g 礼盒装(又名：高定香榭唇膏N306 斩男番...&lt;/td&gt;
      &lt;td&gt;345.0&lt;/td&gt;
      &lt;td&gt;[自营, 品质溯源]&lt;/td&gt;
      &lt;td&gt;393924&lt;/td&gt;
      &lt;td&gt;311890&lt;/td&gt;
      &lt;td&gt;111614&lt;/td&gt;
      &lt;td&gt;1154&lt;/td&gt;
      &lt;td&gt;1771&lt;/td&gt;
      &lt;td&gt;1179&lt;/td&gt;
      &lt;td&gt;443&lt;/td&gt;
      &lt;td&gt;0.97&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;3950523&lt;/td&gt;
      &lt;td&gt;迪奥(Dior)烈艳蓝金999哑光唇膏3.5g(迪奥 正红色 传奇红唇 礼物送女友)&lt;/td&gt;
      &lt;td&gt;212.0&lt;/td&gt;
      &lt;td&gt;[自营, 品质溯源, 秒杀, 券300-40, 满99-20]&lt;/td&gt;
      &lt;td&gt;452385&lt;/td&gt;
      &lt;td&gt;362651&lt;/td&gt;
      &lt;td&gt;93423&lt;/td&gt;
      &lt;td&gt;1485&lt;/td&gt;
      &lt;td&gt;2193&lt;/td&gt;
      &lt;td&gt;1340&lt;/td&gt;
      &lt;td&gt;337&lt;/td&gt;
      &lt;td&gt;0.96&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
">爬虫实例2</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/1023/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/python-pa-chong-xpath/&#34;&gt;基本原理: python爬虫汇总篇&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;使用-requests-抓取bs4结构化&#34;&gt;使用 requests 抓取+bs4结构化&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np
import pandas as pd
import requests        #导入requests包
from bs4 import BeautifulSoup

## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    
import warnings
warnings.filterwarnings(&#39;ignore&#39;)


url = &#39;http://www.cntour.cn/&#39;
strhtml = requests.get(url)        #Get方式获取网页数据，是一个 URL 对象，它代表整个网页
soup = BeautifulSoup(strhtml.text,&amp;quot;html.parser&amp;quot;)
#print(soup)  # 把爬取的内容结构化了
soup.title
soup.find_all(&#39;a&#39;)[:5]
print(soup.get_text()[:10])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;中国旅游网
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;简单实例1爬取中国大学排名&#34;&gt;简单实例1——爬取中国大学排名&lt;/h2&gt;
&lt;p&gt;https://www.shanghairanking.cn/rankings/bcur/2020&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import requests
from bs4 import BeautifulSoup
allUniv = []

def getHTMLText(url):
    try:
        r = requests.get(url, timeout=30)
        r.raise_for_status()
        r.encoding = &#39;utf-8&#39;
        return r.text
    except:
        return &amp;quot;&amp;quot;
    
url = &#39;https://www.shanghairanking.cn/rankings/bcur/2020.html&#39;
html = getHTMLText(url)
soup = BeautifulSoup(html, &amp;quot;html.parser&amp;quot;)
schools = soup.find_all(&#39;tr&#39;)


# 选择清华大学进行尝试
school1 = schools[2]
print(&amp;quot;\n1.以清华大学为例:\n&amp;quot;)
print(school1)
# 把清华各类信息分割开，根据&amp;lt;td&amp;gt;
school1_str = school1.find_all(&amp;quot;td&amp;quot;)
tsinghua = []
# 提取文字部分
for i in range(len(school1_str)):
    tsinghua.append(school1_str[i].get_text(&amp;quot;|&amp;quot;, strip=True))  # 删掉空白
print(&amp;quot;\n2.提取文字部分:\n&amp;quot;)
print(tsinghua)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1.以清华大学为例:

&amp;lt;tr data-v-45ac69d8=&amp;quot;&amp;quot;&amp;gt;&amp;lt;td data-v-45ac69d8=&amp;quot;&amp;quot;&amp;gt;
          1
        &amp;lt;/td&amp;gt;&amp;lt;td class=&amp;quot;align-left&amp;quot; data-v-45ac69d8=&amp;quot;&amp;quot;&amp;gt;&amp;lt;a data-v-45ac69d8=&amp;quot;&amp;quot; href=&amp;quot;/institution/tsinghua-university&amp;quot;&amp;gt;清华大学&amp;lt;/a&amp;gt; &amp;lt;p data-v-45ac69d8=&amp;quot;&amp;quot; style=&amp;quot;display:none&amp;quot;&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;td data-v-45ac69d8=&amp;quot;&amp;quot;&amp;gt;
          北京
        &amp;lt;/td&amp;gt;&amp;lt;td data-v-45ac69d8=&amp;quot;&amp;quot;&amp;gt;
          综合
        &amp;lt;/td&amp;gt;&amp;lt;td data-v-45ac69d8=&amp;quot;&amp;quot;&amp;gt;
          852.5
        &amp;lt;/td&amp;gt;&amp;lt;td data-v-45ac69d8=&amp;quot;&amp;quot;&amp;gt;
          38.2
        &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;

2.提取文字部分:

[&#39;1&#39;, &#39;清华大学&#39;, &#39;北京&#39;, &#39;综合&#39;, &#39;852.5&#39;, &#39;38.2&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pandas as pd
# 用dataframe存储爬取结果
univ_rank = []

for i in range(2,len(schools)):
    school = schools[i]
    school_str = school.find_all(&amp;quot;td&amp;quot;)
    datalist = []
    # 提取文字部分
    for j in range(len(school_str)):
        datalist.append(school_str[j].get_text(&amp;quot;|&amp;quot;, strip=True))  # 删掉空白
    univ_rank.append(datalist)

univ_rank_df = pd.DataFrame(univ_rank, columns= [&amp;quot;排名&amp;quot;,&amp;quot;学校名称&amp;quot;,&amp;quot;省市&amp;quot;,&amp;quot;类型&amp;quot;,&amp;quot;总分&amp;quot;,&amp;quot;办学层次&amp;quot;]) 
univ_rank_df.head()
univ_rank_df.shape
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;排名&lt;/th&gt;
      &lt;th&gt;学校名称&lt;/th&gt;
      &lt;th&gt;省市&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;总分&lt;/th&gt;
      &lt;th&gt;办学层次&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;清华大学&lt;/td&gt;
      &lt;td&gt;北京&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;852.5&lt;/td&gt;
      &lt;td&gt;38.2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;北京&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;746.7&lt;/td&gt;
      &lt;td&gt;36.1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;浙江大学&lt;/td&gt;
      &lt;td&gt;浙江&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;649.2&lt;/td&gt;
      &lt;td&gt;33.9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;上海交通大学&lt;/td&gt;
      &lt;td&gt;上海&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;625.9&lt;/td&gt;
      &lt;td&gt;35.4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;南京大学&lt;/td&gt;
      &lt;td&gt;江苏&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;566.1&lt;/td&gt;
      &lt;td&gt;35.1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;(567, 6)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;简单实例2学院官网会议信息&#34;&gt;简单实例2——学院官网会议信息&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;url = &#39;http://www.math.sjtu.edu.cn/research/seminar.php&#39;
html = getHTMLText(url)
soup = BeautifulSoup(html, &amp;quot;html.parser&amp;quot;)
# &amp;lt;a href=&amp;quot;seminar-show.php?id=4068&amp;quot;&amp;gt;
soup.find_all(&amp;quot;a&amp;quot;,href=&amp;quot;seminar-show.php?id=4068&amp;quot;)
def has_class_but_no_id(tag):
    return tag.has_attr(&#39;href&#39;) and not tag.has_attr(&#39;class&#39;)
xx = soup.find_all(has_class_but_no_id)
xx[0].find(&amp;quot;a&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&amp;lt;a href=&amp;quot;seminar-show.php?id=4068&amp;quot;&amp;gt;
 &amp;lt;div class=&amp;quot;title&amp;quot;&amp;gt;
 &amp;lt;div class=&amp;quot;zh&amp;quot;&amp;gt;
 &amp;lt;span style=&amp;quot;color: #F4A011;&amp;quot;&amp;gt;
 									[COLLOQUIUM]								&amp;lt;/span&amp;gt;
 								杨伟豪							&amp;lt;/div&amp;gt;
 &amp;lt;div class=&amp;quot;en&amp;quot;&amp;gt;TBA&amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
 &amp;lt;div class=&amp;quot;time&amp;quot;&amp;gt;
 &amp;lt;div class=&amp;quot;date&amp;quot;&amp;gt;2020-11-27&amp;lt;/div&amp;gt;
 &amp;lt;div class=&amp;quot;hour&amp;quot;&amp;gt;14:00 — 15:15&amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
 &amp;lt;/a&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import re  # 正则表达式，选出href包含这一串字符的标签
def ifseminar(href):
        return href and re.compile(&amp;quot;seminar\-show.php\?id=+\d{4}&amp;quot;).search(href)   # 正则表达式匹配
xx = soup.find_all(href = ifseminar)

# 取一场会议的看看
xx[0]
#xx[0].get_text(&amp;quot;,&amp;quot;, strip=True).split(&amp;quot;,&amp;quot;)
#xx[1].get_text(&amp;quot;,&amp;quot;, strip=True).split(&amp;quot;,&amp;quot;)
# 注意有些会议有分类，因此如果len=4，要在会议分类一项设为None
Seminars = []
for i in range(0,len(xx)):
    tmp = xx[i].get_text(&amp;quot;|&amp;quot;, strip=True).split(&amp;quot;|&amp;quot;)
    if len(tmp)==4:
        tmp.insert(0, None)
    Seminars.append(tmp)
    
seminars_df = pd.DataFrame(Seminars, columns= [&amp;quot;类型&amp;quot;,&amp;quot;报告人&amp;quot;,&amp;quot;标题&amp;quot;,&amp;quot;日期&amp;quot;,&amp;quot;时间&amp;quot;]) 
seminars_df.iloc[:10,:]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;seminar-show.php?id=4068&amp;quot;&amp;gt;
&amp;lt;div class=&amp;quot;title&amp;quot;&amp;gt;
&amp;lt;div class=&amp;quot;zh&amp;quot;&amp;gt;
&amp;lt;span style=&amp;quot;color: #F4A011;&amp;quot;&amp;gt;
									[COLLOQUIUM]								&amp;lt;/span&amp;gt;
								杨伟豪							&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;en&amp;quot;&amp;gt;TBA&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;time&amp;quot;&amp;gt;
&amp;lt;div class=&amp;quot;date&amp;quot;&amp;gt;2020-11-27&amp;lt;/div&amp;gt;
&amp;lt;div class=&amp;quot;hour&amp;quot;&amp;gt;14:00 — 15:15&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;报告人&lt;/th&gt;
      &lt;th&gt;标题&lt;/th&gt;
      &lt;th&gt;日期&lt;/th&gt;
      &lt;th&gt;时间&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;[COLLOQUIUM]&lt;/td&gt;
      &lt;td&gt;杨伟豪&lt;/td&gt;
      &lt;td&gt;TBA&lt;/td&gt;
      &lt;td&gt;2020-11-27&lt;/td&gt;
      &lt;td&gt;14:00 — 15:15&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;刘会   教授&lt;/td&gt;
      &lt;td&gt;The multiplicity and stability conjectures abo...&lt;/td&gt;
      &lt;td&gt;2020-11-19&lt;/td&gt;
      &lt;td&gt;10:00 — 11:30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;[INS COLLOQUIUM]&lt;/td&gt;
      &lt;td&gt;Alberto Bressan&lt;/td&gt;
      &lt;td&gt;Distinguished Lecture in Celebration of the 10...&lt;/td&gt;
      &lt;td&gt;2020-11-10&lt;/td&gt;
      &lt;td&gt;10:00 — 11:00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;骆威&lt;/td&gt;
      &lt;td&gt;On order determination by predictor augmentation&lt;/td&gt;
      &lt;td&gt;2020-11-05&lt;/td&gt;
      &lt;td&gt;14:00 — 15:00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;杜增吉&lt;/td&gt;
      &lt;td&gt;Dynamics of traveling waves for shallow water ...&lt;/td&gt;
      &lt;td&gt;2020-10-29&lt;/td&gt;
      &lt;td&gt;14:00 — 15:00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;陈和柏&lt;/td&gt;
      &lt;td&gt;连续分段线性系统的奇点分类及其相应奇点指标&lt;/td&gt;
      &lt;td&gt;2020-10-29&lt;/td&gt;
      &lt;td&gt;15:00 — 16:30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;张荣茂&lt;/td&gt;
      &lt;td&gt;Identifying Cointegration under High-dimension...&lt;/td&gt;
      &lt;td&gt;2020-10-28&lt;/td&gt;
      &lt;td&gt;14:00 — 15:00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;[INS COLLOQUIUM]&lt;/td&gt;
      &lt;td&gt;Chi-wang Shu&lt;/td&gt;
      &lt;td&gt;Distinguished Lecture in Celebration of the 10...&lt;/td&gt;
      &lt;td&gt;2020-10-27&lt;/td&gt;
      &lt;td&gt;09:30 — 10:30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;8&lt;/th&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;朱文圣&lt;/td&gt;
      &lt;td&gt;Concordance Matched Learning for Estimating Op...&lt;/td&gt;
      &lt;td&gt;2020-10-27&lt;/td&gt;
      &lt;td&gt;14:00 — 15:00&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;9&lt;/th&gt;
      &lt;td&gt;None&lt;/td&gt;
      &lt;td&gt;李骥&lt;/td&gt;
      &lt;td&gt;Orbital stability of the Degasperis-Procesi eq...&lt;/td&gt;
      &lt;td&gt;2020-10-23&lt;/td&gt;
      &lt;td&gt;15:00 — 16:00&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;简单实例3如何爬取下一页&#34;&gt;简单实例3——如何爬取下一页&lt;/h2&gt;
&lt;h3 id=&#34;爬取下厨房网站的早餐下一页有明显规律&#34;&gt;爬取下厨房网站的早餐（下一页有明显规律）&lt;/h3&gt;
&lt;p&gt;http://www.xiachufang.com/category/40071/&lt;/p&gt;
&lt;p&gt;网页源代码通常从前几行可以看到声明，例如 content = &#39;text/html; charset = &#39;gbk&#39;&lt;br&gt;
字符编码是gbk&lt;/p&gt;
&lt;p&gt;headers={&amp;quot;user-agent：xxx&amp;quot;}模拟浏览器——反爬虫&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603425618855.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;headers = {  
&#39;user-agent&#39;: &#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.111 Safari/537.36&#39;
}

recipes = []
for i in range(1,12):   # 爬取10页内容
    urli = &amp;quot;http://www.xiachufang.com/category/40071/?page=&amp;quot;+str(i)   # 循环爬取下一页
    res = requests.get(urli, headers = headers) #获取数据
    html = res.text
    soup = BeautifulSoup(html,&#39;html.parser&#39;)
    recipei = soup.find_all(&amp;quot;div&amp;quot;, class_ = &amp;quot;info pure-u&amp;quot;)
    recipes += recipei   # 合并到一起
len(recipes)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;236
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 提取变量
recipeslist = []
for i in range(len(recipes)):
    recipe0 = recipes[i]
    tmp = [&amp;quot;&amp;quot;]*5
    tmp[0] = recipe0.a.get_text(strip = True)  # 标题
    tmp[1] = recipe0.find(&amp;quot;p&amp;quot;, class_ = &amp;quot;ing ellipsis&amp;quot;).get_text(strip = True).split(&amp;quot;、&amp;quot;)       # 食材
    if recipe0.find(&amp;quot;span&amp;quot;, class_ = &amp;quot;score bold green-font&amp;quot;) == None:   #  评分
        tmp[2] = None
    else: 
        tmp[2] = np.float(recipe0.find(&amp;quot;span&amp;quot;, class_ = &amp;quot;score bold green-font&amp;quot;).get_text()) 
    if recipe0.find(&amp;quot;span&amp;quot;, class_ = &amp;quot;bold score&amp;quot;) == None:      # 做过人数
        tmp[3] = None
    else: 
        tmp[3] = np.int(recipe0.find(&amp;quot;span&amp;quot;, class_ = &amp;quot;bold score&amp;quot;).get_text())   
    tmp[4] = recipe0.find(&amp;quot;a&amp;quot;, class_ = &amp;quot;gray-font&amp;quot;).get_text()             # 作者
    recipeslist.append(tmp)

# 整理为dataframe
recipes_df = pd.DataFrame(recipeslist, columns= [&amp;quot;标题&amp;quot;,&amp;quot;食材&amp;quot;,&amp;quot;评分&amp;quot;,&amp;quot;做过的人数&amp;quot;,&amp;quot;作者&amp;quot;]) 
recipes_df.iloc[:13, ]
recipes_df.shape
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;标题&lt;/th&gt;
      &lt;th&gt;食材&lt;/th&gt;
      &lt;th&gt;评分&lt;/th&gt;
      &lt;th&gt;做过的人数&lt;/th&gt;
      &lt;th&gt;作者&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;四十八天不重样早餐&lt;/td&gt;
      &lt;td&gt;[主食, 果蔬, 肉蛋]&lt;/td&gt;
      &lt;td&gt;7.6&lt;/td&gt;
      &lt;td&gt;12.0&lt;/td&gt;
      &lt;td&gt;cincintoitoitoi&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;5分钟快手早餐——鸡蛋饼&lt;/td&gt;
      &lt;td&gt;[鸡蛋, 面粉, 火腿肠, 辣酱, 芝麻酱, 孜然粉, 盐]&lt;/td&gt;
      &lt;td&gt;7.7&lt;/td&gt;
      &lt;td&gt;2.0&lt;/td&gt;
      &lt;td&gt;吃吃喝喝小主妇&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;面片汤&lt;/td&gt;
      &lt;td&gt;[馄饨皮, 西红柿, 鸡蛋, 水, 菠菜, 葱花, 酱油, 十三香, 盐, 味精或是鸡精, 糖]&lt;/td&gt;
      &lt;td&gt;8.3&lt;/td&gt;
      &lt;td&gt;5.0&lt;/td&gt;
      &lt;td&gt;wupeilu115&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;秒杀路边摊的鸡蛋汉堡&lt;/td&gt;
      &lt;td&gt;[面粉, 水, 鸡蛋, 火腿肠, 香葱, 剩的饺子馅, 盐, 泡打粉, 孜然粉, 花椒粉, ...&lt;/td&gt;
      &lt;td&gt;8.1&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;H_美食爱好者&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;解决孩子不吃菜难题的胡萝卜蔬菜厚蛋烧鸡蛋卷&lt;/td&gt;
      &lt;td&gt;[鸡蛋, 水果胡萝卜, 盐, 双汇火腿, 韭菜, 生抽, 白糖]&lt;/td&gt;
      &lt;td&gt;8.1&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;殇婆子&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;家有小学生，每周早餐不重样（10.12-10.18）&lt;/td&gt;
      &lt;td&gt;[爱]&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;0.0&lt;/td&gt;
      &lt;td&gt;大元子的元&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;td&gt;吐司这样吃-一周减脂三明治不重样&lt;/td&gt;
      &lt;td&gt;[吐司片, 鸡蛋, 生菜, 芝士片, 胡萝卜, 火腿片, 鸡胸肉, 金枪鱼罐头, 虾仁, 颗...&lt;/td&gt;
      &lt;td&gt;8.2&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;姚小胖MissYiu&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;一碗清汤面 🍜 —— 秋日里的治愈系&lt;/td&gt;
      &lt;td&gt;[拉面, 香葱, 小米椒, 蒜蓉, 生抽, 陈醋, 盐, 鸡精, 黑胡椒]&lt;/td&gt;
      &lt;td&gt;8.3&lt;/td&gt;
      &lt;td&gt;54.0&lt;/td&gt;
      &lt;td&gt;Ane_思远哥哥&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;8&lt;/th&gt;
      &lt;td&gt;玉米面松饼，早起5分钟搞定，又软又健康&lt;/td&gt;
      &lt;td&gt;[玉米面, 白面, 鸡蛋, 白糖, 酵母粉, 温水]&lt;/td&gt;
      &lt;td&gt;8.1&lt;/td&gt;
      &lt;td&gt;8.0&lt;/td&gt;
      &lt;td&gt;豆妈糕点1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;9&lt;/th&gt;
      &lt;td&gt;家庭版土豆丝卷饼&lt;/td&gt;
      &lt;td&gt;[土豆, 胡萝卜, 青椒丝, 葱花, 牛肉粉, 蚝油, 花椒粉, 生抽, 盐, 面粉, 盐,...&lt;/td&gt;
      &lt;td&gt;8.4&lt;/td&gt;
      &lt;td&gt;2.0&lt;/td&gt;
      &lt;td&gt;风飘千雪496631161&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;10&lt;/th&gt;
      &lt;td&gt;我的破壁养生路（分享破壁机食谱，不断更新中）&lt;/td&gt;
      &lt;td&gt;[各种五谷杂粮, 各种蔬菜水果]&lt;/td&gt;
      &lt;td&gt;8.7&lt;/td&gt;
      &lt;td&gt;2.0&lt;/td&gt;
      &lt;td&gt;马宝宝的妈咪&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;11&lt;/th&gt;
      &lt;td&gt;连着3天儿子都点名要吃的晚餐，剪刀面&lt;/td&gt;
      &lt;td&gt;[鸡蛋, 西红柿, 火腿肠, 面粉, 菠菜]&lt;/td&gt;
      &lt;td&gt;8.0&lt;/td&gt;
      &lt;td&gt;12.0&lt;/td&gt;
      &lt;td&gt;豆妈糕点1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12&lt;/th&gt;
      &lt;td&gt;和风海苔虾滑蛋三明治【健康一手握】&lt;/td&gt;
      &lt;td&gt;[吐司或欧包汉堡胚随便你, 第戎芥末籽酱, 寿司海苔, 芝士, 虾仁, 盐, 黑胡椒, 鸡蛋...&lt;/td&gt;
      &lt;td&gt;9.5&lt;/td&gt;
      &lt;td&gt;2.0&lt;/td&gt;
      &lt;td&gt;一只有猫病的Sunsun&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;(236, 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 统计各个食材用于早餐的次数
shicai = recipes_df[&#39;食材&#39;]
d = {}
type_num = []
for i in range(len(shicai)):
    type_num.append(len(shicai[i]))
    for j in range(len(shicai[i])):
        tmp = shicai[i][j]
        if tmp not in d:
            d[tmp] = 1
        else:
            d[tmp] += 1

# 最常出现的食材
hot_shicai = sorted(d.items(), key = lambda item:item[1],reverse=True)[:8]
hot_shicai = [[i[0],i[1]] for i in hot_shicai]
hot_shicai = pd.DataFrame(hot_shicai, columns= [&#39;食材名称&#39;,&#39;出现次数&#39;])
hot_shicai
# 每个早餐需要的食材数目
np.mean(type_num)
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;食材名称&lt;/th&gt;
      &lt;th&gt;出现次数&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;盐&lt;/td&gt;
      &lt;td&gt;103&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;鸡蛋&lt;/td&gt;
      &lt;td&gt;83&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;面粉&lt;/td&gt;
      &lt;td&gt;51&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;水&lt;/td&gt;
      &lt;td&gt;41&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;牛奶&lt;/td&gt;
      &lt;td&gt;39&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;酵母&lt;/td&gt;
      &lt;td&gt;37&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;td&gt;糖&lt;/td&gt;
      &lt;td&gt;30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;生抽&lt;/td&gt;
      &lt;td&gt;27&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;7.190677966101695
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;试着对以上数据做些描述&#34;&gt;试着对以上数据做些描述&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# matplotlib 中的pyplot函数，用于画图
import matplotlib.pyplot as plt      # 命名为plt

# 在jupyter 里显示图片
import numpy as np
%matplotlib inline

# font_manager函数，用于指定中文字体样式、大小
import matplotlib.font_manager as mfm

# 设置字体
font_path = r&amp;quot;/Users/mac/Library/Fonts/字体管家方萌简（非商业使用）v1.1.ttf&amp;quot;
prop = mfm.FontProperties(fname = font_path)

# 画图主题
plt.style.use(&#39;seaborn-white&#39;)  # 指定全局画图主题为ggplot
#plt.style.use(&#39;ggplot&#39;)
fig = plt.figure(figsize=(18,12))   # 画布

# 1.评分的直方图
ax1 = fig.add_subplot(111)        # 创建子图
ax1 = fig.add_subplot(2,2,1)           # 创建2*2=4张图，ax1画在第一张图上
ax1.hist(x = recipes_df[&#39;评分&#39;].dropna(axis=0), color = &amp;quot;dodgerblue&amp;quot;,alpha = 0.5)
ax1.set_title(&#39;评分直方图&#39;, fontproperties=prop, fontsize=40)   # 图标题

# 2.食材数目直方图
ax2 = fig.add_subplot(111)        # 创建子图
ax2 = fig.add_subplot(2,2,2)           # 创建2*2=4张图，ax1画在第一张图上
ax2.hist(x = type_num, color = &amp;quot;orange&amp;quot;, alpha = 0.9)
ax2.set_title(&#39;需要食材种类直方图&#39;, fontproperties=prop, fontsize=40)   # 图标题

# 3.热门食材的出现次数
ax3 = fig.add_subplot(111)        # 创建子图
ax3 = fig.add_subplot(2,2,3)           # 创建2*2=4张图，ax1画在第一张图上
ax3.bar(hot_shicai[&#39;食材名称&#39;], hot_shicai[&#39;出现次数&#39;], color = &amp;quot;pink&amp;quot;)
ax3.set_title(&#39;热门食材的出现次数&#39;, fontproperties=prop, fontsize=40)   # 图标题
ax3.set_xticklabels(labels =hot_shicai[&#39;食材名称&#39;], fontproperties=prop, fontsize=20)

# 4.做过的人数直方图
ax4 = fig.add_subplot(111)        # 创建子图
ax4 = fig.add_subplot(2,2,4)           # 创建2*2=4张图，ax1画在第一张图上
ax4.hist(x = recipes_df[&#39;做过的人数&#39;].dropna(axis=0), color = &amp;quot;grey&amp;quot;,alpha = 0.5)
ax4.set_title(&#39;做过的人数直方图&#39;, fontproperties=prop, fontsize=40)   # 图标题

plt.show()  # 画图
plt.close()  # plt.show()结束后仍然保存在内存中, 切记关闭！！！在jupyter理！！！
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603366028256.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">爬虫实例1</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/python-pa-chong-xpath/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5&#34;&gt;一、基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C-html&#34;&gt;二、HTML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89-xpath&#34;&gt;三、xpath&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&#34;&gt;1.基础知识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E5%B8%B8%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6&#34;&gt;2.常用通配符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B-beautifulsoap&#34;&gt;四、beautifulSoap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;一-基本概念&#34;&gt;一、基本概念&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;前端的概念&lt;br&gt;
前端技术语言体系包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;html：超文本标记语言（第一行就是声明）&lt;/li&gt;
&lt;li&gt;css：层叠样式表（渲染），简单理解为标签中的属性&lt;/li&gt;
&lt;li&gt;javascript/js：语言（e.g.点击——&amp;gt;处理）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;爬虫工具和学习框架&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;爬静态网站
&lt;ul&gt;
&lt;li&gt;requests 链接网站&lt;/li&gt;
&lt;li&gt;bs4 将网页变成结构化数据，方便爬&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;爬动态网站 js加载的
&lt;ul&gt;
&lt;li&gt;chrome 开发者工具+requests&lt;/li&gt;
&lt;li&gt;selenium/ghost&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;其他
&lt;ul&gt;
&lt;li&gt;多线程爬虫&lt;/li&gt;
&lt;li&gt;代理IP池&lt;/li&gt;
&lt;li&gt;scrapy pyspider 框架&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;二-html&#34;&gt;二、HTML&lt;/h1&gt;
&lt;p&gt;常见标签含义：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script type = ...&amp;gt; ：javascript——是控制页面逻辑的，爬虫时候不用管
&amp;lt;body&amp;gt; 页面内容
&amp;lt;div class = &#39;一部分css代码，理解为属性&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个标签:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;b class=&amp;quot;boldest&amp;quot;&amp;gt; 加粗字体 &amp;lt;/b&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b class=&#34;boldest&#34;&gt; 加粗字体（诶在markdown里面也有效） &lt;/b&gt;&lt;/li&gt;
&lt;li&gt;b——name&lt;/li&gt;
&lt;li&gt;class——attribute，&amp;quot;boldest&amp;quot; 是class的取值&lt;/li&gt;
&lt;li&gt;其他常见属性：href, style,id.title,tid等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;元素的树形关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先辈、父、子、兄弟、后代&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;三-xpath&#34;&gt;三、xpath&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py1024/&#34;&gt;京东商品爬取案例——xpath&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;1基础知识&#34;&gt;1.基础知识&lt;/h2&gt;
&lt;p&gt;/    从根节点来选择元素&lt;br&gt;
//   从匹配选择的当前节点来对文档中的因素进行选择&lt;br&gt;
.     选取当前节点&lt;br&gt;
..    选择当前节点的父节点&lt;br&gt;
@   选择属性&lt;/p&gt;
&lt;p&gt;例子：&lt;br&gt;
body/div  选取属于body的子元素中的所有div元素&lt;br&gt;
//div        选择所有div 标签的子元素，不管他们在文档中的位置&lt;br&gt;
@lang      选取名称为lang的所有属性&lt;/p&gt;
&lt;h2 id=&#34;2常用通配符&#34;&gt;2.常用通配符&lt;/h2&gt;
&lt;p&gt;*       匹配任何元素节点&lt;br&gt;
@*    匹配任何属性节点&lt;/p&gt;
&lt;p&gt;例子：&lt;br&gt;
//*    选取所有元素&lt;br&gt;
//title[@*]   选取所有&amp;quot;有属性的title元素&amp;quot;&lt;br&gt;
| 代表的是“并集”的关系（通常表示“or”不太一样）&lt;br&gt;
//body/div | //body/li   选取body下面所有 div和li 元素&lt;/p&gt;
&lt;h1 id=&#34;四-beautifulsoap&#34;&gt;四、beautifulSoap&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/1023/&#34;&gt;requests+bs4 爬取大学排名表、学院官网会议、下厨房早餐&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;就是一个从html或者xml文件中提取数据的python库&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;获取某一个标签：&lt;br&gt;
soup.head     获取html的文档头&lt;br&gt;
soup.p          获取第一个p标签&lt;br&gt;
soup.p.attrs   获取第一个p标签的属性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;find_all获取所有指定标签&lt;br&gt;
soup.find_all(id = xx)    获取所有id为xx的标签&lt;br&gt;
soup.find_all(&#39;p&#39;) 获取所有p标签&lt;br&gt;
soup.find_all(&#39;td&#39;, class_ = &#39;aa&#39;)  打印所有标签为aa的td标签——按照css来匹配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和正则表达式的&lt;strong&gt;组合使用&lt;/strong&gt;&lt;br&gt;
import re&lt;br&gt;
正则表达式用法具体百度&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a class = &amp;quot;abc&amp;quot;&amp;gt; 生存分析 &amp;lt;a/&amp;gt;
&amp;lt;a class = &amp;quot;abc&amp;quot;&amp;gt; 多元回归 &amp;lt;a/&amp;gt;
re.findall(&amp;quot;&amp;gt;(.{2,5})&amp;lt;/a&amp;gt;&amp;quot;, str(names)) 全文文字匹配出此格式
def ifseminar(href):                定义一个href属性的匹配函数
        return href and re.compile(&amp;quot;seminar\?id=+\d{4}&amp;quot;).search(href)     
soup.find_all(href = ifseminar)   找到所有href属性满足条件的标签
get_text(&amp;quot;|&amp;quot;, strip=True)          删除空白换行等，用|作为分隔符
&lt;/code&gt;&lt;/pre&gt;
">python 爬虫汇总篇</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1022/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC1%E9%A2%98%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C&#34;&gt;第1题，两数之和&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%B8%80%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4&#34;&gt;解法一：简单粗暴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%BA%8C%E8%BD%AC%E5%8C%96%E6%88%90%E5%AD%97%E5%85%B8%E5%8A%A0%E5%BF%AB%E6%9F%A5%E6%89%BE&#34;&gt;解法二：转化成字典加快查找&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC20%E9%A2%98%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7&#34;&gt;第20题，有效的括号&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%B8%80-%E5%81%9A%E4%B8%80%E4%B8%AA%E5%BE%AA%E7%8E%AF%E4%B8%8D%E6%96%AD%E5%88%A0%E9%99%A4%E6%88%90%E5%AF%B9%E7%AC%A6%E5%8F%B7&#34;&gt;解法一、做一个循环不断删除成对符号&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%BA%8C-%E7%94%A8%E4%B8%80%E4%B8%AA%E6%A0%88%E6%9D%A5%E8%AE%B0%E5%BD%95%E6%A0%87%E5%87%86&#34;&gt;解法二、用一个栈来记录（标准）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC21%E9%A2%98%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8&#34;&gt;第21题，合并两个有序链表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC53%E9%A2%98%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C&#34;&gt;第53题，最大子序和&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%B8%80%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4-2&#34;&gt;解法一，简单粗暴&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%BA%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%B6%85%E7%AE%80%E6%B4%81&#34;&gt;解法二，动态规划，超简洁&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%B8%89%E5%88%86%E6%B2%BB%E6%B3%95&#34;&gt;解法三，分治法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC70%E9%A2%98%E7%88%AC%E6%A5%BC%E6%A2%AF&#34;&gt;第70题，爬楼梯&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%B8%80%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E5%85%B8%E5%9E%8B%E7%9A%84%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98&#34;&gt;解法一，简单粗暴，典型的递归问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E6%B3%95%E4%BA%8C%E4%BC%98%E5%8C%96%E9%80%92%E5%BD%92&#34;&gt;解法二，优化递归&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://leetcode-cn.com/problems/two-sum/&#34;&gt;热门题目&amp;amp;简单题 23道&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;第1题两数之和&#34;&gt;第1题，两数之和&lt;/h1&gt;
&lt;p&gt;给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们。假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;e.g. 给定 nums = [2, 7, 11, 15], target = 9，返回 [2, 7]&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解法一简单粗暴&#34;&gt;解法一：简单粗暴&lt;/h2&gt;
&lt;p&gt;for i 每一个数，计算和target的差值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def twoSum(nums, target):
    notfound = True
    i = 0
    while i &amp;lt; len(nums) and notfound:
        tmp = target - nums[i]
        j = i+1
        while j &amp;lt;len(nums) and notfound:
            if nums[j] == tmp:
                notfound = False
            j += 1
        i += 1
        
    if not notfound:
        return [i-1, j-1]
    
# 测试
twoSum(nums = [2,7,11,15,4], target = 9)
twoSum(nums = [2,7,11,15,4], target = 22)
twoSum(nums = [2,7,11,15,4], target = 8)
twoSum(nums = [2,7,11,15,4], target = 14) 
twoSum(nums = [2,2,11,15,4], target = 4) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[0, 1]






[1, 3]






[0, 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解法二转化成字典加快查找&#34;&gt;解法二：转化成字典加快查找&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def twoSum(nums, target):
    d = {}
    n = len(nums)
    for i in range(n):   # 转化成字典
        d[nums[i]] = i   # 如果有相同的字符，value变成最后一次出现时候的index
    for i in range(n):
        tmp = target - nums[i]
        j = d.get(tmp)   # 用字典查找
        if (not j == None) and (not i==j):   # 排除是本身
            return [i,j]
        

# 测试
twoSum(nums = [2,7,11,15,4], target = 9)
twoSum(nums = [2,7,11,15,4], target = 22)
twoSum(nums = [2,7,11,15,4], target = 8)
twoSum(nums = [2,7,11,15,4], target = 14)
twoSum(nums = [2,2,11,15,4], target = 4) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[0, 1]






[1, 3]






[0, 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第20题有效的括号&#34;&gt;第20题，有效的括号&lt;/h1&gt;
&lt;p&gt;给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;有效字符串需满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左括号必须用相同类型的右括号闭合。&lt;/li&gt;
&lt;li&gt;左括号必须以正确的顺序闭合。&lt;/li&gt;
&lt;li&gt;空字符串可被认为是有效字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解法一-做一个循环不断删除成对符号&#34;&gt;解法一、做一个循环不断删除成对符号&lt;/h2&gt;
&lt;p&gt;迭代删掉成对的括号，虽然可以，但是复杂度高了&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def isValid(strings):   # leetcode上复杂度rank倒数
    while len(list(strings))&amp;gt;1:
        before  = len(list(strings))
        strings  = strings.replace(&amp;quot;()&amp;quot;,&amp;quot;&amp;quot;).replace(&amp;quot;[]&amp;quot;,&amp;quot;&amp;quot;).replace(&amp;quot;{}&amp;quot;,&amp;quot;&amp;quot;)
        after = len(list(strings))
        if before == after: 
            break
            
    if len(list(strings))==0:
        return True
    else:
        return False

isValid(&amp;quot;([]{{}})[{}[[]]]&amp;quot;)
isValid(&amp;quot;&amp;quot;)
isValid(&amp;quot;([)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;True






True






False
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解法二-用一个栈来记录标准&#34;&gt;解法二、用一个栈来记录（标准）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;从左边开始发现了左括号，push进去&lt;/li&gt;
&lt;li&gt;发现了右括号，把栈尾部的pop出来对比，如果栈是空的——F，如果pop出来的不匹配——F，否则继续进行&lt;/li&gt;
&lt;li&gt;最后看栈是不是空的&lt;/li&gt;
&lt;li&gt;执行时间超过97%的&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def isValid(strings):
    string = list(strings)
    left = [&amp;quot;(&amp;quot;, &amp;quot;[&amp;quot;, &amp;quot;{&amp;quot;]
    right = [&amp;quot;)&amp;quot;, &amp;quot;]&amp;quot;, &amp;quot;}&amp;quot;]
    stack = []
    
    for i in range(len(string)):
        if string[i] in left:
            stack.append(string[i])
        if string[i] in right:
            if len(stack)==0: 
                return False  # 右括号多了
            else:
                tmp = stack.pop()
                if left.index(tmp)!=right.index(string[i]):  # 左右不匹配
                    return False
   
    if len(stack)==0:  
        return True
    else: 
        return False  # 左括号多了


isValid(&amp;quot;([]{{}})[{}[[]]]&amp;quot;)
isValid(&amp;quot;&amp;quot;)
isValid(&amp;quot;([)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;True






True






False
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第21题合并两个有序链表&#34;&gt;第21题，合并两个有序链表&lt;/h1&gt;
&lt;p&gt;将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的&lt;/p&gt;
&lt;p&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;/p&gt;
&lt;p&gt;输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/p&gt;
&lt;p&gt;思路——递归&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结束条件：两个链表剩下的空了&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ListNode:
     def __init__(self, val=0, next=None):
            self.val = val
            self.next = next
        
a1 = ListNode(1)
a2 = ListNode(2)
a3 = ListNode(4)
a1.next = a2
a2.next = a3

b1 = ListNode(1)
b2 = ListNode(3)
b3 = ListNode(4)
b1.next = b2
b2.next = b3
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def mergeTwoLists(l1: ListNode, l2: ListNode) -&amp;gt; ListNode:  # 要连接的下一个是什么
    if not l1: return l2  # l1没有了，l2后面的直接接上
    if not l2: return l1  # l2没有了，l1后面的直接接上
    if l1.val &amp;lt;= l2.val:   # 如果l1比l2小
        l1.next = mergeTwoLists(l1.next,l2) # 用l1的下一个和l2比较，比较的结果作为1.next
        return l1          # return l1 l2两者更小的（作为连接的next）
    else: 
        l2.next = mergeTwoLists(l1,l2.next)
        return l2 

# 测试
mergeTwoLists(a1, b1)
a = a1
while a!=None:
    print(a.val, end = &amp;quot; -&amp;gt; &amp;quot;)
    a = a.next
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;__main__.ListNode at 0x1044be8d0&amp;gt;



1 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3 -&amp;gt; 4 -&amp;gt; 4 -&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;第53题最大子序和&#34;&gt;第53题，最大子序和&lt;/h1&gt;
&lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;输入: [-2,1,-3,4,-1,2,1,-5,4]&lt;/p&gt;
&lt;p&gt;输出: 6&lt;/p&gt;
&lt;p&gt;解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。&lt;/p&gt;
&lt;h2 id=&#34;解法一简单粗暴-2&#34;&gt;解法一，简单粗暴&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一个数作为起点，如果直到下一个正数, sum_tmp &amp;lt;0，则记max[i] ==0 ，sum_tmp = 再次开始计算, 。&lt;/li&gt;
&lt;li&gt;如果直到下一个正数 max &amp;gt; 0，则把max单独拿出来，如果max_next，如果max_next&amp;lt;0，则maxx=max，max=0&lt;/li&gt;
&lt;li&gt;如果max_next&amp;gt;0，max=max+max_next&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;面试这样写会被打的，把问题复杂化了。。。&lt;/strong&gt;，但是执行时间和内存消耗都挺小。。。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def max_Sum(nums):
    maxsum = nums[0]
    tmp_sum = nums[0]
    for i in range(1,len(nums)):
        if nums[i] &amp;gt; 0:
            if tmp_sum &amp;lt;= 0:
                tmp_sum = nums[i]
                if tmp_sum &amp;gt; maxsum:
                    maxsum = tmp_sum
            elif tmp_sum &amp;gt; 0:
                tmp_sum = tmp_sum+nums[i]
                maxsum = max(maxsum, tmp_sum)
    
        elif nums[i] &amp;lt;= 0:
            if maxsum&amp;lt;= 0:
                maxsum = max(maxsum, nums[i])     
            elif maxsum&amp;gt; 0:
                tmp_sum = tmp_sum + nums[i]
        print(i, nums[i], tmp_sum, maxsum)
    return(maxsum)


max_Sum( [-2,1,-3,4,-1,2,1,-5,4])
max_Sum( [-1,0])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1 1 1 1
2 -3 -2 1
3 4 4 4
4 -1 3 4
5 2 5 5
6 1 6 6
7 -5 1 6
8 4 5 6





6



1 0 -1 0





0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解法二动态规划超简洁&#34;&gt;解法二，动态规划，超简洁&lt;/h2&gt;
&lt;p&gt;超简洁代码！&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nums在更新前是原始数据，从第二项开始往右更新，更新后记录子序和&lt;/li&gt;
&lt;li&gt;每当当前数据比累计子序和要大时，重新从当前开始计算子序和。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;nums = [-2,1,-3, 4, -1,2,1,-5,4]
for i in range(1,len(nums)):
    nums[i] = max(nums[i-1]+nums[i], nums[i])  
    #print(nums)
max(nums)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[-2, 1, -3, 4, -1, 2, 1, -5, 4]
[-2, 1, -2, 4, -1, 2, 1, -5, 4]
[-2, 1, -2, 4, -1, 2, 1, -5, 4]
[-2, 1, -2, 4, 3, 2, 1, -5, 4]
[-2, 1, -2, 4, 3, 5, 1, -5, 4]
[-2, 1, -2, 4, 3, 5, 6, -5, 4]
[-2, 1, -2, 4, 3, 5, 6, 1, 4]
[-2, 1, -2, 4, 3, 5, 6, 1, 5]




6
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解法三分治法&#34;&gt;解法三，分治法&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603337312613.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;第70题爬楼梯&#34;&gt;第70题，爬楼梯&lt;/h1&gt;
&lt;p&gt;假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p&gt;
&lt;p&gt;每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p&gt;
&lt;p&gt;注意：给定 n 是一个正整数。&lt;/p&gt;
&lt;p&gt;输入： 3&lt;br&gt;
输出： 3&lt;/p&gt;
&lt;h2 id=&#34;解法一简单粗暴典型的递归问题&#34;&gt;解法一，简单粗暴，典型的递归问题&lt;/h2&gt;
&lt;p&gt;好蠢，超时了。。。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def climbStairs(n):
    if n&amp;lt;=1: return 1
    if n&amp;gt;1:
        return(climbStairs(n-1)+climbStairs(n-2))
    
climbStairs(38)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;63245986
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解法二优化递归&#34;&gt;解法二，优化递归&lt;/h2&gt;
&lt;p&gt;用一个字典记录，极大提升速度，但是内存消耗上去了（事实上不要保存之前的内容，可以考虑优化）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def climbStairs(n):
    dict0 = {}
    dict0[1] = 1
    dict0[2] = 2
    for n in range(3, n+1):   # 这道题事实上是斐波那契数列——前两项求和
        dict0[n] = dict0[n-1]+dict0[n-2]
    #print(dict0)
    return dict0[n]

climbStairs(38)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{1: 1, 2: 2, 3: 3, 4: 5, 5: 8, 6: 13, 7: 21, 8: 34, 9: 55, 10: 89, 11: 144, 12: 233, 13: 377, 14: 610, 15: 987, 16: 1597, 17: 2584, 18: 4181, 19: 6765, 20: 10946, 21: 17711, 22: 28657, 23: 46368, 24: 75025, 25: 121393, 26: 196418, 27: 317811, 28: 514229, 29: 832040, 30: 1346269, 31: 2178309, 32: 3524578, 33: 5702887, 34: 9227465, 35: 14930352, 36: 24157817, 37: 39088169, 38: 63245986}




63245986
&lt;/code&gt;&lt;/pre&gt;
">练习题 DAY1</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1021/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#svm%E5%8E%9F%E7%90%86-%E6%80%9D%E8%B7%AF&#34;&gt;SVM原理 &amp;amp; 思路&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8E%9F%E7%90%86%E5%85%B3%E9%94%AE%E7%82%B9&#34;&gt;原理关键点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%9D%E8%B7%AF&#34;&gt;思路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%B0%E6%8D%AE%E9%9B%86&#34;&gt;数据集&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#smo%E7%AE%97%E6%B3%95&#34;&gt;SMO算法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#why-smo&#34;&gt;why SMO?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%9D%E8%B7%AF-2&#34;&gt;思路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0&#34;&gt;辅助函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%AD%A3%E5%BC%8F%E7%BC%96%E5%86%99&#34;&gt;正式编写&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A8%A1%E5%9E%8B%E6%8B%9F%E5%90%88%E9%A2%84%E6%B5%8B&#34;&gt;模型拟合&amp;amp;预测&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%AF%E8%A7%86%E5%8C%96&#34;&gt;可视化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;SVM——完全线性可分问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/LDASVM-0921/&#34;&gt;之前用sklearn实现过——SVM分析约会数据&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这里尝试手写代码，先从最简单的&lt;strong&gt;完全线性可分问题（硬间隔、线性核函数）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;svm原理-思路&#34;&gt;SVM原理 &amp;amp; 思路&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;原理，具体见笔记本第19-29页&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;原理关键点&#34;&gt;原理关键点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;线性可分：能够找到超平面使得&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;$ y_i(w^T X_i +b ) \geq 1 $&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;原问题和对偶问题&lt;/p&gt;
&lt;p&gt;原问题：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;msup&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;∣&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;min \frac{1}{2} ||w||^2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.190108em;vertical-align:-0.345em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.845108em;&#34;&gt;&lt;span style=&#34;top:-2.6550000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.394em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.345em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;∣&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 限制条件为$ y_i(w^T X_i +b ) \geq 1$&lt;/p&gt;
&lt;p&gt;对偶问题：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;max&lt;/mi&gt;&lt;mo&gt;⁡&lt;/mo&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;min&lt;/mi&gt;&lt;mo&gt;⁡&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\max \limits_{\alpha} \min\limits_{w,b}L(w,b,\alpha)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.638216em;vertical-align:-0.8882159999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.43056em;&#34;&gt;&lt;span style=&#34;top:-2.1em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.7em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop&#34;&gt;max&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.7em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.66786em;&#34;&gt;&lt;span style=&#34;top:-2.0478920000000005em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mpunct mtight&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.7em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop&#34;&gt;min&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8882159999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;问题转化为极大化 $\theta(\alpha) $:&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;θ&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;min&lt;/mi&gt;&lt;mo&gt;⁡&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msub&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;msub&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;⋅&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\theta(\alpha) =  \min\limits_{w,b}L(w,b,\alpha) = \sum \limits_i \alpha_i - \frac{1}{2} \sum \limits_i\sum \limits_j \alpha_i \alpha_j y_i y_j (x_i\cdot x_j)&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;θ&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.638216em;vertical-align:-0.8882159999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.66786em;&#34;&gt;&lt;span style=&#34;top:-2.0478920000000005em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mpunct mtight&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.7em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop&#34;&gt;min&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8882159999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;L&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.727674em;vertical-align:-0.977669em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.750005em;&#34;&gt;&lt;span style=&#34;top:-2.122331em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0000050000000003em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop op-symbol small-op&#34;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.977669em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.958885em;vertical-align:-1.113777em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.845108em;&#34;&gt;&lt;span style=&#34;top:-2.6550000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.394em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.345em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.750005em;&#34;&gt;&lt;span style=&#34;top:-2.122331em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0000050000000003em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop op-symbol small-op&#34;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.977669em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.7500050000000001em;&#34;&gt;&lt;span style=&#34;top:-2.122331em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0000050000000003em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop op-symbol small-op&#34;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.113777em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;⋅&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.036108em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;限制条件 :&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo fence=&#34;true&#34;&gt;{&lt;/mo&gt;&lt;mtable&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;≥&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;mtr&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;mtd&gt;&lt;mstyle scriptlevel=&#34;0&#34; displaystyle=&#34;false&#34;&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mtd&gt;&lt;/mtr&gt;&lt;/mtable&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\left\{\begin{matrix}
 \alpha_i \geq 0 &amp;amp;  &amp;amp; \\ 
 \sum \alpha_i y_i = 0&amp;amp; &amp;amp; 
\end{matrix}\right.&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.40003em;vertical-align:-0.95003em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;&lt;span class=&#34;mopen delimcenter&#34; style=&#34;top:0em;&#34;&gt;&lt;span class=&#34;delimsizing size3&#34;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mtable&#34;&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.61em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≥&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.4099999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mop op-symbol small-op&#34; style=&#34;position:relative;top:-0.0000050000000000050004em;&#34;&gt;∑&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.4499999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.84em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.2499999999999996em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.84em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;arraycolsep&#34; style=&#34;width:0.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;col-align-c&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.45em;&#34;&gt;&lt;span style=&#34;top:-3.4499999999999997em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.84em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.2499999999999996em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.84em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9500000000000004em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;思路&#34;&gt;思路&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;利用SMO算法（序列最小最优化问题）计算&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\alpha_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;预测&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/msup&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;≥&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;/msup&gt;&lt;msub&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mo&gt;&amp;lt;&lt;/mo&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;h&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;w^T X_i +b\geq 0, then 1, w^T X_i +b &amp;lt; 0, then-1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.991331em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8413309999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83041em;vertical-align:-0.13597em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;≥&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.035771em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8413309999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.13889em;&#34;&gt;T&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.73354em;vertical-align:-0.0391em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.64444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可视化，希望画出分割线、margin、支持向量&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据集&#34;&gt;数据集&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np
import matplotlib.pyplot as plt

## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    

## 造数据——一个线性可分的数据集
data_x = np.array([[1.5, 5], [2, 7.5], [3, 5.7], [4, 8], [5, 1], [6, -1], [6.7, 3], [7.5, 0.5]])
x1 = [data_x[i][0] for i in range(data_x.shape[0])]
x2 = [data_x[i][1] for i in range(data_x.shape[0])]
data_y = np.array([[1] * 4 + [-1] * 4]).T
color = [&amp;quot;orange&amp;quot; if c==1 else &amp;quot;dodgerblue&amp;quot; for c in data_y] 
fig = plt.figure(figsize=(6, 4))   # 创建一张画布
plt.scatter(x1, x2, c = color)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603260770442.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;smo算法&#34;&gt;SMO算法&lt;/h1&gt;
&lt;p&gt;利用SMO算法（序列最小最优化问题）计算&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\alpha_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，参考资料&lt;a href=&#34;https://www.bilibili.com/video/BV1bK4y187hG?from=search&amp;amp;seid=14847408062907272488&#34;&gt;快速理解SMO算法&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;why-smo&#34;&gt;why SMO?&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;参数很多——梯度下降（每次对所有参数更新）复杂度太高；由于约束条件的存在，每次调整两个参数，把问题转化为一系列子问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;假定其他alpha固定，只更新&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\alpha_1 \alpha_2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，根据约束条件&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\alpha_2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;可以表示为&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\alpha_1&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.58056em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的函数，优化问题可以有&lt;strong&gt;解析解&lt;/strong&gt;（不用搜索直接计算，其实就是一个&lt;strong&gt;一元二次函数求极值&lt;/strong&gt;的问题，但是要注意极值点是不是在取值的约束内）——速度提升&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;思路-2&#34;&gt;思路&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;参数初始化（0）&lt;/li&gt;
&lt;li&gt;选取两个参数进行优化（其中至少有一个是违背kkt条件的）计算最优解，看最优解是否在取值范围内（剪辑），然后更新参数，并计算更新后的b和Ei&lt;/li&gt;
&lt;li&gt;是否满足停止算法条件（达到迭代次数/参数更新量太小），如果不满足就再次选取两个参数（记录迭代次数）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;辅助函数&#34;&gt;辅助函数&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;计算预测值&lt;br&gt;
$Ei = \sum \alpha&lt;em&gt;y&lt;/em&gt;k +b $&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据取值范围剪辑alpha，看最优解是否在取值范围内（剪辑）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;KKT条件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据强对偶定理有alpha=0或者Ei=0&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;p&gt;计算eta 方便后续更新alpha值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算取值范围上下界&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计算b  &lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mi&gt;b&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;w&lt;/mi&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;b_j^{new} = yj - \sum \alpha_i y_i k_{ij}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.0892119999999998em;vertical-align:-0.394772em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-2.441336em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.02691em;&#34;&gt;w&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.394772em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.85396em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.036108em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-symbol small-op&#34; style=&#34;position:relative;top:-0.0000050000000000050004em;&#34;&gt;∑&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选出第一个变量后随机选择第二个&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 1.计算预测值
def count_Ei(alphas, b, x, xi, y, yi):    
    &#39;&#39;&#39;
    输入的维度：alphas(n,1), b(1,1),x(n,p),xi(1,p),y(n,1)
    &#39;&#39;&#39;
    # 计算xi和其他xj的内积——输出向量(k1i,k2i,...kni)
    ki = np.sum(x*xi, axis = 1) 
    # 计算预测值
    resulti = ki@(alphas*y)+b-yi
    return resulti


### 2.根据取值范围剪辑alpha
def clipAlpha(alpha,L,H):
    if alpha &amp;gt; H: 
        alpha = H
    if L &amp;gt; alpha:
        alpha = L
    return alpha


### 3.定义KKT条件
def match_kkt(alphai, Ei):
    &#39;&#39;&#39;
    输入两个数字，根据强对偶定理有alpha=0或者Ei=0
    &#39;&#39;&#39;
    return ((alphai==0) and (Ei &amp;gt; 1 or Ei &amp;lt; -1)) or ((alphai&amp;gt;0) and (Ei==0))
 
    
### 4.计算η
def count_eta(xi, xj):
    etaij = xi.T@xi + xj.T@xj - 2*xi.T@xj
    return etaij


### 5.计算取值范围上下界
def alpha_LH(alphai, alphaj, yi, yj):
    &#39;&#39;&#39;
    alphaj是更新对象的old值，alphai是另一个对象的old值
    &#39;&#39;&#39;
    if yi==yj:
        Lij = 0
        Hij = max(0, alphai + alphaj)
    else:
        Lij = max(0, alphaj- alphai)
        Hij = 99999      
    return Lij, Hij

### 6.计算b更新后的值
def count_b(alphas, x, y, xj, yj):
    &#39;&#39;&#39;
    输入自变量因变量xy，准备用第j个alpha计算b——需要xj和yj
    &#39;&#39;&#39;
    bj_new = yj - np.sum(x*xj, axis = 1)@(alphas*y)
    return bj_new.tolist()

### 7. 随机选择第二个变量
import random
def selectJrand(i,m):
    j=i 
    while (j==i):
        j = int(random.uniform(0,m))
    return j

# 测试
alphas = np.zeros((data_x.shape[0], 1))
count_Ei(alphas = alphas, b=0, x = data_x, xi = data_x[0], y= data_y, yi = data_y[0])
match_kkt(alphai=0, Ei=1)
count_eta(data_x[0], data_x[1])
count_b(alphas, data_x, data_y, data_x[0], data_y[0])
selectJrand(0,8)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;array([-1.])

False

6.5

[1.0]

2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;正式编写&#34;&gt;正式编写&lt;/h2&gt;
&lt;p&gt;参考统计学习方法（李航）第128-130页&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一步，取出两个alpha&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先for每一个i，（根据当前参数值）计算Ei —&amp;gt;&lt;/li&gt;
&lt;li&gt;判断alphai是否满足kkt条件，如果遇到不满足的就作为第一个变量 —&amp;gt;&lt;/li&gt;
&lt;li&gt;在剩下的里面找一个j作为第二个变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二步，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算alpha j 的最优解&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;msubsup&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mi&gt;η&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;=\alpha_j^{old}+y_j(Ei-Ej)/\eta&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.2438799999999999em;vertical-align:-0.394772em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.849108em;&#34;&gt;&lt;span style=&#34;top:-2.441336em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.01968em;&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.394772em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.036108em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05764em;&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;η&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;、取值范围，再做剪辑，更新alpha j&lt;/li&gt;
&lt;li&gt;如果发现alpha j更新量很少——&lt;strong&gt;回到第一步，重新选择两个alpha&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;else就根据alpha j计算alpha i的值（根据kkt条件等式约束）&lt;/li&gt;
&lt;/ul&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;munder&gt;&lt;mo&gt;∑&lt;/mo&gt;&lt;mrow&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mo&gt;!&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;/mrow&gt;&lt;/munder&gt;&lt;msub&gt;&lt;mi&gt;α&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/msub&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\alpha_i y_i + \alpha_j y_j = -\sum_{k!=i,j} \alpha_k yk
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.7777700000000001em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.31166399999999994em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.716668em;vertical-align:-0.286108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.311664em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.286108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:2.488226em;vertical-align:-1.438221em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mop op-limits&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.050005em;&#34;&gt;&lt;span style=&#34;top:-1.8478869999999998em;margin-left:0em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;mclose mtight&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;mrel mtight&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mpunct mtight&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.0500049999999996em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.05em;&#34;&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&#34;mop op-symbol large-op&#34;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.438221em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.0037em;&#34;&gt;α&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.33610799999999996em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新之后再次计算b 更新b的值&lt;/li&gt;
&lt;li&gt;记录迭代更新次数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;迭代循环上述步骤，限制条件是迭代次数&amp;lt;最大值&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 参数初始化：
n = data_x.shape[0]
alphas = np.zeros((n, 1))
b = 0
iteration=0

while(iteration&amp;lt;=3):
    change = False
    for i in range(n):
        #####   第一步   #####
        # 寻找一个不满足kkt条件的ai
        # 计算Ei，用来判断kkt条件
        Ei = count_Ei(alphas = alphas, b = b, x = data_x, xi = data_x[i], y= data_y, yi = data_y[i])
        if not match_kkt(alphas[i], Ei):    # 如果不满足kkt条件，则继续
            # 从剩下的里面随机选择j
            j = selectJrand(i, n)
            alphaj_old = alphas[j].copy()   # 记录j更新前的数值
            alphai_old = alphas[i].copy() 
            
            #####   第二步   #####
            # 更新alphai alphaj
            alphaj_LH = alpha_LH(alphas[i], alphas[j], data_y[i], data_y[j])  # 计算取值范围
           # if alphaj_LH[0]==alphaj_LH[1]: continue
            Ej = count_Ei(alphas = alphas, b = b, x = data_x, xi = data_x[j], y=data_y,yi = data_y[j])  # 计算Ej
            etaj = count_eta(data_x[i],data_x[j])   # 计算eta
            #if etaj &amp;gt; 0: continue
            alphaj_new = alphaj_old + data_y[j]*(Ei-Ej)/etaj  #计算alphaj最优解
            alphaj_new = clipAlpha(alphaj_new,L = alphaj_LH[0], H = alphaj_LH[1])  # 做剪辑
            # 如果发现更新量大于0.001，后续不用进行
            if (abs(alphaj_new-alphaj_old)&amp;lt;0.001): continue   # 跳出本次循环
            change = True
            alphas[j] = alphaj_new
            
            # 再根据alphaj的值计算alphai
            alphai_new = alphai_old + data_y[i]* data_y[j]*(alphaj_old-alphaj_new)
            alphas[i]  = alphai_new
            
             #####   第三步   #####
            # 更新b
            bi = b-Ei-data_y[i]*(data_x[i]@data_x[i])*(alphai_new-alphai_old)-data_y[j]*(data_x[i]@data_x[j])*(alphaj_new-alphaj_old)
            bj = b-Ej-data_y[i]*(data_x[i]@data_x[j])*(alphai_new-alphai_old)-data_y[j]*(data_x[j]@data_x[j])*(alphaj_new-alphaj_old)
            b = (bi + bj)/2
    if change: iteration = iteration+1
    iteration

### 结果
alphas,b
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1

2

3

4   

 (array([[0.        ],
        [0.        ],
        [0.09610824],
        [0.        ],
        [0.0115309 ],
        [0.        ],
        [0.08457734],
        [0.        ]]), array([0.39743575]))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;模型拟合预测&#34;&gt;模型拟合&amp;amp;预测&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 定义预测函数
def SVM_pred(train_x, train_y, test_x, alphas, b):
    test_pred = []
    test_decision = []
    for i in range(len(test_x)):
        tmp = np.sum(train_x*test_x[i], axis = 1) @(alphas * train_y) + b
        test_pred.append(tmp)
        if tmp &amp;gt;= 0 :
            tmp = 1
        if tmp &amp;lt; 0 :
            tmp = -1
        test_decision.append(tmp)
    return test_pred,test_decision

# 对于训练集上的拟合值
train_pred, train_decision = SVM_pred(data_x,data_y,data_x,alphas,b)
train_pred
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[array([1.3062091]),
 array([1.84459527]),
 array([1.]),
 array([1.31387637]),
 array([-1.]),
 array([-1.90110608]),
 array([-1.00608842]),
 array([-1.98127194])]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;根据拟合结果可以看出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;样本3和样本5、7 为支持向量，接下来考虑可视化&lt;/p&gt;
&lt;h1 id=&#34;可视化&#34;&gt;可视化&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;分类界限：用测试数据的背景点表示&lt;/li&gt;
&lt;li&gt;支持向量：用三角形表示&lt;/li&gt;
&lt;li&gt;margin：通过测试数据画出来&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;xx1, xx2 = np.meshgrid(np.arange(-2, 10, 0.1), np.arange(-2, 10, 0.1))   # 生成自变量的数据
test_xx = [[xx1.ravel()[i],xx2.ravel()[i]] for i in range(len(xx1.ravel()))]
yy_pred,yy_decision = SVM_pred(data_x,data_y,test_xx, alphas, b)

fig = plt.figure(figsize=(7, 6))   # 创建一张画布
# 背景网格点
color = [&amp;quot;#e2a653&amp;quot; if c==1 else &amp;quot;#6cabe6&amp;quot; for c in yy_decision] 
for i in range(len(yy_pred)):
    if abs(abs(yy_pred[i])-1)&amp;lt;0.01:
        color[i] = &amp;quot;black&amp;quot;

plt.scatter(xx1, xx2, c = color, alpha = 0.35, marker= &amp;quot;.&amp;quot;,s = 10)
# 原始数据的点
color = [&amp;quot;orange&amp;quot; if c==1 else &amp;quot;dodgerblue&amp;quot; for c in data_y] 
markers = [&amp;quot;v&amp;quot; if abs((abs(m)-1))&amp;lt;0.01 else &amp;quot;s&amp;quot; for m in train_pred]
size = [150 if abs((abs(m)-1))&amp;lt;0.01 else 30 for m in train_pred]
[plt.scatter(x1[i], x2[i], c = color[i], marker = markers[i], s =size[i]) for i in range(len(color))]
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603262195592.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">手动实现——SVM（线性可分问题）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/xi-lie-leetcode-shua-ti-bi-ji/"" data-c="
          &lt;p&gt;慢慢来&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;第一步热门简单题&#34;&gt;第一步：热门简单题&lt;/h2&gt;
&lt;p&gt;地址：&lt;a href=&#34;https://leetcode-cn.com/problemset/algorithms/?difficulty=%E7%AE%80%E5%8D%95&amp;amp;listId=2cktkvj&#34;&gt;热门题目&amp;amp;简单题 23道&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py1022/&#34;&gt;DAY 1 (2020年10月22日）&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;【1】两数之和——字典查找&lt;/li&gt;
&lt;li&gt;【20】有效的括号——栈&lt;/li&gt;
&lt;li&gt;【21】合并两个有序链表——递归&lt;/li&gt;
&lt;li&gt;【53】最大子序和——动态规划&lt;/li&gt;
&lt;li&gt;【70】爬楼梯——递归&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py1026/&#34;&gt;DAY 2 (2020年10月26日）&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;【101】对称二叉树——递归&lt;/li&gt;
&lt;li&gt;【104】二叉树的最大深度——递归&lt;/li&gt;
&lt;li&gt;【121】买卖股票的最佳时机——遍历&lt;/li&gt;
&lt;li&gt;【136】只出现一次的数字——“异或”&lt;/li&gt;
&lt;li&gt;【141】环形链表——快慢指针&lt;/li&gt;
&lt;li&gt;【155】最小栈——辅助栈&lt;/li&gt;
&lt;li&gt;【169】多数元素——投票法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py1102/&#34;&gt;DAY 3 (2020年11月02日）&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;【198】打家劫舍——动态规划&lt;/li&gt;
&lt;li&gt;【206】反转链表——链表&lt;/li&gt;
&lt;li&gt;【226】翻转二叉树——二叉树&lt;/li&gt;
&lt;li&gt;【234】回文链表——链表&lt;/li&gt;
&lt;li&gt;【283】移动零&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py1125/&#34;&gt;DAY 4 (2020年11月25日）&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;【448】找到消失的数字&lt;/li&gt;
&lt;li&gt;【461】汉明距离&lt;/li&gt;
&lt;li&gt;【543】二叉树直径&lt;/li&gt;
&lt;li&gt;【617】合并二叉树&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;后面计划按照主题来做，顺便把之前学的复习一遍，尤其是各种排序&lt;/p&gt;
&lt;h2 id=&#34;第二步剑指offer&#34;&gt;第二步：剑指offer&lt;/h2&gt;
&lt;p&gt;地址：&lt;a href=&#34;https://leetcode-cn.com/problemset/lcof/&#34;&gt;剑指offer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py1125/&#34;&gt;DAY 4 (2020年11月25日）&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;剑指 Offer 03 数组中重复的数字&lt;/li&gt;
&lt;li&gt;剑指 Offer 05. 替换空格&lt;/li&gt;
&lt;li&gt;剑指 Offer 06. 从尾到头打印链表&lt;/li&gt;
&lt;li&gt;剑指 Offer 09. 用两个栈实现队列&lt;/li&gt;
&lt;li&gt;剑指 Offer 10 经典递归&lt;/li&gt;
&lt;li&gt;剑指 Offer 11. 旋转数组的最小数字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py1126/&#34;&gt;DAY 5 (2020年11月26日）&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;剑指 Offer 15. 二进制中1的个数&lt;/li&gt;
&lt;li&gt;剑指 Offer 18. 删除链表的节点&lt;/li&gt;
&lt;li&gt;剑指 Offer 21. 调整数组顺序使奇数位于偶数前面&lt;/li&gt;
&lt;li&gt;剑指 Offer 22. 链表中倒数第k个节点&lt;/li&gt;
&lt;li&gt;剑指 Offer 24. 反转链表&lt;/li&gt;
&lt;li&gt;剑指 Offer 25. 合并两个排序的链表&lt;/li&gt;
&lt;li&gt;剑指 Offer 27. 二叉树的镜像&lt;/li&gt;
&lt;li&gt;剑指 Offer 28. 对称的二叉树&lt;/li&gt;
&lt;li&gt;剑指 Offer 29. 顺时针打印矩阵——递归
&lt;ul&gt;
&lt;li&gt;第一步，p维矩阵&lt;/li&gt;
&lt;li&gt;第二步，m x n 维矩阵&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;剑指 Offer 30. 包含min函数的栈——栈&lt;/li&gt;
&lt;li&gt;剑指 Offer 32 打印二叉树——迭代
&lt;ol&gt;
&lt;li&gt;从上到下、每一层从左到右&lt;/li&gt;
&lt;li&gt;每一层打印到一行&lt;/li&gt;
&lt;li&gt;之字形顺序打印二叉树&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;剑指 Offer 39. 出现次数超过一半的数字——字典&lt;/li&gt;
&lt;li&gt;剑指 Offer 40. 最小的k个数——堆排序&lt;/li&gt;
&lt;li&gt;剑指 Offer 42. 连续子数组的最大和——动态规划&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py1129/&#34;&gt;DAY 6 (2020年11月29日）&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;剑指 Offer 50. 第一个只出现一次的字符&lt;/li&gt;
&lt;li&gt;剑指 Offer 52. 两个链表的第一个公共节点&lt;/li&gt;
&lt;li&gt;剑指 Offer 53 - I. 在排序数组中查找数字 I&lt;/li&gt;
&lt;li&gt;剑指 Offer 53 - II. 0～n-1中缺失的数字&lt;/li&gt;
&lt;li&gt;剑指 Offer 54. 二叉搜索树的第k大节点&lt;br&gt;
&lt;strong&gt;二叉搜索树的遍历问题&lt;/strong&gt;：递归解法+迭代解法&lt;/li&gt;
&lt;li&gt;剑指 Offer 55 - II. 平衡二叉树&lt;/li&gt;
&lt;li&gt;剑指 Offer 56 数组中出现数字的次数&lt;/li&gt;
&lt;li&gt;剑指 Offer 57. 和为某个数字
&lt;ol&gt;
&lt;li&gt;找出和为X的两个数字&lt;/li&gt;
&lt;li&gt;找出所有和为s的连续正数序列&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;剑指 Offer 58 - I. 翻转单词顺序&lt;/li&gt;
&lt;li&gt;剑指 Offer 58 - II. 左旋转字符串&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py1201/&#34;&gt;DAY 7 (2020年12月01日）&lt;/a&gt;&lt;br&gt;
这部分是剑指offer中等难度的，需要复习哟~&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;剑指 Offer 59. 滑动窗口的最大值——&lt;strong&gt;队列维护最大值的index&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;剑指 Offer 61. 扑克牌中的顺子&lt;/li&gt;
&lt;li&gt;剑指 Offer 62. 圆圈中最后剩下的数字——队列&lt;/li&gt;
&lt;li&gt;剑指 Offer 63. 股票的最大利润&lt;/li&gt;
&lt;li&gt;剑指 Offer 68 - 二叉树的最近公共祖先——递归&lt;/li&gt;
&lt;li&gt;剑指 Offer 04. 二维数组中的查找——查找
&lt;ol&gt;
&lt;li&gt;逐行二分法，其实效率也还不错&lt;/li&gt;
&lt;li&gt;转化为图问题&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;剑指 Offer 07. 重建二叉树——递归&lt;/li&gt;
&lt;li&gt;剑指 Offer 12. 矩阵中的路径——图DFS问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;————————————————————————&lt;br&gt;
算法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础技巧：分治、二分、贪心&lt;/li&gt;
&lt;li&gt;排序算法：快速排序、归并排序、计数排序&lt;/li&gt;
&lt;li&gt;搜索算法：回溯、递归、深度优先遍历，广度优先遍历，二叉搜索树等&lt;/li&gt;
&lt;li&gt;图论：最短路径、最小生成树&lt;/li&gt;
&lt;li&gt;动态规划：背包问题、最长子序列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组与链表：单 / 双向链表&lt;/li&gt;
&lt;li&gt;栈与队列&lt;/li&gt;
&lt;li&gt;哈希表&lt;/li&gt;
&lt;li&gt;堆：最大堆 ／ 最小堆&lt;/li&gt;
&lt;li&gt;树与图：最近公共祖先、并查集&lt;/li&gt;
&lt;li&gt;字符串：前缀树（字典树） ／ 后缀树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;补充&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 Rand7() 实现 Rand10()&lt;/li&gt;
&lt;/ul&gt;
">【系列】leetcode笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1020/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#1%E9%80%9A%E7%94%A8%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2&#34;&gt;1.通用的深度优先搜索&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F&#34;&gt;2.拓扑排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E6%94%AF&#34;&gt;3.强连通分支&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%BE%E7%9A%84%E8%BD%AC%E7%BD%AE&#34;&gt;图的转置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#kosaraju-%E7%AE%97%E6%B3%95&#34;&gt;Kosaraju 算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E5%B8%A6%E6%9D%83%E9%87%8D&#34;&gt;4.最短路径问题（带权重）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#dijkstra&#34;&gt;DIJKSTRA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91&#34;&gt;5.最小生成树&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%AB%E4%B9%89&#34;&gt;含义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#prim&#34;&gt;Prim&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;1通用的深度优先搜索&#34;&gt;1.通用的深度优先搜索&lt;/h1&gt;
&lt;p&gt;vertex增加两个属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;discovery 发现时间，第几步访问到并被设置为灰色&lt;/li&gt;
&lt;li&gt;finish 结束时间，第几步结束探索并被设置为黑色&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;graph 增加一个属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;time 记录算法执行的步骤&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;方法：类的继承 super&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class DFSGraph(Graph): 
    def __init__(self):
        super().__init__()   # 继承graph里init里的属性
        self.time = 0        # 新增属性 time
    
    def dfs(self):
        for aVertex in self:
            aVertex.setColor(&#39;white&#39;)
            aVertex.setPred(-1)   # 设置前驱顶点
        for aVertex in self:
            if aVertex.color==&amp;quot;white&amp;quot;:
                self.dfsvisit(aVertex)   # 递归调用
    
    def dfsvisit(self, startVertex):
        # 开始探索
        startVertex.setColor(&amp;quot;grey&amp;quot;)  
        self.time += 1
        startVertex.setDiscovery(self.time)    # 记录开始的时间
        for nextVertex in startVertex.getConnections():
            if nextVertex.color==&amp;quot;white&amp;quot;:     # 对于没有发现过的新顶点
                nextVertex.setPred(startVertex)  # 设置前驱
                self.dfsvisit(nextVertex)        # 递归调用
        
        # 结束探索
        startVertex.setColor(&#39;black&#39;)
        self.time += 1
        startVertex.setFinish(self.time)     # 记录结束时间

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;2拓扑排序&#34;&gt;2.拓扑排序&lt;/h1&gt;
&lt;p&gt;从“工作流程图”到“工作次序排列”的算法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;图建立：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工作项——节点；工作流程——图&lt;/li&gt;
&lt;li&gt;一个DAG（有向无圈图【否则循环依赖】），输出顶点的线性序列&lt;/li&gt;
&lt;li&gt;要求存在边(v,w)，则线性序列中v在w之前&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现——深度优先搜索DFS&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;3强连通分支&#34;&gt;3.强连通分支&lt;/h1&gt;
&lt;p&gt;发现高度聚集节点群&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图G的子集C，任意两个顶点之间都有路径来回——C是具有这样性质的最大子集&lt;/li&gt;
&lt;li&gt;找到之后可以对顶点分类合并——简化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;图的转置&#34;&gt;图的转置&lt;/h2&gt;
&lt;p&gt;图的转置代表把图所有有向边的顶点交换次序——图和转置图的强连通分支没有变&lt;/p&gt;
&lt;h2 id=&#34;kosaraju-算法&#34;&gt;Kosaraju 算法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;首先调用通用DFS计算结束时间&lt;/li&gt;
&lt;li&gt;对图进行转置，再调用DFS计算，每个顶点的搜索循环按照上一步计算的结束时间倒序来搜索&lt;/li&gt;
&lt;li&gt;生成深度优先森林，每一棵树都是一个强连通分支&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;4最短路径问题带权重&#34;&gt;4.最短路径问题（带权重）&lt;/h1&gt;
&lt;p&gt;例子：&lt;strong&gt;路由器连接的网络&lt;/strong&gt;，负责把信息传递，终端试试“traceroute www....”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶点：路由器；边：网络连接；权重：速度、负载程度、优先级等等因素抽象为权重&lt;/li&gt;
&lt;li&gt;权重越高，代价越高，希望找到代价最小的路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dijkstra&#34;&gt;DIJKSTRA&lt;/h2&gt;
&lt;p&gt;一个确定的开始节点到所有图中其他节点的最短路径&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;顶点Vertex类中使用dist 作为实例变量，包含从起点到目的节点的最小权值路线的当前总权值。&lt;/li&gt;
&lt;li&gt;各顶点先后顺序是由一个优先队列控制的，队列中决定顺序的参量是dist值，初始dist尽可能的大&lt;/li&gt;
&lt;li&gt;每次最低dist的顶点优先pop出来，计算权重会引起dist的减小——重排&lt;/li&gt;
&lt;li&gt;重复上述，每一个节点，算法均会重复一次&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pythonds import PriorityQueue, Graph, Vertex

# 最短路径
# G - 无向赋权图
# start - 开始节点
# 返回从开始节点到其它所有节点的最短带权路径
def dijkstra(G, start):
    pq = PriorityQueue()  # 创建优先队列
    start.setDistance(0)  # 起点距离设置为0，其它节点距离默认maxsize
    # 将节点排入优先队列，start在最前面
    pq.buildHeap([(v.getDistance(), v) for v in G])
    while not pq.isEmpty():
        # 取从start开始距离最小的节点出队列，作为当前节点
        # 当前节点已解出最短路径
        currentVert = pq.delMin()
        # 遍历节点的所有邻接节点
        for nextVert in currentVert.getConnections():
            # 从当前节点出发，逐个加上邻接节点的距离进行检验
            newDist = currentVert.getDistance() \
                      + currentVert.getWeight(nextVert)
            # 如果小于邻接节点原有距离，就更新邻接节点
            #print(&amp;quot;{}，原距离 = {}，新距离 = {}&amp;quot;.format(nextVert.getId(), newDist, nextVert.getDistance()))
            if newDist &amp;lt; nextVert.getDistance():
                # 更新距离值
                nextVert.setDistance(newDist)
                # 更新返回路径
                nextVert.setPred(currentVert)
                # 更新优先队列
                pq.decreaseKey(nextVert, newDist)

                
G = Graph()
ndedge = [(&#39;u&#39;, &#39;v&#39;, 2), (&#39;u&#39;, &#39;w&#39;, 5), (&#39;u&#39;, &#39;x&#39;, 1),  # 边和权重
          (&#39;v&#39;, &#39;x&#39;, 2), (&#39;v&#39;, &#39;w&#39;, 3), (&#39;x&#39;, &#39;w&#39;, 3),
          (&#39;x&#39;, &#39;y&#39;, 1), (&#39;w&#39;, &#39;y&#39;, 1), (&#39;w&#39;, &#39;z&#39;, 5),
          (&#39;y&#39;, &#39;z&#39;, 1)]
for nd in ndedge:
    G.addEdge(nd[0], nd[1], nd[2])
    G.addEdge(nd[1], nd[0], nd[2])
start = G.getVertex(&#39;u&#39;)       # 从u开始
dijkstra(G, start)                # 计算从u开始最短路径的权重和

for i in G.getVertices():
    print(G.getVertex(i))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;u:color white:disc 0:fin 0:dist 0:pred 
	[None]

v:color white:disc 0:fin 0:dist 2:pred 
	[u:color white:disc 0:fin 0:dist 0:pred 
	[None]
]

w:color white:disc 0:fin 0:dist 3:pred 
	[y:color white:disc 0:fin 0:dist 2:pred 
	[x:color white:disc 0:fin 0:dist 1:pred 
	[u:color white:disc 0:fin 0:dist 0:pred 
	[None]
]
]
]

x:color white:disc 0:fin 0:dist 1:pred 
	[u:color white:disc 0:fin 0:dist 0:pred 
	[None]
]

y:color white:disc 0:fin 0:dist 2:pred 
	[x:color white:disc 0:fin 0:dist 1:pred 
	[u:color white:disc 0:fin 0:dist 0:pred 
	[None]
]
]

z:color white:disc 0:fin 0:dist 3:pred 
	[y:color white:disc 0:fin 0:dist 2:pred 
	[x:color white:disc 0:fin 0:dist 1:pred 
	[u:color white:disc 0:fin 0:dist 0:pred 
	[None]
]
]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;5最小生成树&#34;&gt;5.最小生成树&lt;/h1&gt;
&lt;p&gt;信息广播问题，希望覆盖到所有顶点，同时总费用最少&lt;/p&gt;
&lt;h2 id=&#34;含义&#34;&gt;含义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;生成树：拥有图中所有的顶点和最少的边，仍然保持连通的子图&lt;/li&gt;
&lt;li&gt;最小生成树：包含图G(v,e)的所有顶点v和E的无圈子集，并且边权重和最小。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;prim&#34;&gt;Prim&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;贪心算法&lt;/strong&gt; 每一步都沿着权重最小的边前进搜索，如果还不是生成树则——添加一条最小权重的可以安全添加的边&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可以安全添加的边&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from pythonds import PriorityQueue, Graph, Vertex
 
# 最小生成树prim算法
# G - 无向赋权图
# start - 开始节点
# 返回从开始节点创建最小生成树
def prim(G, start):
    pq = PriorityQueue()  # 创建优先队列
    start.setDistance(0)  # 起点最小权重代价设置为0，其它节点最小权重代价默认maxsize
    # 将节点排入优先队列，start在最前面
    pq.buildHeap([(v.getDistance(), v) for v in G])
    while not pq.isEmpty():
        # 取距离*已有树*最小权重代价的节点出队列，作为当前节点
        # 当前节点已解出最小生成树的前驱pred和对应最小权重代价dist
        currentVert = pq.delMin()
        # 遍历节点的所有邻接节点
        for nextVert in currentVert.getConnections():
            # 从当前节点出发，逐个检验到邻接节点的权重
            newCost = currentVert.getWeight(nextVert)
            print((nextVert.id), end = &amp;quot; &amp;quot;)
            # 如果邻接节点是&amp;quot;安全边&amp;quot;，并且小于邻接节点原有最小权重代价dist，就更新邻接节点
            if nextVert in pq and newCost &amp;lt; nextVert.getDistance():
                # 更新最小权重代价dist
                nextVert.setPred(currentVert)
                # 更新返回路径
                nextVert.setDistance(newCost)
                # 更新优先队列
                pq.decreaseKey(nextVert, newCost)
                print((nextVert.id, newCost))

G = Graph()
ndedge = [(&#39;A&#39;, &#39;B&#39;, 2), (&#39;A&#39;, &#39;C&#39;, 3), (&#39;B&#39;, &#39;C&#39;, 1),
          (&#39;B&#39;, &#39;D&#39;, 1), (&#39;B&#39;, &#39;E&#39;, 4), (&#39;C&#39;, &#39;F&#39;, 5),
          (&#39;D&#39;, &#39;E&#39;, 1), (&#39;E&#39;, &#39;F&#39;, 1), (&#39;F&#39;, &#39;G&#39;, 1)]
for nd in ndedge:
    G.addEdge(nd[0], nd[1], nd[2])
    G.addEdge(nd[1], nd[0], nd[2])
start = G.getVertex(&#39;A&#39;)
prim(G, start) 
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603164078677.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;B (&#39;B&#39;, 2)
C (&#39;C&#39;, 3)
A C (&#39;C&#39;, 1)
D (&#39;D&#39;, 1)
E (&#39;E&#39;, 4)
A B F (&#39;F&#39;, 5)
B E (&#39;E&#39;, 1)
B D F (&#39;F&#39;, 1)
C E G (&#39;G&#39;, 1)
F 
&lt;/code&gt;&lt;/pre&gt;
">图——其他算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py10.19/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#knn%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0&#34;&gt;knn算法实现&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86&#34;&gt;数据预处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E8%AE%AD%E7%BB%83%E9%9B%86%E4%B8%8E%E7%BB%99%E5%87%BA%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%B7%9D%E7%A6%BB&#34;&gt;定义函数——计算训练集与给出实例的距离&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E6%8A%95%E7%A5%A8%E7%BB%99%E5%87%BA%E5%AE%9E%E4%BE%8B%E9%A2%84%E6%B5%8B%E7%B1%BB%E5%88%AB&#34;&gt;定义函数——投票给出实例预测类别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%80%89%E5%8F%96%E6%9C%80%E4%BC%98k%E5%80%BC&#34;&gt;选取最优k值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%AF%E8%A7%86%E5%8C%96%E4%B8%8D%E5%90%8Ck%E4%B8%8B%E7%9A%84%E7%BB%93%E6%9E%9C&#34;&gt;可视化不同k下的结果&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;knn算法实现&#34;&gt;knn算法实现&lt;/h1&gt;
&lt;p&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义函数——计算训练集各数据与给出实例的距离&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义函数——投票规则&lt;br&gt;
根据最近的k个训练数据——投票得到新实例的类别&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义函数——交叉验证选择最佳k值&lt;/p&gt;
&lt;p&gt;一般可以先根据样本量来选择k值范围，最后交叉验证取预测率最高的k值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可视化不同k带来的影响&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据预处理&#34;&gt;数据预处理&lt;/h2&gt;
&lt;p&gt;和之前一样，直接复制&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    
## 不显示warnings
import warnings
warnings.filterwarnings(&amp;quot;ignore&amp;quot;)

# font_manager函数，用于指定中文字体样式、大小
import matplotlib.font_manager as mfm
font_path = r&amp;quot;/Users/mac/Library/Fonts/字体管家方萌简（非商业使用）v1.1.ttf&amp;quot;
prop = mfm.FontProperties(fname = font_path)

## 读入数据
os.chdir(&amp;quot;/Users/mac/Desktop/快乐研一/python/机器学习python实现&amp;quot;)
dating = pd.read_csv(&amp;quot;Speed Dating Data.csv&amp;quot;, encoding = &amp;quot;gbk&amp;quot;)

## 提取变量——是否接受dec（因变量0-1）、好感度like、吸引力attr
dating = dating[[&#39;like&#39;,&#39;attr&#39;,&#39;dec&#39;]]
dating.head()

## 缺失问题
dating.isnull().sum(axis=0)  # 缺失比例
dating.dropna(axis = 0, how=&#39;any&#39;, thresh = None, subset = None, inplace=True)   # omit na值
print(&amp;quot;去掉缺失之后总样本量{}&amp;quot;.format(len(dating)))

## 分为训练集和测试集
sample = np.random.choice(range(len(dating)), int(len(dating)*0.8), replace= False).tolist()
dating_train = dating.iloc[sample, :]
dating_test = dating.iloc[[x for x in range(len(dating)) if x not in sample], :]
print(&amp;quot;训练集样本量 = {}, 测试集样本量 = {}&amp;quot;.format(len(dating_train),len(dating_test)))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;去掉缺失之后总样本量8122
训练集样本量 = 6497, 测试集样本量 = 1625
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;定义函数计算训练集与给出实例的距离&#34;&gt;定义函数——计算训练集与给出实例的距离&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第i和第j样本的L2距离：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msqrt&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;/msub&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;/mrow&gt;&lt;/msqrt&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\sqrt{(x_{(i)}-x_{(j)})(x_{(i)}-x_{(j)})&amp;#x27;}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.24em;vertical-align:-0.3575999999999999em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord sqrt&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8824000000000001em;&#34;&gt;&lt;span class=&#34;svg-align&#34; style=&#34;top:-3.2em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.2em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34; style=&#34;padding-left:1em;&#34;&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.34480000000000005em;&#34;&gt;&lt;span style=&#34;top:-2.5198em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mopen mtight&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose mtight&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3551999999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.34480000000000005em;&#34;&gt;&lt;span style=&#34;top:-2.5198em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mopen mtight&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose mtight&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3551999999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.34480000000000005em;&#34;&gt;&lt;span style=&#34;top:-2.5198em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mopen mtight&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;mclose mtight&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3551999999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.34480000000000005em;&#34;&gt;&lt;span style=&#34;top:-2.5198em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mopen mtight&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;mclose mtight&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3551999999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.6778919999999999em;&#34;&gt;&lt;span style=&#34;top:-2.9890000000000003em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.8424000000000005em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3.2em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;hide-tail&#34; style=&#34;min-width:1.02em;height:1.28em;&#34;&gt;&lt;svg width=&#39;400em&#39; height=&#39;1.28em&#39; viewBox=&#39;0 0 400000 1296&#39; preserveAspectRatio=&#39;xMinYMin slice&#39;&gt;&lt;path d=&#39;M263,681c0.7,0,18,39.7,52,119c34,79.3,68.167,
158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120c340,-704.7,510.7,-1060.3,512,-1067
c4.7,-7.3,11,-11,19,-11H40000v40H1012.3s-271.3,567,-271.3,567c-38.7,80.7,-84,
175,-136,283c-52,108,-89.167,185.3,-111.5,232c-22.3,46.7,-33.8,70.3,-34.5,71
c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1s-109,-253,-109,-253c-72.7,-168,-109.3,
-252,-110,-252c-10.7,8,-22,16.7,-34,26c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26
s76,-59,76,-59s76,-60,76,-60z M1001 80H40000v40H1012z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.3575999999999999em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;输入：训练集用矩阵输入X (n,p)，测试集用向量输入x(1,p)&lt;/li&gt;
&lt;li&gt;输出：距离向量dist(1,n) 表示每个训练集样本点与实例的距离&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def L2_Distance(example, train):
    dist = train-example              # 训练集的每一行都减掉实例
    dist_ = np.square(dist)           # 每个元素求平方
    l2dist = np.sqrt(dist_.sum(axis = 1))      # 按行相加后开根号
    return l2dist.tolist()

example = dating_test.iloc[0,:].tolist()
dating_dist = L2_Distance(example[:2], dating_train[[&#39;like&#39;,&#39;attr&#39;]])
np.max(dating_dist),np.min(dating_dist)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(9.219544457292887, 0.0)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;定义函数投票给出实例预测类别&#34;&gt;定义函数——投票给出实例预测类别&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def prediction(example, train, ylabel, k):
    &#39;&#39;&#39;
    输入：example（没有类别变量），train，ylabel（标识train类别变量），k（用k个投票）
    输出：投票结果
    &#39;&#39;&#39;
    # 提取自变量和因变量
    xlabel = [x for x in train.columns.tolist() if x!=ylabel]  
    train_x = train[xlabel]
    train_y = np.array(train[ylabel])
    # 取出k个最近样本点的类别结果
    dist = L2_Distance(example, train_x)   # 计算distance
    labels = train_y[np.argsort(dist)]  # 距离按大小排序
    labels_k = labels[0:k]   # 提取k个最近的
    # 计算投票结果
    results = labels_k.sum()/k   
    if results&amp;gt;=0.5:
        return 1
    else: 
        return 0
    

# 测试1
example = dating_test.iloc[0, ]
example[&#39;like&#39;] = 9.0; example[&#39;attr&#39;] = 10.0; 
print(&amp;quot;测试数据1：\n{}，预测结果{}\n&amp;quot;.format(example[:2], prediction(example[:2], dating_train,&amp;quot;dec&amp;quot;, 30)))

# 测试2
example[&#39;like&#39;] = 5.0; example[&#39;attr&#39;] = 4.0;
print(&amp;quot;测试数据2：\n{}，预测结果{}\n&amp;quot;.format(example[:2], prediction(example[:2], dating_train,&amp;quot;dec&amp;quot;, 30)))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;测试数据1：
like     9.0
attr    10.0
Name: 0, dtype: float64，预测结果1

测试数据2：
like    5.0
attr    4.0
Name: 0, dtype: float64，预测结果0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;选取最优k值&#34;&gt;选取最优k值&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;交叉验证计算验证集上——平均预测准确率&lt;/li&gt;
&lt;li&gt;遍历k值可能取值选择预测最好的&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def cv_accuracy(train, ylabel, klist, num_fold = 5):
    # 划分训练、验证集
    data_split = np.array_split(train, num_fold)
    xlabel = [x for x in train.columns.tolist() if x!=ylabel]  
    accuracy_k = []
    for k in klist:
        mean_accuracy = []
        for fold in range(num_fold):      # n折交叉验证
            # 处理数据格式
            data_dev = data_split[fold]   # 一份作为验证集
            data_dev_x = data_dev[xlabel] # 去掉因变量
            data_train = np.concatenate(data_split[:fold] + data_split[fold+1:])   # 其他合并为训练集
            data_train = pd.DataFrame(data_train)
            data_train.columns = train.columns
            data_dev_pred = []
            # 计算结果
            for i in range(data_dev_x.shape[0]):
                predi = prediction(data_dev_x.iloc[i,:], data_train, ylabel, k)
                data_dev_pred.append(predi)
            print(&amp;quot;进行到k = {} 时的第{}次交叉验证&amp;quot;.format(k, fold+1))
            accuracy = (data_dev_pred==data_dev[ylabel]).mean()
            mean_accuracy.append(accuracy)
        print(&amp;quot;k = {}, 验证集平均预测正确率 = {}&amp;quot;.format(k, np.mean(mean_accuracy)))
        accuracy_k.append(np.mean(mean_accuracy))
    return accuracy_k

# 测试：
cv_accuracy(dating_train, &#39;dec&#39;, [1, 5, 10, 30, 50, 100, 300, 500, 3000], num_fold = 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;进行到k = 1 时的第1次交叉验证
进行到k = 1 时的第2次交叉验证
进行到k = 1 时的第3次交叉验证
进行到k = 1 时的第4次交叉验证
进行到k = 1 时的第5次交叉验证
k = 1, 验证集平均预测正确率 = 0.6761536092852489
进行到k = 5 时的第1次交叉验证
进行到k = 5 时的第2次交叉验证
进行到k = 5 时的第3次交叉验证
进行到k = 5 时的第4次交叉验证
进行到k = 5 时的第5次交叉验证
k = 5, 验证集平均预测正确率 = 0.7180248712027003
进行到k = 10 时的第1次交叉验证
进行到k = 10 时的第2次交叉验证
进行到k = 10 时的第3次交叉验证
进行到k = 10 时的第4次交叉验证
进行到k = 10 时的第5次交叉验证
k = 10, 验证集平均预测正确率 = 0.7392647598744595
进行到k = 30 时的第1次交叉验证
进行到k = 30 时的第2次交叉验证
进行到k = 30 时的第3次交叉验证
进行到k = 30 时的第4次交叉验证
进行到k = 30 时的第5次交叉验证
k = 30, 验证集平均预测正确率 = 0.7503458281518328
进行到k = 50 时的第1次交叉验证
进行到k = 50 时的第2次交叉验证
进行到k = 50 时的第3次交叉验证
进行到k = 50 时的第4次交叉验证
进行到k = 50 时的第5次交叉验证
k = 50, 验证集平均预测正确率 = 0.759887724284953
进行到k = 100 时的第1次交叉验证
进行到k = 100 时的第2次交叉验证
进行到k = 100 时的第3次交叉验证
进行到k = 100 时的第4次交叉验证
进行到k = 100 时的第5次交叉验证
k = 100, 验证集平均预测正确率 = 0.7578870136791614
进行到k = 300 时的第1次交叉验证
进行到k = 300 时的第2次交叉验证
进行到k = 300 时的第3次交叉验证
进行到k = 300 时的第4次交叉验证
进行到k = 300 时的第5次交叉验证
k = 300, 验证集平均预测正确率 = 0.7605033457689346
进行到k = 500 时的第1次交叉验证
进行到k = 500 时的第2次交叉验证
进行到k = 500 时的第3次交叉验证
进行到k = 500 时的第4次交叉验证
进行到k = 500 时的第5次交叉验证
k = 500, 验证集平均预测正确率 = 0.7632748267898384
进行到k = 3000 时的第1次交叉验证
进行到k = 3000 时的第2次交叉验证
进行到k = 3000 时的第3次交叉验证
进行到k = 3000 时的第4次交叉验证
进行到k = 3000 时的第5次交叉验证
k = 3000, 验证集平均预测正确率 = 0.7601971931071239





[0.6761536092852489,
 0.7180248712027003,
 0.7392647598744595,
 0.7503458281518328,
 0.759887724284953,
 0.7578870136791614,
 0.7605033457689346,
 0.7632748267898384,
 0.7601971931071239]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;可视化不同k下的结果&#34;&gt;可视化不同k下的结果&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def plot_knn_k(k):
    # 1.生成网格点数据
    xx1, xx2 = np.meshgrid(np.arange(0, 10, 0.15), np.arange(0, 10, 0.15))   # 生成自变量的数据
    xx = pd.DataFrame({&#39;like&#39;:xx1.ravel(),&#39;attr&#39;:xx2.ravel()})                         # 拉直后合并为df 
    yy_pred_ = []   # 预测
    for i in range(len(xx)):
        yy_pred_.append(prediction(xx.iloc[i,], dating_train, &amp;quot;dec&amp;quot;, k))                         
    yy_pred = np.array(yy_pred_).reshape(xx1.shape)                  # reshape为网格/矩阵
    
    # 2.画图
    fig = plt.figure(figsize=(8,7))   # 创建一张8*6的画布
    # 2.1背景网格点
    color = [&amp;quot;red&amp;quot; if c==1 else &amp;quot;#6cabe6&amp;quot; for c in yy_pred_] 
    plt.scatter(xx1, xx2, c = color, alpha = 0.4, marker= &amp;quot;.&amp;quot;)
    
    # 2.2原始数据的点
    color = [&amp;quot;red&amp;quot; if c==1 else &amp;quot;dodgerblue&amp;quot; for c in dating[&#39;dec&#39;]] 
    plt.scatter(dating[&#39;like&#39;],dating[&#39;attr&#39;], c=color, marker= &amp;quot;s&amp;quot;)

    # 3.图例
    print(&amp;quot;\nK = {}&amp;quot;.format(k))
    plt.title(&#39;黄色-约会成功 蓝色-约会失败&#39;, fontproperties = prop, fontsize = 15)  
    plt.xlabel(&amp;quot;好感度 like&amp;quot;, fontproperties = prop, fontsize = 15)
    plt.ylabel(&amp;quot;吸引力 attr&amp;quot;, fontproperties = prop, fontsize = 15)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plot_knn_k(k=1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;K = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603099049667.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plot_knn_k(k=50)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;K = 50
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603099058049.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plot_knn_k(k=500)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;K = 500
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603099069043.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;plot_knn_k(k=3000)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;K = 3000
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1603099087409.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">手动实现——KNN</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/1018/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%BE%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E9%97%AE%E9%A2%98&#34;&gt;图——骑士周游问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E6%9E%84%E5%BB%BA%E5%9B%BE&#34;&gt;问题处理——构建图&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%94%9F%E6%88%90%E5%90%88%E6%B3%95%E8%B5%B0%E6%A3%8B%E4%BD%8D%E7%BD%AE&#34;&gt;生成合法走棋位置：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B5%B0%E6%A3%8B%E5%85%B3%E7%B3%BB%E5%9B%BE&#34;&gt;走棋关系图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-dfs&#34;&gt;深度优先搜索 DFS&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%94%A8%E4%BA%8E%E8%A7%A3%E5%86%B3%E9%AA%91%E5%A3%AB%E5%91%A8%E6%B8%B8%E9%97%AE%E9%A2%98&#34;&gt;用于解决骑士周游问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%94%B9%E8%BF%9B%E7%AE%97%E6%B3%95&#34;&gt;改进算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;需要用到上一节中定义的Graph类，直接复制：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;  

class Vertex:
    def __init__(self, key):
        self.id = key                  # 用id保存key
        self.connectedTo = {}     # 字典保存，非常类似昨天10.14写的ID3里对于多叉数的节点定义
        self.distance = None
        self.pred = None
        self.color = &amp;quot;white&amp;quot;
        
    def addNeighbor(self, nbr, weight = 0):    # nbr——链接的对象的key
        self.connectedTo[nbr]=weight            # 加入connection里，并赋边的权重
    
    def __str__(self):
        return str(self.id) +&#39; connectedTo: &#39;  +str([x.id for x in self.connectedTo])

    def getId(self):                      # 获得id
        return self.id
    
    def getConnections(self):       # 该顶点链接的所有顶点的key
        return self.connectedTo.keys()
        
    def getWeight(self,nbr):              # 查看两个顶点的边权重
        return self.connectedTo[nbr]   # 字典按照key索引
    
    ##### 增加部分 ######
    def setDistance(self, x):   # 设置距离
        self.distance = x
        
    def setPred(self, x):     # 设置前驱顶点
        self.pred = x
        
    def setColor(self, x):    # 设置颜色标识
        self.color = x

        
class Graph:                                  # 维护一个masterlist
    def __init__(self):
        self.vertList = {}                       # 存储所有顶点，是一个字典key:vertex
        self.numVertices = 0               # 顶点数量
    
    def addVertex(self,key):              # 添加顶点
        newVertex = Vertex(key)         # 变成顶点形式
        self.vertList[key] = newVertex   # 加入masterlist字典
        self.numVertices +=1 
        #print(newVertex)
    
    def getVertex(self,item):            # 按照key从master里查找一个顶点
        if item in self.vertList:
            return self.vertList[item]
        else:
            return None
    
    def __contain__(self,item):          # 是否包含某个key
        return item in self.vertList
    
    def addEdge(self, f, t, cost=0):     # 添加边 f 到 t（key），cost是边的权重
        # 如果给出的f和t在masterlist里面找不到
        if f not in self.vertList:
            nv = self.addVertex(f)
        if t not in self.vertList:
            nv = self.addVertex(t)
       
        self.vertList[f].addNeighbor(self.vertList[t], cost)     # 调用vertex类里定义联系的方法
        #print(self.vertList[f])
    
    def getVertices(self):    # 输出所有顶点key
        return self.vertList.keys()
    
    def __iter__(self):
        return iter(self.vertList.values())    # 可迭代   所有vertex
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;图骑士周游问题&#34;&gt;图——骑士周游问题&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;马从一个格子开始，按照“马走日”的规则，把棋盘中所有格子都走一遍（不重复）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;“马走日”规则：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每步棋先横走或直走一格，然后再往外斜走一格；&lt;/li&gt;
&lt;li&gt;或者先斜走一格，最后再往外横走或竖走一格&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1602944941202.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;问题处理构建图&#34;&gt;问题处理——构建图&lt;/h1&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把棋盘格作为图的顶点&lt;/li&gt;
&lt;li&gt;把“马走日”这个规则的走棋步骤作为连接边&lt;/li&gt;
&lt;li&gt;每一次最多有8个格子可以走&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;生成合法走棋位置&#34;&gt;生成合法走棋位置：&lt;/h2&gt;
&lt;p&gt;genLegalMoves&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入：当前位置&lt;/li&gt;
&lt;li&gt;输出：当前位置上骑士所有合法移动的列表&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def genLegalMoves(x,y,bdSize):
    newMoves = []
    moveOffsets = [(-1,-2),(-1,2),(-2,-1),(-2,1),( 1,-2),( 1,2),( 2,-1),( 2,1)] 
    for i in moveOffsets:        # 按照规则所有走法
        newX = x + i[0]            # 走到的位置
        newY = y + i[1]
        if legalCoord(newX,bdSize) and legalCoord(newY,bdSize):    # 没有走出棋盘
            newMoves.append((newX,newY))    # 生成合法的移动新位置
    return newMoves

def legalCoord(x,bdSize):
    if x &amp;gt;= 0 and x &amp;lt; bdSize:
        return True
    else:
        return False

genLegalMoves(0, 0, 8)
genLegalMoves(3, 3, 8)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[(1, 2), (2, 1)]

[(2, 1), (2, 5), (1, 2), (1, 4), (4, 1), (4, 5), (5, 2), (5, 4)]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;走棋关系图&#34;&gt;走棋关系图&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 给顶点的id，没有重复
def NodeID(row, col, bdsize):
    return row*bdsize + col

def revNodeID(nodeid, bdsize):   # 根据node id 计算棋盘上的位置
    x = nodeid//bdsize
    y = nodeid%bdsize
    return (x,y)
    
# 生成图
def knightGraph(bdsize=8):
    ktGraph = Graph()
    for row in range(bdsize):  
        for col in range(bdsize):   # 遍历每个格子
            nodeid = NodeID(row, col, bdsize)   # 生成id
            new_xy = genLegalMoves(row, col, bdsize)      # 计算合法移动位置
            for position in new_xy:   # 对每个合法移动的位置
                nid = NodeID(position[0], position[1], bdsize)  # 生成id
                ktGraph.addEdge(nodeid, nid)    # add函数建边，没有顶点就先建立顶点再建边
    return ktGraph
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;knightG = knightGraph(8)
length = 0
for key in knightG.getVertices():
    length += len(knightG.getVertex(key).connectedTo)
print(&amp;quot;一共%d个顶点，%d条边\n&amp;quot;% (knightG.numVertices, length))

# 与(0,0) （3,3）两个顶点有边相连的顶点
print(knightG.getVertex(NodeID(0, 0 ,8)))
print(knightG.getVertex(NodeID(3, 3, 8)))
[revNodeID(x.id, 8) for x in knightG.getVertex(NodeID(0, 0 ,8)).connectedTo] # 2个（2个可走位置）
[revNodeID(x.id, 8) for x in knightG.getVertex(NodeID(3, 3 ,8)).connectedTo]# 8个（8个可走位置）
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;一共64个顶点，336条边

0 connectedTo: [10, 17]
27 connectedTo: [17, 21, 10, 12, 33, 37, 42, 44]


[(1, 2), (2, 1)]


[(2, 1), (2, 5), (1, 2), (1, 4), (4, 1), (4, 5), (5, 2), (5, 4)]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;深度优先搜索-dfs&#34;&gt;深度优先搜索 DFS&lt;/h1&gt;
&lt;p&gt;Depth First Search&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;沿着树的单支尽量深入，&lt;/li&gt;
&lt;li&gt;直到无法继续还没有找到解时&lt;/li&gt;
&lt;li&gt;回溯到上一层，搜索下一支&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现的算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一种，每个顶点仅访问一次&lt;/li&gt;
&lt;li&gt;第二种，允许顶点被重复访问&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;用于解决骑士周游问题&#34;&gt;用于解决骑士周游问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;假定每个顶点只能被访问一次&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;沿着单支深入，直到：还没有走到63步（还没完成周游时），已经出现“当前位置的所有合法移动位置都被走过了”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;那就清除当前位置标记，返回上一层换一个分支搜索&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据这个思路可以发现，访问路径可以用栈来处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引入一个栈记录路径&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;整个算法用递归完成：&lt;br&gt;
访问一个节点——标记、对所有合法位置递归、如果都失败则清楚当前节点标记，并返回上一步&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def knightTour(position, path, depth, limit):
    position.setColor(&#39;grey&#39;)   # 走过了就记作灰色，避免重复
    path.append(position)      # 纳入路径中

    if depth==limit:   # 结束条件
        available = True
    else:
        available = False
        new_xy = list(position.getConnections())  # 下一步走棋位置
        i = 0
        # 对于所有合法且没有走过的解法，递归调用
        while i &amp;lt; len(new_xy) and not available:
            if new_xy[i].color ==&amp;quot;white&amp;quot;:  # 如果没走过
                available,path = knightTour(new_xy[i], path, depth+1, limit)
            i += 1
        if not available:   # 循环结束，如果没有找到
            path.pop()      # 返回上一步
            position.setColor(&amp;quot;white&amp;quot;)       # 当做没来过
    return available, path


knightG = knightGraph(5)
available, path = knightTour(knightG.getVertex(NodeID(2, 2 ,5)), [], 0, 24)
path = [str(revNodeID(x.id, 5)) for x in path]
print(&amp;quot;5x5的棋盘上骑士周游的一条路径：\n&amp;quot;+ &#39; -&amp;gt; &#39;.join(path))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;5x5的棋盘上骑士周游的一条路径：
(2, 2) -&amp;gt; (1, 0) -&amp;gt; (0, 2) -&amp;gt; (1, 4) -&amp;gt; (3, 3) -&amp;gt; (4, 1) -&amp;gt; (2, 0) -&amp;gt; (0, 1) -&amp;gt; (1, 3) -&amp;gt; (3, 4) -&amp;gt; (4, 2) -&amp;gt; (3, 0) -&amp;gt; (1, 1) -&amp;gt; (0, 3) -&amp;gt; (2, 4) -&amp;gt; (4, 3) -&amp;gt; (3, 1) -&amp;gt; (2, 3) -&amp;gt; (0, 4) -&amp;gt; (1, 2) -&amp;gt; (0, 0) -&amp;gt; (2, 1) -&amp;gt; (4, 0) -&amp;gt; (3, 2) -&amp;gt; (4, 4)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;改进算法&#34;&gt;改进算法&lt;/h1&gt;
&lt;p&gt;骑士周游问题的改进算法——在进行对于所有合法移动位置new_xy，按照新位置的合法移动位置数目来决定搜索顺序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下一步选择有最少可能移动位置的顶点！！&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 1.首先定义函数——把下一步的合法移动位置按照其包含的合法移动位置排序：
def orderByAvail(n):
    nextlist = []
    for i in n.getConnections():
        if i.color ==&amp;quot;white&amp;quot;:
            count = 0
            for j in i.getConnections():   # 计算新的顶点有多少可能的移动位置
                if j.color==&amp;quot;white&amp;quot;:
                    count+=1
            nextlist.append((count,i))
    # 按照可能移动位置排序，由小到大
    nextlist.sort(key = lambda x: x[0])
    # 输出排序后的节点列表
    return [x[1] for x in nextlist]

# 测试
knightG = knightGraph(8)
orderByAvail( knightG.getVertex(NodeID(4, 4 ,8)))


### 2.修改原本的算法
def knightTour(position, path, depth, limit):
    position.setColor(&#39;grey&#39;)   # 走过了就记作灰色，避免重复
    path.append(position)      # 纳入路径中

    if depth==limit:   # 结束条件
        available = True
    else:
        available = False
        new_xy = orderByAvail(position)   # 【修改位置】
        i = 0
        # 对于所有合法且没有走过的解法，递归调用
        while i &amp;lt; len(new_xy) and not available:
            if new_xy[i].color ==&amp;quot;white&amp;quot;:  # 如果没走过
                available,path = knightTour(new_xy[i], path, depth+1, limit)
            i += 1
        if not available:   # 循环结束，如果没有找到
            path.pop()      # 返回上一步
            position.setColor(&amp;quot;white&amp;quot;)       # 当做没来过
    return available, path
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&amp;lt;__main__.Vertex at 0x10a0f9198&amp;gt;,
 &amp;lt;__main__.Vertex at 0x10a0f9518&amp;gt;,
 &amp;lt;__main__.Vertex at 0x10a0f9630&amp;gt;,
 &amp;lt;__main__.Vertex at 0x10a0f96a0&amp;gt;,
 &amp;lt;__main__.Vertex at 0x10a0f90b8&amp;gt;,
 &amp;lt;__main__.Vertex at 0x10a0f7cf8&amp;gt;,
 &amp;lt;__main__.Vertex at 0x10a0f7e80&amp;gt;,
 &amp;lt;__main__.Vertex at 0x10a0f9438&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;knightG = knightGraph(8)
available, path = knightTour(knightG.getVertex(NodeID(2, 6 ,8)), [], 0, 63)
path = [str(revNodeID(x.id, 8)) for x in path]
print(&amp;quot;8x8的棋盘上骑士周游的一条路径：\n&amp;quot;+ &#39; -&amp;gt; &#39;.join(path))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;8x8的棋盘上骑士周游的一条路径：
(2, 6) -&amp;gt; (0, 7) -&amp;gt; (1, 5) -&amp;gt; (0, 3) -&amp;gt; (1, 1) -&amp;gt; (3, 0) -&amp;gt; (5, 1) -&amp;gt; (7, 0) -&amp;gt; (6, 2) -&amp;gt; (5, 0) -&amp;gt; (7, 1) -&amp;gt; (6, 3) -&amp;gt; (7, 5) -&amp;gt; (6, 7) -&amp;gt; (4, 6) -&amp;gt; (2, 7) -&amp;gt; (0, 6) -&amp;gt; (1, 4) -&amp;gt; (0, 2) -&amp;gt; (1, 0) -&amp;gt; (2, 2) -&amp;gt; (0, 1) -&amp;gt; (2, 0) -&amp;gt; (4, 1) -&amp;gt; (6, 0) -&amp;gt; (7, 2) -&amp;gt; (6, 4) -&amp;gt; (7, 6) -&amp;gt; (5, 7) -&amp;gt; (3, 6) -&amp;gt; (1, 7) -&amp;gt; (0, 5) -&amp;gt; (1, 3) -&amp;gt; (3, 4) -&amp;gt; (5, 5) -&amp;gt; (4, 7) -&amp;gt; (6, 6) -&amp;gt; (7, 4) -&amp;gt; (5, 3) -&amp;gt; (4, 5) -&amp;gt; (3, 7) -&amp;gt; (2, 5) -&amp;gt; (0, 4) -&amp;gt; (1, 6) -&amp;gt; (2, 4) -&amp;gt; (3, 2) -&amp;gt; (4, 0) -&amp;gt; (6, 1) -&amp;gt; (4, 2) -&amp;gt; (2, 1) -&amp;gt; (0, 0) -&amp;gt; (1, 2) -&amp;gt; (3, 3) -&amp;gt; (5, 4) -&amp;gt; (7, 3) -&amp;gt; (6, 5) -&amp;gt; (7, 7) -&amp;gt; (5, 6) -&amp;gt; (4, 4) -&amp;gt; (5, 2) -&amp;gt; (3, 1) -&amp;gt; (2, 3) -&amp;gt; (3, 5) -&amp;gt; (4, 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;小感受&lt;/strong&gt;&lt;br&gt;
我的天这个效率提升也太快了，原因就是因为充分利用了先验知识，通常要棋盘边上走，选择有最多可能移动位置的节点作为下一个顶点，会导致问题骑士将倾向于在周游的早期访问棋盘中间的方格，因为不能重复走，最后没法完成周游&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;list排序的新知识：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;key = lambda 元素: 元素[字段索引]&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;nextlist.append((count,i))  
nextlist.sort(key = lambda x: x[0])  # 按照某一维排序
return [x[1] for x in nextlist]   # 只输出某一维
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = [(1,4,3),(6,2,4),(5,9,1)]   # 当然这里是圆括号还是方括号都可以
a.sort(key = lambda x :x[0]); [x[0] for x in a]
a.sort(key = lambda x :x[1]); [x[1] for x in a]
a.sort(key = lambda x :x[2]); [x[2] for x in a]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1, 5, 6]






[2, 4, 9]






[1, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
">图——深度优先搜索（骑士周游问题）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/shou-dong-shi-xian-ji-qi-xue-xi-suan-fa-xi-lie/"" data-c="
          &lt;p&gt;回归（普通最小二乘、lasso、岭回归、逻辑回归），树结构相关（cart回归树、ID3分类树、集成学习），距离相关（knn、kmeans等），SVM，神经网络的bp算法，其他（混淆矩阵、交叉验证、ROC曲线绘制）&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;ROC曲线的绘制—— &lt;a href=&#34;https://yangggshuyi.github.io/post/py-shi-xian-logistic/&#34;&gt;已完成&lt;/a&gt; 😚&lt;/p&gt;
&lt;p&gt;一、回归&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;普通最小二乘—— &lt;a href=&#34;https://yangggshuyi.github.io/post/py1017/&#34;&gt;已完成&lt;/a&gt; 😚&lt;/li&gt;
&lt;li&gt;Lasso和岭回归—— &lt;a href=&#34;https://yangggshuyi.github.io/post/py1017/&#34;&gt;已完成&lt;/a&gt; 😚&lt;/li&gt;
&lt;li&gt;逻辑回归—— &lt;a href=&#34;https://yangggshuyi.github.io/post/py-shi-xian-logistic/&#34;&gt;已完成&lt;/a&gt; 😚&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二、树结构的相关算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CART 回归树  —— &lt;a href=&#34;https://yangggshuyi.github.io/post/py1031/&#34;&gt;已完成&lt;/a&gt;😚&lt;/li&gt;
&lt;li&gt;ID3算法分类树  —— &lt;a href=&#34;https://yangggshuyi.github.io/post/python-shi-xian-jue-ce-shu-id3-suan-fa/&#34;&gt;已完成&lt;/a&gt; 😚&lt;/li&gt;
&lt;li&gt;Adaboost —— &lt;a href=&#34;https://yangggshuyi.github.io/post/py1027/&#34;&gt;已完成&lt;/a&gt; 😚&lt;/li&gt;
&lt;li&gt;GBDT&lt;/li&gt;
&lt;li&gt;xgboost 单颗 class xgboost(Tree)-&amp;gt;多颗&lt;/li&gt;
&lt;li&gt;剪枝和缺失值处理问题&lt;/li&gt;
&lt;li&gt;随机森林&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三、距离的相关算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;LDA&lt;/li&gt;
&lt;li&gt;knn—— &lt;a href=&#34;https://yangggshuyi.github.io/post/py10.19/&#34;&gt;已完成&lt;/a&gt; 😚&lt;/li&gt;
&lt;li&gt;kmeans&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;四、感知机&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py1021/&#34;&gt;SVM——完全线性可分&lt;/a&gt; 😚&lt;/li&gt;
&lt;li&gt;SVM——近似线性可分（软间隔）&lt;/li&gt;
&lt;li&gt;SVM——线性不可分（核函数问题）&lt;/li&gt;
&lt;li&gt;BP算法 —— &lt;a href=&#34;https://yangggshuyi.github.io/post/BP0922/&#34;&gt;已完成&lt;/a&gt; 😚&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;五、贝叶斯&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;朴素贝叶斯&lt;/li&gt;
&lt;li&gt;贝叶斯网络&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;六、隐马尔科夫等&lt;/p&gt;
">【系列】手动实现机器学习算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1017/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#ridge-%E7%9A%84%E5%B0%81%E8%A3%85%E7%B1%BB&#34;&gt;Ridge 的封装——类&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%83%B3%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%9F%E8%83%BD&#34;&gt;想要实现的功能：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AF%BB%E5%85%A5-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE-%E6%8F%90%E5%8F%96%E5%8F%98%E9%87%8F&#34;&gt;读入&amp;amp; 处理数据 &amp;amp; 提取变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D&#34;&gt;具体实现（梯度下降）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E6%99%AE%E9%80%9A%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E7%9F%A9%E9%98%B5%E6%B1%82%E9%80%86&#34;&gt;定义函数——普通最小二乘（矩阵求逆）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理有解/x&#39;x可逆的情况——非常简单的矩阵运算&lt;/li&gt;
&lt;li&gt;补充上岭回归的惩罚参数a——也是简单的矩阵运算，也可以用梯度下降&lt;/li&gt;
&lt;li&gt;交叉验证——计算平均预测误差 RMSE 在多次中的平均值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关键在于包装为成一个尽可能完整的class&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;ridge-的封装类&#34;&gt;Ridge 的封装——类&lt;/h1&gt;
&lt;h2 id=&#34;想要实现的功能&#34;&gt;想要实现的功能：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;划分训练和测试集&lt;/li&gt;
&lt;li&gt;梯度下降迭代估计参数&lt;/li&gt;
&lt;li&gt;绘制迭代cost收敛图&lt;/li&gt;
&lt;li&gt;计算预测值&lt;/li&gt;
&lt;li&gt;计算预测rmse&lt;/li&gt;
&lt;li&gt;交叉验证的平均rmse&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;读入-处理数据-提取变量&#34;&gt;读入&amp;amp; 处理数据 &amp;amp; 提取变量&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
#  1.读入数据 
os.chdir(&amp;quot;/Users/mac/Desktop/快乐研一/python/data&amp;quot;)
gaokao = pd.read_csv(&amp;quot;高考待预处理.csv&amp;quot;)
gaokao.head()
data = gaokao.iloc[:, [2, 3, 11, 4]]
data_x = data.drop([&amp;quot;分数线&amp;quot;], axis=1)  # # 提取自变量——重点学科、博士点、是否为综合类大学
data_y = data[[&#39;分数线&#39;]]  # 因变量——分数线
# 2.标准化
def biaozhunhua(x):
    return (x-x.mean())/x.std()
data_y = data_y.apply(biaozhunhua)
data_x[[&amp;quot;重点学科&amp;quot;,&amp;quot;博士点&amp;quot;]] = data_x[[&amp;quot;重点学科&amp;quot;,&amp;quot;博士点&amp;quot;]].apply(biaozhunhua)
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;大学名称&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;重点学科&lt;/th&gt;
      &lt;th&gt;博士点&lt;/th&gt;
      &lt;th&gt;分数线&lt;/th&gt;
      &lt;th&gt;type_农业&lt;/th&gt;
      &lt;th&gt;type_医药&lt;/th&gt;
      &lt;th&gt;type_工科&lt;/th&gt;
      &lt;th&gt;type_师范&lt;/th&gt;
      &lt;th&gt;type_林业&lt;/th&gt;
      &lt;th&gt;type_民族&lt;/th&gt;
      &lt;th&gt;type_综合&lt;/th&gt;
      &lt;th&gt;type_财经&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;复旦大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;30.0&lt;/td&gt;
      &lt;td&gt;178.0&lt;/td&gt;
      &lt;td&gt;687.0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;清华大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;37.0&lt;/td&gt;
      &lt;td&gt;253.0&lt;/td&gt;
      &lt;td&gt;686.0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;上海交通大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;9.0&lt;/td&gt;
      &lt;td&gt;78.0&lt;/td&gt;
      &lt;td&gt;664.0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;南京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;21.0&lt;/td&gt;
      &lt;td&gt;44.0&lt;/td&gt;
      &lt;td&gt;662.0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;具体实现梯度下降&#34;&gt;具体实现（梯度下降）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;岭回归也可以通过矩阵求逆直接计算&lt;/li&gt;
&lt;li&gt;这里当做优化问题来做——梯度下降法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;J&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mi&gt;β&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mi&gt;β&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mfrac&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mfrac&gt;&lt;msup&gt;&lt;mi&gt;β&lt;/mi&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;mi&gt;β&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;J = \frac{1}{2m} (X\beta -y)&amp;#x27;(X\beta -y) + \frac{a}{2} \beta &amp;#x27; \beta&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.09618em;&#34;&gt;J&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.190108em;vertical-align:-0.345em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.845108em;&#34;&gt;&lt;span style=&#34;top:-2.6550000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.394em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.345em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05278em;&#34;&gt;β&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.001892em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05278em;&#34;&gt;β&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.096892em;vertical-align:-0.345em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.695392em;&#34;&gt;&lt;span style=&#34;top:-2.6550000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.394em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;a&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.345em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05278em;&#34;&gt;β&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05278em;&#34;&gt;β&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;J&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mi&gt;β&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;/mfrac&gt;&lt;msup&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mi&gt;β&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;+&lt;/mo&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;β&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\frac{dJ}{d \beta} = \frac{1}{m} X&amp;#x27;(X \beta -y) + a \beta&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.3612159999999998em;vertical-align:-0.481108em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8801079999999999em;&#34;&gt;&lt;span style=&#34;top:-2.6550000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05278em;&#34;&gt;β&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.394em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.09618em;&#34;&gt;J&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.481108em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.190108em;vertical-align:-0.345em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.845108em;&#34;&gt;&lt;span style=&#34;top:-2.6550000000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;m&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.394em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.345em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05278em;&#34;&gt;β&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05278em;&#34;&gt;β&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Ridge():
    
    def __init__(self):
        self.w = None
        self.b = None
        self.costlist = None
        self.epochs = None
    
    # 1.获得参数估计值
    def getParam(self):
        print(&amp;quot;\nW: {}\nb: {}&amp;quot;.format(np.round(self.w,3), np.round(self.b,3)))
        return self.w, self.b
        
    # 2.计算梯度
    def l2_loss(self, X, y, w, b, alpha = 0):
        num_train = X.shape[0]
        num_feature = X.shape[1]
        y_hat = np.dot(X, w) + b
        cost = np.sum((y_hat-y)**2)/num_train + alpha*(np.sum(np.square(w)))
        dw = np.dot(X.T, (y_hat-y)) /num_train + 2*alpha*w
        db = np.sum((y_hat-y)) /num_train
        return dw, db, cost
    
    # 3.迭代估计
    def fit(self, data_x, data_y, learning_rate=0.05, epochs=1000, alpha=0, ifprint = False):
        &#39;&#39;&#39;
        输入：X、y、学习率、迭代次数、惩罚系数
        输出：估计参数、cost（list）
        &#39;&#39;&#39;
        self.w = np.zeros((data_x.shape[1],1))
        self.b = 0
        self.costlist = []
        self.epochs = epochs 
        for i in range(epochs):
            dw, db, cost_tmp = self.l2_loss(data_x, data_y, self.w, self.b, alpha = alpha)  # 计算梯度
            self.w = self.w - learning_rate * dw         # 更新参数
            self.b = self.b - learning_rate * db
            self.b = self.b.tolist()
            self.costlist.append(cost_tmp)    # 记录下cost函数的递减过程
            if (ifprint==True) and (i % 100 == 0):              # 打印训练过程 
                print(&amp;quot;迭代次数:%d,  cost=%f&amp;quot; % (i+1, cost_tmp))
        if ifprint==True:
            print(&amp;quot;%d次迭代结束！最终训练集上cost:%f&amp;quot; % (i+1, cost_tmp))
        
    
    # 4.绘制cost收敛
    def plot_cost(self):
        fig = plt.figure(figsize=(9,6))   
        plt.plot(range(self.epochs), self.costlist)
        plt.title(&amp;quot;cost&amp;quot;, fontsize=20)
        plt.show()
        plt.close()
        
    #5. 计算rmse：
    def rmse(self, test_y, test_pred):
        x = np.squeeze(np.array(test_y))-test_pred
        return np.sqrt(np.squeeze(np.dot((x).T,(x)))/len(x))
    
    # 6.计算预测值
    def prediction(self, test_x):
        yhat_l2 = np.squeeze(np.dot(test_x, self.w) + self.b)
        return yhat_l2
    
    # 7.# 划分训练集和测试集
    def sample(self, data_x, data_y, percentage=0.8):
        sample = np.random.choice(range(len(data_y)), int(len(data_y) * percentage), replace= False).tolist()
        train_x = data_x.iloc[sample, :]
        test_x = data_x.iloc[[x for x in range(len(data_y)) if x not in sample], :]
        train_y = data_y.iloc[sample, :]
        test_y = data_y.iloc[[x for x in range(len(data_y)) if x not in sample], :]
        print(&amp;quot;训练集样本量:{}测试集样本量:{}&amp;quot;.format(len(train_y),len(test_y)))
        return train_x, train_y, test_x, test_y
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 测试 ridge 函数类
# 1.初始化
model = Ridge()
# 2.分割测试和训练
train_x, train_y, test_x, test_y = model.sample(data_x, data_y, percentage=0.7)
# 3.训练model
model.fit(train_x, train_y, learning_rate=0.003, epochs=1000, alpha=0.1, ifprint = True)
# 4.获取参数估计值
w, b = model.getParam()
# 5.绘制训练过程中的cost收敛过程
model.plot_cost()
# 6. 预测
test_pred = model.prediction(test_x)
# 7.计算预测rmse
rmse_l2 = model.rmse(test_y, test_pred)
print(&amp;quot;\n 岭回归（惩罚系数0.1\n预测集上rmse={}&amp;quot;.format(rmse_l2))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;训练集样本量:89测试集样本量:39
迭代次数:1,  cost=1.048072
迭代次数:101,  cost=0.716701
迭代次数:201,  cost=0.613186
迭代次数:301,  cost=0.578509
迭代次数:401,  cost=0.565609
迭代次数:501,  cost=0.560109
迭代次数:601,  cost=0.557384
迭代次数:701,  cost=0.555831
迭代次数:801,  cost=0.554838
迭代次数:901,  cost=0.554142
1000次迭代结束！最终训练集上cost:0.553627

W: [[ 0.321]
 [ 0.364]
 [-0.05 ]]
b: [-0.052]
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1602899701115.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt; 岭回归（惩罚系数0.1
预测集上rmse=0.7781370066362491
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;定义函数普通最小二乘矩阵求逆&#34;&gt;定义函数——普通最小二乘（矩阵求逆）&lt;/h1&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;β&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;msup&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;msup&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mrow&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;msup&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;mi&gt;y&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\beta = (X&amp;#x27;X)^{-1}X&amp;#x27;y&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8888799999999999em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.05278em;&#34;&gt;β&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.064108em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8141079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.751892em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03588em;&#34;&gt;y&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;$rmse = \frac{(X\beta -y)&#39;(X\beta -y)}{n} $&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;##### 正式定义函数——OLS
def my_OLS(data_x, data_y):
    
    #######    1.构造数据    ######
    #  在第一列插入1
    col_name = data_x.columns.tolist()                   
    col_name.insert(0, &#39;x0&#39;)                      
    data_x = data_x.reindex(columns = col_name)           
    data_x[&#39;x0&#39;] = [1] * data_x.shape[0]  
    
    #######    2.计算OLS估计量    ######
    xTx = np.dot(data_x.T, data_x)   # x&#39;x
    xTx_I = np.matrix(xTx).I            # (x&#39;x)的逆
    beta = np.dot(np.dot(xTx_I, data_x.T), data_y)
    beta = np.squeeze(np.array(beta))
    
    #######    3.输出    ######
    yhat = np.dot(data_x, beta)
    return yhat, beta

# 测试
# train_x, train_y, test_x, test_y
yhat_ols, beta_ols = my_OLS(train_x, train_y)
yhat_ols = np.dot(beta_ols[1:len(beta_ols)], test_x.T) + beta_ols[0]
rmse_ols = model.rmse(test_y, yhat_ols)   # 普通最小二乘rmse
print(&amp;quot;普通最小二乘法参数：{} \n 预测集上rmse={}&amp;quot;.format(np.round(beta_ols,3),np.round(rmse_ols,3)))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;普通最小二乘法参数：[ 0.034  0.344  0.479 -0.029] 
 预测集上rmse=0.793
&lt;/code&gt;&lt;/pre&gt;
">手动实现——OLS & 岭回归</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/shu-ju-jie-gou-yu-suan-fa-python-ban/"" data-c="
          &lt;p&gt;学习框架：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;算法分析：&lt;a href=&#34;https://yangggshuyi.github.io/post/python-jichu1/&#34;&gt;python 数据结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;基本结构：&lt;a href=&#34;https://yangggshuyi.github.io/post/py0926-0928/&#34;&gt;栈、队列、双端队列、链表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py0929-0930/&#34;&gt;递归&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py10-7/&#34;&gt;排序与搜索&lt;/a&gt;&lt;br&gt;
-  查找：顺序搜索、二分查找&lt;br&gt;
-  排序：冒泡排序、选择排序、插入排序（谢尔排序、归并排序、快速排序）&lt;/li&gt;
&lt;li&gt;树和树的算法
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/10-8/&#34;&gt;树与二叉堆&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py1012-13/&#34;&gt;二叉搜索树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py10.14/&#34;&gt;平衡二叉树AVL&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;图和图的算法
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py1015-2/&#34;&gt;广度优先搜索——词梯问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/1018/&#34;&gt;深度优先搜索——骑士周游问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://yangggshuyi.github.io/post/py1020/&#34;&gt;其他问题：拓扑排序、强连通分支、最短路径&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
">【系列】数据结构与算法 （完结）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py-shi-xian-logistic/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%9D%E8%B7%AF&#34;&gt;思路：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86&#34;&gt;数据预处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E4%BA%A4%E5%8F%89%E7%86%B5%E7%9A%84cost%E6%A2%AF%E5%BA%A6&#34;&gt;定义函数——计算交叉熵的cost&amp;amp;梯度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%AD%E4%BB%A3%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D&#34;&gt;迭代梯度下降&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9F%A5%E7%9C%8B%E8%AE%AD%E7%BB%83%E9%9B%86%E7%9A%84%E7%BB%93%E6%9E%9C&#34;&gt;查看训练集的结果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9C%A8%E6%B5%8B%E8%AF%95%E9%9B%86%E4%B8%8A%E7%9A%84%E8%A1%A8%E7%8E%B0&#34;&gt;在测试集上的表现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%98%E5%88%B6roc%E6%9B%B2%E7%BA%BF%E7%9A%84%E5%87%BD%E6%95%B0%E4%BA%8C%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98&#34;&gt;绘制roc曲线的函数（二分类问题）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%85%83%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E7%B1%BB%E7%95%8C%E9%99%90&#34;&gt;二元可视化分类界限&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h2 id=&#34;思路&#34;&gt;思路：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;读入数据&amp;amp;预处理&amp;amp;分训练集和预测集&lt;/li&gt;
&lt;li&gt;定义函数——计算交叉熵损失coss、w和b的偏导&lt;/li&gt;
&lt;li&gt;定义函数——迭代梯度下降&lt;/li&gt;
&lt;li&gt;预测混淆矩阵 &amp;amp; ROC曲线 &amp;amp; 可视化分类边界&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据预处理&#34;&gt;数据预处理&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
#import random     
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    

# font_manager函数，用于指定中文字体样式、大小
import matplotlib.font_manager as mfm
font_path = r&amp;quot;/Users/mac/Library/Fonts/字体管家方萌简（非商业使用）v1.1.ttf&amp;quot;
prop = mfm.FontProperties(fname = font_path)

## 读入数据
os.chdir(&amp;quot;/Users/mac/Desktop/快乐研一/python/机器学习python实现&amp;quot;)
dating = pd.read_csv(&amp;quot;Speed Dating Data.csv&amp;quot;, encoding = &amp;quot;gbk&amp;quot;)

## 提取变量——是否接受dec（因变量0-1）、好感度like、吸引力attr
dating = dating[[&#39;like&#39;,&#39;attr&#39;,&#39;dec&#39;]]
dating.head()

## 缺失问题
dating.isnull().sum(axis=0)  # 缺失比例
dating.dropna(axis = 0, how=&#39;any&#39;, thresh = None, subset = None, inplace=True)   # omit na值
print(&amp;quot;去掉缺失之后总样本量{}&amp;quot;.format(len(dating)))

## 分为训练集和测试集
sample = np.random.choice(range(len(dating)), int(len(dating)*0.8), replace= False).tolist()
dating_train = dating.iloc[sample, :]
dating_test = dating.iloc[[x for x in range(len(dating)) if x not in sample], :]
print(&amp;quot;训练集样本量 = {}, 测试集样本量 = {}&amp;quot;.format(len(dating_train),len(dating_test)))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;去掉缺失之后总样本量8122
训练集样本量 = 6497, 测试集样本量 = 1625
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;定义函数计算交叉熵的cost梯度&#34;&gt;定义函数——计算交叉熵的cost&amp;amp;梯度&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;输入：x,y,w,b&lt;/li&gt;
&lt;li&gt;计算yhat（最好先定义一个sigmoid方便计算）、coss、对于w和b的梯度&lt;/li&gt;
&lt;li&gt;输出：yhat/coss/dw/db&lt;br&gt;
&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1602777130104.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里就按照向量计算来，假定w是(p,1)维的向量，b是常数，数据(n,p)，y和y_hat是(n,1)维的向量&lt;/p&gt;
&lt;p&gt;矩阵/向量的乘法：np.dot&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 前置知识——py中的矩阵运算：
&#39;&#39;&#39;
a = np.zeros((3,2));b = a+1;c = a+2
b
b.T   # 矩阵转置
b*c  # 每一项相乘
b+c  # 每一项相加
np.dot(b.T,c)   # 真正的矩阵乘法
np.sum(c)       # 每一项的总和
&#39;&#39;&#39;

# 定义sigmoid函数
def sigmoid(x):           
    z = 1/(1+np.exp(-x))
    return z

# 定义函数计算梯度
def logistic(X,y,w,b):      # 计算当前梯度
    # 根据输入的w和b，计算yhat，再加上x和y计算并输出梯度
    yhat = sigmoid(np.dot(X, w) + b)     # 计算预测值
    cost = (-1/len(X)) *(int(np.dot(y.T,np.log(yhat)))+np.dot((1-y.T), np.log(1-yhat)))   # 计算交叉熵
    dw = np.dot(X.T, np.squeeze(yhat)-y)/len(X)   # 计算梯度
    db = np.sum(np.squeeze(yhat)-y)/len(X)        # 计算梯度
    return np.squeeze(yhat), cost, dw.reshape(X.shape[1],1), db

# 测试
a,b,c,d = logistic(X = dating_train[[&#39;like&#39;,&#39;attr&#39;]], y = dating_train[&#39;dec&#39;] ,w = np.zeros((2,1)) ,b = 0)
c,d
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(array([[-0.05731876],
        [-0.05567185]]), 0.06749268893335386)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;迭代梯度下降&#34;&gt;迭代梯度下降&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;输入：训练集df，y_label，学习率、迭代次数&lt;/li&gt;
&lt;li&gt;输出：迭代过程print出来，yhat/cost/更新后的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def logistic_train(X, y, alpha, epochs):
    # 首先参数初始化
    n = X.shape[0]
    p = X.shape[1]
    w = np.zeros((p, 1))
    b = 0
    cost_list = []           # 记录下cost函数的递减过程
    
    # 循环迭代
    for i in range(epochs):
        yhat, cost, dw, db = logistic(X, y, w, b)   # 计算梯度
        w = w - alpha * dw      # 更新参数
        b = b - alpha * db
        cost_list.append(cost)      # 记录下cost函数的递减过程
        
        # 打印训练过程 ，每迭代100次打印一次
        if i % 100 == 0: 
            print(&amp;quot;迭代次数:%d,  交叉熵cost=%f&amp;quot; % (i+1, cost))
    
    # 输出最后参数
    params = {
        &#39;W&#39;: w,
        &#39;b&#39;: b
    }
    grads = {
        &#39;dW&#39;:dw,
        &#39;db&#39;:db
    }
    print(&amp;quot;%d次迭代结束！最终训练集上cost:%f&amp;quot; % (i+1, cost))
    #print(params,grads)
    return cost_list, params,yhat

# 测试
costlist, Wb, yhat = logistic_train(dating_train[[&#39;like&#39;,&#39;attr&#39;]], dating_train[&#39;dec&#39;], 0.1, 3000)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;迭代次数:1,  交叉熵cost=0.693033
迭代次数:101,  交叉熵cost=0.681541
迭代次数:201,  交叉熵cost=0.630818
迭代次数:301,  交叉熵cost=0.589915
迭代次数:401,  交叉熵cost=0.567970
迭代次数:501,  交叉熵cost=0.554228
迭代次数:601,  交叉熵cost=0.543767
迭代次数:701,  交叉熵cost=0.535549
迭代次数:801,  交叉熵cost=0.528856
迭代次数:901,  交叉熵cost=0.523552
迭代次数:1001,  交叉熵cost=0.519121
迭代次数:1101,  交叉熵cost=0.515412
迭代次数:1201,  交叉熵cost=0.512466
迭代次数:1301,  交叉熵cost=0.509890
迭代次数:1401,  交叉熵cost=0.507618
迭代次数:1501,  交叉熵cost=0.505904
迭代次数:1601,  交叉熵cost=0.504247
迭代次数:1701,  交叉熵cost=0.502922
迭代次数:1801,  交叉熵cost=0.501747
迭代次数:1901,  交叉熵cost=0.500701
迭代次数:2001,  交叉熵cost=0.499921
迭代次数:2101,  交叉熵cost=0.499082
迭代次数:2201,  交叉熵cost=0.498482
迭代次数:2301,  交叉熵cost=0.497800
迭代次数:2401,  交叉熵cost=0.497337
迭代次数:2501,  交叉熵cost=0.496777
迭代次数:2601,  交叉熵cost=0.496421
迭代次数:2701,  交叉熵cost=0.496109
迭代次数:2801,  交叉熵cost=0.495837
迭代次数:2901,  交叉熵cost=0.495446
3000次迭代结束！最终训练集上cost:0.495245
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;查看训练集的结果&#34;&gt;查看训练集的结果&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 训练过程cost的下降过程
fig = plt.figure(figsize=(9,6))   # 创建一张8*6的画布
plt.plot(range(3000), costlist)
plt.title(&amp;quot;可视化-交叉熵损失函数收敛过程&amp;quot;, fontproperties=prop, fontsize=20)
plt.show() 
plt.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1602777092725.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 查看训练结果——拟合的混淆矩阵：
# 加载库画混淆矩阵
from sklearn.metrics import confusion_matrix
import seaborn as sns

# 定义预测归类函数
def pred(x, threshold=0.5):
    if x&amp;gt;threshold:
        return 1
    else:
        return 0

# 混淆矩阵
y_train = [pred(x) for x in yhat]
confusion_matrix(dating_train[&#39;dec&#39;],y_train)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;array([[3022,  665],
       [ 893, 1917]])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;在测试集上的表现&#34;&gt;在测试集上的表现&lt;/h2&gt;
&lt;p&gt;从以下角度出发&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据参数计算yhat&lt;/li&gt;
&lt;li&gt;pred(yhat)，比如分类阈值是0.5的时候的混淆矩阵&lt;/li&gt;
&lt;li&gt;绘制roc曲线&lt;/li&gt;
&lt;li&gt;可视化分类界限&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 1.计算预测集上yhat
test_yhat =  np.squeeze(sigmoid(np.dot(dating_test[[&#39;like&#39;,&#39;attr&#39;]], Wb[&#39;W&#39;]) + Wb[&#39;b&#39;]))

# 2.预测集上的混淆矩阵
y_test_pred = [pred(x) for x in test_yhat]  # 按0.5作为阈值
confusion_matrix(dating_test[&#39;dec&#39;],y_test_pred)/dating_test.shape[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;array([[0.47446154, 0.10461538],
       [0.14461538, 0.27630769]])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;绘制roc曲线的函数二分类问题&#34;&gt;绘制roc曲线的函数（二分类问题）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;######## 绘制roc曲线的函数（二分类问题） ######
# 3.roc曲线

def plot_roc(y,yhat):
    
    # 第一步、计算fpr tpr
    tpr = []
    fpr = []
    yhat_ = np.random.choice(yhat, int(len(yhat)*0.2), replace= False).tolist()   # 从样本预测值里面抽取一些
    yhat_.sort()   # 把样本预测值从小到大排序
    for i in yhat_:
        ypred = [pred(x, threshold=i) for x in yhat]   # 把抽取的预测值当做分类阈值
        cm = confusion_matrix(y,ypred)                  # 计算混淆矩阵，方便算fpr tpr
        tpr.append(cm[0,0]/(cm[0,0]+cm[0,1]))        # 真 正例率
        fpr.append(cm[1,0]/(cm[1,0]+cm[1,1]))          # 假 正例率
    
    # 第二步、画图
    fig = plt.figure(figsize=(8,6))   # 创建一张8*6的画布
    plt.plot(fpr, tpr)
    plt.title(&amp;quot;ROC曲线&amp;quot;, fontproperties=prop, fontsize=25)
    plt.xlabel(&amp;quot;假正例率  fpr&amp;quot;, fontproperties=prop, fontsize=20)
    plt.ylabel(&amp;quot;真正例率  tpr&amp;quot;, fontproperties=prop, fontsize=20)
    plt.show() 
    # AUC值或许可以用模拟方法求，后面可以查下资料    

plot_roc(dating_test[&#39;dec&#39;], test_yhat)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1602777078897.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;二元可视化分类界限&#34;&gt;二元可视化分类界限&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 1.生成网格点数据
xx1, xx2 = np.meshgrid(np.arange(0, 10, 0.15), np.arange(0, 10, 0.15))   # 生成自变量的数据
xx = pd.DataFrame({&#39;x1&#39;:xx1.ravel(),&#39;x2&#39;:xx2.ravel()})                              # 拉直后合并为df
yy_hat =  np.squeeze(sigmoid(np.dot(xx, Wb[&#39;W&#39;]) + Wb[&#39;b&#39;]))                # 预测
yy_pred_ = [pred(x) for x in yy_hat]                                    # 按0.5作为阈值对预测值分类  
yy_pred = np.array(yy_pred_).reshape(xx1.shape)                  # reshape为网格/矩阵

# 2.画图
fig = plt.figure(figsize=(8,7))   # 创建一张8*6的画布
# 2.1背景网格点
color = [&amp;quot;#e2a653&amp;quot; if c==1 else &amp;quot;#6cabe6&amp;quot; for c in yy_pred_] 
plt.scatter(xx1, xx2, c = color, alpha = 0.4, marker= &amp;quot;.&amp;quot;)

# 2.2原始数据的点
color = [&amp;quot;orange&amp;quot; if c==1 else &amp;quot;dodgerblue&amp;quot; for c in dating_test[&#39;dec&#39;]] 
plt.scatter(dating_test[&#39;like&#39;],dating_test[&#39;attr&#39;], c=color, marker= &amp;quot;s&amp;quot;)

# 3.图例
plt.title(&#39;黄色-约会成功\n蓝色-约会失败&#39;, fontproperties=prop, fontsize=30)  
plt.xlabel(&amp;quot;好感度 like&amp;quot;, fontproperties=prop, fontsize=20)
plt.ylabel(&amp;quot;吸引力 attr&amp;quot;, fontproperties=prop, fontsize=20)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1602777070263.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">手动实现——Logistic与Roc曲线</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1015-2/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5&#34;&gt;图的概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E7%8E%B0adt-graph&#34;&gt;实现ADT Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8&#34;&gt;图的应用&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F%E8%AF%8D%E6%A2%AF%E9%97%AE%E9%A2%98&#34;&gt;单词游戏——词梯问题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BB%BA%E7%AB%8B%E5%8D%95%E8%AF%8D%E5%85%B3%E7%B3%BB%E5%9B%BE&#34;&gt;建立单词关系图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2bfs&#34;&gt;广度优先搜索BFS&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%9D%E6%AD%A5%E7%90%86%E8%A7%A3&#34;&gt;初步理解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%9F%E8%B8%AA%E9%A1%B6%E7%82%B9%E5%8A%A0%E5%85%A5%E8%BF%87%E7%A8%8B%E7%BB%99%E9%A1%B6%E7%82%B9%E5%A2%9E%E5%8A%A0%E5%B1%9E%E6%80%A7&#34;&gt;跟踪顶点加入过程——给顶点增加属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B&#34;&gt;算法过程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;今天要开启新的一章学习啦，近期学习目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图及算法，慢慢来&lt;/li&gt;
&lt;li&gt;py实现逻辑回归（easy）、cart回归树（median）、SVM（hard）&lt;/li&gt;
&lt;li&gt;经典机器学习算法还差rf和boosting，学完之后可以了解下强化学习的概念&lt;/li&gt;
&lt;li&gt;做完这些就需要对数据结构进行复习啦，暂定为看b站视频&amp;amp;leetcode简单题目&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;图的概念&#34;&gt;图的概念&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;顶点Vertex&lt;/strong&gt;&lt;br&gt;
具有名称标识Key，也可以携带数据项payload&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;边Edge/弧Arc&lt;/strong&gt;&lt;br&gt;
表示两个顶点之间的关系，可以有方向也可以没有&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;权重Weight&lt;/strong&gt;&lt;br&gt;
给边赋权重，可以理解为从一个顶点到另一个顶点的“代价”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;图Graph&lt;/strong&gt; 一个图G可以定义为G = (V,E)，即点和边的集合
&lt;ul&gt;
&lt;li&gt;E中的每一条e = (v,w) v,w是两个顶点&lt;/li&gt;
&lt;li&gt;如果有权重，e中还要增加权重分量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路径Path&lt;/strong&gt; 依次链接的顶点序列：
&lt;ul&gt;
&lt;li&gt;有权重：路径的长度=边的数量&lt;/li&gt;
&lt;li&gt;无权重：路径的长度=边权重的和&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;圈Cycle&lt;/strong&gt; 首尾相连/顶点相同的路径，有些有向图不存在任何圈（称为DAG）&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;实现adt-graph&#34;&gt;实现ADT Graph&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;添加：顶点、边/有权重的边addVertex、addEgde&lt;/li&gt;
&lt;li&gt;查找：按key查找顶点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;邻接矩阵&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;行列代表顶点，如果i和j有连接，矩阵ij处保存权重&lt;/li&gt;
&lt;li&gt;问题在于效率，大多数时候都是系数的&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;邻接表&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个masterlist，包括所有顶点&lt;/li&gt;
&lt;li&gt;每个顶点都关联一个list，保存所有和自己有边连接的顶点&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    

#### 1.首先定义顶点类（不带payload的、有方向的图）
class Vertex:
    def __init__(self, key):
        self.id = key                  # 用id保存key
        self.connectedTo = {}     # 字典保存，非常类似昨天10.14写的ID3里对于多叉数的节点定义！
        
    def addNeighbor(self, nbr, weight = 0):    # nbr——链接的对象的key
        self.connectedTo[nbr]=weight            # 加入connection里，并赋边的权重
    
    def __str__(self):
        return str(self.id) +&#39; connectedTo: &#39;  +str([x.id for x in self.connectedTo])

    def getId(self):                      # 获得id
        return self.id
    
    def getConnections(self):       # 该顶点链接的所有顶点的key
        return self.connectedTo.keys()
        
    def getWeight(self,nbr):              # 查看两个顶点的边权重
        return self.connectedTo[nbr]   # 字典按照key索引

# 测试
v1 = Vertex(1);v2 = Vertex(2);v3 = Vertex(3)
v1.addNeighbor(1, 12);v1.addNeighbor(2, 13);v2.addNeighbor(3, 23)
v1.getConnections()
v2.getWeight(3)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1
2





23
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;##### 2.接着实现Graph类（邻接表的形式）

class Graph:                                  # 维护一个masterlist
    def __init__(self):
        self.vertList = {}                       # 存储所有顶点，是一个字典key:vertex
        self.numVertices = 0               # 顶点数量
    
    def addVertex(self,key):              # 添加顶点
        newVertex = Vertex(key)         # 变成顶点形式
        self.vertList[key] = newVertex   # 加入masterlist字典
        self.numVertices +=1 
        #print(newVertex)
    
    def getVertex(self,item):            # 按照key从master里查找一个顶点
        if item in self.vertList:
            return self.vertList[item]
        else:
            return None
    
    def __contain__(self,item):          # 是否包含某个key
        return item in self.vertList
    
    def addEdge(self, f, t, cost=0):     # 添加边 f 到 t（key），cost是边的权重
        # 如果给出的f和t在masterlist里面找不到
        if f not in self.vertList:
            nv = self.addVertex(f)
        if t not in self.vertList:
            nv = self.addVertex(t)
       
        self.vertList[f].addNeighbor(self.vertList[t], cost)     # 调用vertex类里定义联系的方法
        #print(self.vertList[f])
    
    def getVertices(self):    # 输出所有顶点key
        return self.vertList.keys()
    
    def __iter__(self):
        return iter(self.vertList.values())    # 可迭代   所有vertex
        
# 测试
g = Graph()
# 添加顶点
for i in range(6): g.addVertex(i)
# 查看所有顶点
g.getVertices()
# 添加新边
g.addEdge(1, 2, cost=12)
g.addEdge(1, 3, cost=13)
g.addEdge(1, 7,  cost=17)
# 顶点数目
g.numVertices
# 查看某个顶点
print(g.getVertex(1))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;dict_keys([0, 1, 2, 3, 4, 5])






7



1 connectedTo: [2, 3, 7]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;图的应用&#34;&gt;图的应用&lt;/h1&gt;
&lt;h2 id=&#34;单词游戏词梯问题&#34;&gt;单词游戏——词梯问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相邻两个单词之间的差异只能是一个字母&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们的目标是找到最短的单词变换序列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何用图来解释——把可能的单词之间的演变关系表达为图&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把所有固定长度的单词作为顶点key&lt;/li&gt;
&lt;li&gt;对每个顶点，如果单词之间之只差一个字母，就设一条边（比较次数多）&lt;/li&gt;
&lt;li&gt;无向图、无权重&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;避免逐个比较建边的改进方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;桶&lt;/strong&gt;，每个桶可以存放若干单词——只有一个字母不一样&lt;/li&gt;
&lt;li&gt;桶的key是用_占替代一个字母&lt;/li&gt;
&lt;li&gt;然后在同一个桶的相互之间建边&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;广度优先搜索BFS&lt;/strong&gt;：搜索从开始单词到结束单词之间的所有有效路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选出最短路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;建立单词关系图&#34;&gt;建立单词关系图&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 前置处理——采用字典建立“桶”
import os             # 加载标准库
os.chdir(&#39;/Users/mac/Desktop/快乐研一/python/data&#39;)   # 相当于setwd()

def buildGraph(wordFile):
    d = {}
    g = Graph()
    wfile = open(wordFile,&#39;r&#39;)
    
    # 构造桶
    for line in wfile:              # 对于每一个单词
        word = line[:-1]
        for i in range(len(word)):   # 有a个字母的单词会属于a个桶!!
            bucket = word[:i] + &amp;quot;_&amp;quot; + word[i+1:]    # 对于单词的每一个字母
            if bucket in d:         # 如果已经有了这个桶，直接加入，没有的话新建桶用bucket当做key
                d[bucket].append(word)
            else:  
                d[bucket] = [word]
            
    # 桶内建立边
    for bucket in d.keys():          # 对每一个桶
        for word1 in d[bucket]:     
            for word2 in d[bucket]:
                if word1!=word2:    # 对于桶内的每对单词，建边
                    g.addEdge(word1, word2)  # 默认权重0，相当于无权重
    
    return g   # 就是各个单词的图

wordslink = buildGraph(&#39;fourletterwords.txt&#39;)  
print(wordslink.getVertex(&#39;SAIL&#39;))
#wordslink.getVertices()
length = 0
for key in wordslink.getVertices():
    length += len(wordslink.getVertex(key).connectedTo)
print(&amp;quot;\n 单词数量={}，邻接表的边数目={}，如果用邻接矩阵单元数目将会是={} &amp;quot;.format(wordslink.numVertices ,length, wordslink.numVertices *wordslink.numVertices))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SAIL connectedTo: [&#39;BAIL&#39;, &#39;FAIL&#39;, &#39;HAIL&#39;, &#39;JAIL&#39;, &#39;KAIL&#39;, &#39;MAIL&#39;, &#39;NAIL&#39;, &#39;PAIL&#39;, &#39;RAIL&#39;, &#39;TAIL&#39;, &#39;VAIL&#39;, &#39;WAIL&#39;, &#39;SAID&#39;, &#39;SAIN&#39;, &#39;SOIL&#39;, &#39;SALL&#39;, &#39;SAUL&#39;]

 单词数量=3838，邻接表的边数目=42004，如果用邻接矩阵单元数目将会是=14730244 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;广度优先搜索bfs&#34;&gt;广度优先搜索BFS&lt;/h2&gt;
&lt;h3 id=&#34;初步理解&#34;&gt;初步理解&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;给定一个图G和搜索的起始顶点S，搜索所有从s可到顶点的边&lt;/li&gt;
&lt;li&gt;可以想象为s作为根节点，构建一颗多叉树的过程&lt;/li&gt;
&lt;li&gt;**“广度优先”**意味着在增加搜索距离到k+1/加深层次之前，把所有兄弟节点/距离为k的顶点都找到&lt;/li&gt;
&lt;li&gt;产生的问题：有一些节点到S有不同路径，导致距离不同——如何解决？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;跟踪顶点加入过程给顶点增加属性&#34;&gt;跟踪顶点加入过程——给顶点增加属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;距离distance：起始S到当前顶点的路径&lt;/li&gt;
&lt;li&gt;前驱顶点 predecessor：反向追溯&lt;/li&gt;
&lt;li&gt;标识color：白色：尚未发现；灰色：已经发现；完成探索：黑色&lt;/li&gt;
&lt;li&gt;队列：对已经发现的顶点进行排序&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 首先扩展一下vertex类，加入三个属性
class Vertex:
    def __init__(self, key):
        self.id = key                  # 用id保存key
        self.connectedTo = {}     # 字典保存，非常类似昨天10.14写的ID3里对于多叉数的节点定义
        self.distance = None
        self.pred = None
        self.color = &amp;quot;white&amp;quot;
        
    def addNeighbor(self, nbr, weight = 0):    # nbr——链接的对象的key
        self.connectedTo[nbr]=weight            # 加入connection里，并赋边的权重
    
    def __str__(self):
        return str(self.id) +&#39; connectedTo: &#39;  +str([x.id for x in self.connectedTo])

    def getId(self):                      # 获得id
        return self.id
    
    def getConnections(self):       # 该顶点链接的所有顶点的key
        return self.connectedTo.keys()
        
    def getWeight(self,nbr):              # 查看两个顶点的边权重
        return self.connectedTo[nbr]   # 字典按照key索引
    
    ##### 增加部分 ######
    def setDistance(self, x):   # 设置距离
        self.distance = x
        
    def setPred(self, x):     # 设置前驱顶点
        self.pred = x
        
    def setColor(self, x):    # 设置颜色标识
        self.color = x
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;算法过程&#34;&gt;算法过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一步、从起始顶点S开始（颜色灰色，距离0，前驱none，加入队列）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二步、迭代：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从队首pop出一个顶点，作为current顶点&lt;/li&gt;
&lt;li&gt;遍历current顶点的connected顶点，如果是白色，则：改为灰色、距离+1、前驱设为current顶点、加入队列）&lt;/li&gt;
&lt;li&gt;遍历结束后，把current顶点设为黑色&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最终的结果：所有的顶点都有颜色黑色、距离X、前驱X，可以根据前驱一步步找回起始顶点S——一条路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def bfs(g,start):   # 按照上述写成函数
    # 第一步
    queue = []
    start.setDistance(0)
    start.setColor(&amp;quot;grey&amp;quot;)
    queue.append(start)
    
    # 第二步
    while len(queue)&amp;gt;0:
        current = queue.pop(0)
        for node in current.connectedTo:
            if node.color == &amp;quot;white&amp;quot;:
                node.setColor(&amp;quot;grey&amp;quot;)
                node.setDistance(current.distance+1)
                node.setPred(current)
                queue.append(node)
        current.setColor(&amp;quot;black&amp;quot;)

    # 第三步
def traverse(y):   # 根据pred来回溯
    x = y
    path = []
    while x.pred:  # 顶点有predecessor时
        path.append(x.id)
        x = x.pred   # 继续向上
    path.append(x.id)
    path.reverse()
    return path


# 测试
wordslink = buildGraph(&#39;fourletterwords.txt&#39;)  
bfs(wordslink,  wordslink.getVertex(&#39;FOOL&#39;))  # 给出图和起始顶点
res = traverse(wordslink.getVertex(&#39;SAGE&#39;))
print(&amp;quot;词梯问题的一个解：\n&amp;quot;+ &#39; -&amp;gt; &#39;.join(res))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;词梯问题的一个解：
FOOL -&amp;gt; MOOL -&amp;gt; MOLL -&amp;gt; MALL -&amp;gt; SALL -&amp;gt; SALE -&amp;gt; SAGE
&lt;/code&gt;&lt;/pre&gt;
">图——广度优先搜索BFS（词梯问题）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/python-shi-xian-jue-ce-shu-id3-suan-fa/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE&#34;&gt;1.读入数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E5%AE%9A%E4%B9%89%E8%AE%A1%E7%AE%97%E7%86%B5%E7%9A%84%E5%87%BD%E6%95%B0&#34;&gt;2.定义计算熵的函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E6%A0%B9%E6%8D%AE%E7%89%B9%E5%BE%81%E5%88%86%E5%89%B2%E6%A0%B7%E6%9C%AC&#34;&gt;3.根据特征分割样本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4%E9%80%89%E6%8B%A9%E6%9C%80%E4%BD%B3%E7%89%B9%E5%BE%81&#34;&gt;4.选择最佳特征&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAclass%E6%8A%8Abuild%E7%9A%84%E7%BB%93%E6%9E%9C%E5%AD%98%E6%88%90%E4%B8%80%E4%B8%AAtree&#34;&gt;5.定义一个class，把build的结果存成一个tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;思路：&lt;/p&gt;
&lt;p&gt;第一步：定义函数——计算熵：&lt;/p&gt;
&lt;p&gt;输入：某个样本集合的因变量数据，输出计算出的熵&lt;/p&gt;
&lt;p&gt;第二步：定义函数——根据特征分割样本集合&lt;/p&gt;
&lt;p&gt;输入：总样本集合df、某个特征，输出划分后的各个样本子集sub_df&lt;/p&gt;
&lt;p&gt;第三步：定义函数——选择最佳特征&lt;/p&gt;
&lt;p&gt;输入：样本集合、特征集合，选出能够最大化gain的最佳特征，输出最佳特征、gain值、用第二步得到的分割结果&lt;/p&gt;
&lt;p&gt;第四步：定义class——递归生成决策树&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心函数：生成决策树&lt;/strong&gt;&lt;br&gt;
1.根据第三步函数进行&lt;br&gt;
2.结束条件：输出最佳特征为None&lt;br&gt;
3.递归部分：对每一个子集做递归&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他函数&lt;/strong&gt;：定义节点——联系二叉树结构&lt;/p&gt;
&lt;h2 id=&#34;1读入数据&#34;&gt;1.读入数据&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#### 1.读入数据
import os
import pandas as pd
import numpy as np
from math import log  # 计算信息熵要用

## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    

## 分类变量——转化为虚拟变量
os.chdir(&amp;quot;/Users/mac/Desktop/快乐研一/python/机器学习python实现&amp;quot;)
df = pd.read_csv(&amp;quot;example_data.csv&amp;quot;)
df.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;humility&lt;/th&gt;
      &lt;th&gt;outlook&lt;/th&gt;
      &lt;th&gt;temp&lt;/th&gt;
      &lt;th&gt;windy&lt;/th&gt;
      &lt;th&gt;play&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;high&lt;/td&gt;
      &lt;td&gt;sunny&lt;/td&gt;
      &lt;td&gt;hot&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;high&lt;/td&gt;
      &lt;td&gt;sunny&lt;/td&gt;
      &lt;td&gt;hot&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;high&lt;/td&gt;
      &lt;td&gt;overcast&lt;/td&gt;
      &lt;td&gt;hot&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;high&lt;/td&gt;
      &lt;td&gt;rainy&lt;/td&gt;
      &lt;td&gt;mild&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;normal&lt;/td&gt;
      &lt;td&gt;rainy&lt;/td&gt;
      &lt;td&gt;cool&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;2定义计算熵的函数&#34;&gt;2.定义计算熵的函数&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#### 2.定义计算熵的函数
#  前置问题
tmp_y = df[&#39;play&#39;].tolist()      # 转化为list，方便后面迭代
set(tmp_y)                         # 因变量的类别
[tmp_y.count(i) for i in set(tmp_y)]   # 各类别的样本比例

# 正式定义函数计算信息熵
def information(data_y):  
    # 信息熵 = -sum(p*log2p)
    data_y  = data_y.tolist()
    probs = [data_y.count(i)/len(data_y) for i in set(data_y)]
    entropy = [prob*log(prob,2) for prob in probs]
    sum_entropy = -sum(entropy)
    return sum_entropy

# 测试
information(df[&#39;play&#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&#39;no&#39;, &#39;yes&#39;}






[5, 9]






0.9402859586706309
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3根据特征分割样本&#34;&gt;3.根据特征分割样本&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#### 3.根据特征分割样本
# 前置问题1——怎么subset？
df[df[&#39;outlook&#39;]==&amp;quot;sunny&amp;quot;]    # 选择出outlook变量等于sunny的样本子集
# 前置问题2——怎么输出多个子集——字典{key:df}
pd.DataFrame   # 定义一个空的df
aa = {types: pd.DataFrame for types in set(df[&#39;outlook&#39;])}    # 定义一个空的字典用于存放所有子集
aa
aa.keys()


# 正式定义函数
def split_df(data,col):
    &#39;&#39;&#39;
    输入：data——df数据集，col——列名，根据col这一列的取值来分割data
    输出：字典，每一个key是col取值，对应value是子集
    &#39;&#39;&#39;
    types = set(data[col].tolist())
    sub_df  = {i:pd.DataFrame for i in types}      # 定义一个存放子集集合的空字典
    for key in sub_df.keys():
        sub_df[key] = data[data[col]==key]         # 把对应的子集填入空字典
    return sub_df

# 测试
sub_df = split_df(df,&#39;temp&#39;)
sub_df[&#39;mild&#39;][&#39;play&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;humility&lt;/th&gt;
      &lt;th&gt;outlook&lt;/th&gt;
      &lt;th&gt;temp&lt;/th&gt;
      &lt;th&gt;windy&lt;/th&gt;
      &lt;th&gt;play&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;high&lt;/td&gt;
      &lt;td&gt;sunny&lt;/td&gt;
      &lt;td&gt;hot&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;high&lt;/td&gt;
      &lt;td&gt;sunny&lt;/td&gt;
      &lt;td&gt;hot&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;high&lt;/td&gt;
      &lt;td&gt;sunny&lt;/td&gt;
      &lt;td&gt;mild&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;8&lt;/th&gt;
      &lt;td&gt;normal&lt;/td&gt;
      &lt;td&gt;sunny&lt;/td&gt;
      &lt;td&gt;cool&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;10&lt;/th&gt;
      &lt;td&gt;normal&lt;/td&gt;
      &lt;td&gt;sunny&lt;/td&gt;
      &lt;td&gt;mild&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;pandas.core.frame.DataFrame






{&#39;overcast&#39;: pandas.core.frame.DataFrame,
 &#39;rainy&#39;: pandas.core.frame.DataFrame,
 &#39;sunny&#39;: pandas.core.frame.DataFrame}






dict_keys([&#39;overcast&#39;, &#39;rainy&#39;, &#39;sunny&#39;])






3     yes
7      no
9     yes
10    yes
11    yes
13     no
Name: play, dtype: object
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4选择最佳特征&#34;&gt;4.选择最佳特征&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#### 选择最佳特征
# 前置知识——给出所有自变量的colname
[col for col in df.columns if col!=&#39;play&#39;]

# 正式定义函数
def choose_col(data,col_y):
    &#39;&#39;&#39;
    输入：样本集合、特征集合，从各个特征中选出能够最大化gain的最佳特征
    
    设输出的初始值max_gain = 0（gain 的取值范围为0~logn)
    for每一个特征：
        调用split_df分割数据，for 分割后的每一个子集，调用information 计算条件熵，再按照样本比例加权求和
        差值计算信息增益，如果大于前一个，更新输出值

    输出：最佳特征、gain值、用第二步得到的分割结果
    &#39;&#39;&#39;
    entroy_D = information(data[col_y])       # 计算全集上的信息熵
    colnames_x = [col for col in data.columns if col!=col_y]   # 自变量的列名
    max_gain = -1   # 设定gain初始值
    max_col = None
    max_df = None
    
    for col_x in colnames_x:                   # 对于所有特征
        sub_df = split_df(data,col_x)         # 按照某个特征分割
        entroy_sub = []                            # 用于保存各个子集信息熵*权重的list
        
        for key in sub_df.keys():                # 对于每一个子集
            sub_y = sub_df[key][col_y]
            entroy_sub.append(information(sub_y)*len(sub_y)/len(data[col_y]))   # 子集计算信息熵*权重
        entroy_x  = sum(entroy_sub)
        gain_x = entroy_D-entroy_x

        if gain_x&amp;gt; max_gain:         # 如果信息增益增大了，更新输出值
            max_gain = gain_x
            max_col = col_x
            max_df = sub_df
    return max_gain, max_col, max_df

# 测试
choose_col(df,&#39;play&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&#39;humility&#39;, &#39;outlook&#39;, &#39;temp&#39;, &#39;windy&#39;]






(0.246749819774439,
 &#39;outlook&#39;,
 {&#39;overcast&#39;:    humility   outlook  temp  windy play
  2      high  overcast   hot  False  yes
  6    normal  overcast  cool   True  yes
  11     high  overcast  mild   True  yes
  12   normal  overcast   hot  False  yes,
  &#39;rainy&#39;:    humility outlook  temp  windy play
  3      high   rainy  mild  False  yes
  4    normal   rainy  cool  False  yes
  5    normal   rainy  cool   True   no
  9    normal   rainy  mild  False  yes
  13     high   rainy  mild   True   no,
  &#39;sunny&#39;:    humility outlook  temp  windy play
  0      high   sunny   hot  False   no
  1      high   sunny   hot   True   no
  7      high   sunny  mild  False   no
  8    normal   sunny  cool  False  yes
  10   normal   sunny  mild   True  yes})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 前置知识1，如何定义一个有更多叉的数结构的节点，name是他自己，connections存储链接的所有子节点
class Node:
    def __init__(self,name):
        self.name = name
        self.connections = {}    # 存储所有子节点的信息      
    def connect(self,label,node):  # 链接到子节点
        self.connections[label] = node
# 测试
parent = Node(&#39;root&#39;)
child1 = Node(&#39;child1&#39;)
child2 = Node(&#39;child2&#39;)
parent.connect(&#39;A&#39;,child1)
parent.connect(&#39;B&#39;,child2)
parent.connections


#  前置知识2 核心函数：生成决策树**
# 结束条件：输出最佳特征为None
# 递归部分：对每一个子集做递归
def build(data, col_x, col_y):
    # 结束条件
    if len(data)==0 or len(col_x)==0:
        return 
    # 递归
    current_gain, current_col, current_df = choose_col(data[col_x+[col_y]], col_y)   # 对剩余的特征空间寻找
    print(current_gain, current_col, current_df.keys())
    col_x_new = [_ for _ in col_x if _ not in [current_col]]    # 更新剩余的特征空间
    
    for i in current_df.keys():            # 对于每一个子集
        build(current_df[i], col_x_new, col_y)       # 递归调用

# 测试
build(df,[&#39;humility&#39;, &#39;outlook&#39;, &#39;temp&#39;, &#39;windy&#39;],&#39;play&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&#39;A&#39;: &amp;lt;__main__.Node at 0x116459a58&amp;gt;, &#39;B&#39;: &amp;lt;__main__.Node at 0x11645ceb8&amp;gt;}



0.246749819774439 outlook dict_keys([&#39;overcast&#39;, &#39;rainy&#39;, &#39;sunny&#39;])
-0.0 humility dict_keys([&#39;high&#39;, &#39;normal&#39;])
-0.0 temp dict_keys([&#39;mild&#39;, &#39;hot&#39;])
-0.0 windy dict_keys([True])
-0.0 windy dict_keys([False])
-0.0 temp dict_keys([&#39;hot&#39;, &#39;cool&#39;])
-0.0 windy dict_keys([False])
-0.0 windy dict_keys([True])
0.9709505944546686 windy dict_keys([False, True])
-0.0 humility dict_keys([&#39;high&#39;, &#39;normal&#39;])
-0.0 temp dict_keys([&#39;mild&#39;])
-0.0 temp dict_keys([&#39;mild&#39;, &#39;cool&#39;])
-0.0 humility dict_keys([&#39;normal&#39;, &#39;high&#39;])
-0.0 temp dict_keys([&#39;cool&#39;])
-0.0 temp dict_keys([&#39;mild&#39;])
0.9709505944546686 humility dict_keys([&#39;high&#39;, &#39;normal&#39;])
-0.0 temp dict_keys([&#39;mild&#39;, &#39;hot&#39;])
-0.0 windy dict_keys([False])
-0.0 windy dict_keys([False, True])
-0.0 temp dict_keys([&#39;mild&#39;, &#39;cool&#39;])
-0.0 windy dict_keys([True])
-0.0 windy dict_keys([False])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5定义一个class把build的结果存成一个tree&#34;&gt;5.定义一个class，把build的结果存成一个tree&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#  定义一个class，把build的结果存成一个tree
class ID3Tree:    

    class Node:       # 定义节点  
        def __init__(self, name):
            self.name = name
            self.connections = {}    
            
        def connect(self, label, node):   # 节点对应多个子节点
            self.connections[label] = node    
        
    def __init__(self, data, label):     # 需要给出data和因变量label
        self.columns = data.columns
        self.data = data
        self.label = label
        self.root = self.Node(&amp;quot;Root&amp;quot;)       # 初始化一个根节点
        
    def construct_tree(self):
        self.construct(self.root, &amp;quot;&amp;quot;, self.data, self.columns)    # 输入父节点、父节点的取值、当前样本集合、剩余特征集合
    
    def construct(self, parent_node, parent_connection_label, input_data, columns):
        max_value, best_col, max_splited = choose_col(input_data[columns], self.label)
        if (not best_col) or max_value==0:    # 结束条件，1.没有剩余特征2.样本集合为空3.已经归于同一类
            node = self.Node(input_data[self.label].iloc[0])   
            parent_node.connect(parent_connection_label, node)   # 设为叶节点         
            return
        node = self.Node(best_col)    # 生成新节点
        parent_node.connect(parent_connection_label, node)
        
        new_columns = [col for col in columns if col != best_col]        # 更新剩余特征集合
        for splited_value, splited_data in max_splited.items():             # 对于新子集，递归
            self.construct(node, splited_value, splited_data, new_columns)
            
    def print_tree(self, node, tabs):
        print(tabs + node.name)        
        for connection, child_node in node.connections.items():
            print(tabs + &amp;quot;\t&amp;quot; + &amp;quot;(&amp;quot; + str(connection) + &amp;quot;)&amp;quot;)
            self.print_tree(child_node, tabs + &amp;quot;\t\t&amp;quot;) 

df
mytree = ID3Tree(df,&#39;play&#39;)
mytree.construct_tree()
mytree.print_tree(mytree.root,&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;humility&lt;/th&gt;
      &lt;th&gt;outlook&lt;/th&gt;
      &lt;th&gt;temp&lt;/th&gt;
      &lt;th&gt;windy&lt;/th&gt;
      &lt;th&gt;play&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;high&lt;/td&gt;
      &lt;td&gt;sunny&lt;/td&gt;
      &lt;td&gt;hot&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;high&lt;/td&gt;
      &lt;td&gt;sunny&lt;/td&gt;
      &lt;td&gt;hot&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;high&lt;/td&gt;
      &lt;td&gt;overcast&lt;/td&gt;
      &lt;td&gt;hot&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;high&lt;/td&gt;
      &lt;td&gt;rainy&lt;/td&gt;
      &lt;td&gt;mild&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;normal&lt;/td&gt;
      &lt;td&gt;rainy&lt;/td&gt;
      &lt;td&gt;cool&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;normal&lt;/td&gt;
      &lt;td&gt;rainy&lt;/td&gt;
      &lt;td&gt;cool&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;td&gt;normal&lt;/td&gt;
      &lt;td&gt;overcast&lt;/td&gt;
      &lt;td&gt;cool&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;high&lt;/td&gt;
      &lt;td&gt;sunny&lt;/td&gt;
      &lt;td&gt;mild&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;8&lt;/th&gt;
      &lt;td&gt;normal&lt;/td&gt;
      &lt;td&gt;sunny&lt;/td&gt;
      &lt;td&gt;cool&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;9&lt;/th&gt;
      &lt;td&gt;normal&lt;/td&gt;
      &lt;td&gt;rainy&lt;/td&gt;
      &lt;td&gt;mild&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;10&lt;/th&gt;
      &lt;td&gt;normal&lt;/td&gt;
      &lt;td&gt;sunny&lt;/td&gt;
      &lt;td&gt;mild&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;11&lt;/th&gt;
      &lt;td&gt;high&lt;/td&gt;
      &lt;td&gt;overcast&lt;/td&gt;
      &lt;td&gt;mild&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12&lt;/th&gt;
      &lt;td&gt;normal&lt;/td&gt;
      &lt;td&gt;overcast&lt;/td&gt;
      &lt;td&gt;hot&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
      &lt;td&gt;yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;13&lt;/th&gt;
      &lt;td&gt;high&lt;/td&gt;
      &lt;td&gt;rainy&lt;/td&gt;
      &lt;td&gt;mild&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
      &lt;td&gt;no&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Root
	()
		outlook
			(overcast)
				yes
			(rainy)
				windy
					(False)
						yes
					(True)
						no
			(sunny)
				humility
					(high)
						no
					(normal)
						yes
&lt;/code&gt;&lt;/pre&gt;
">手动实现——决策树ID3算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py10.14/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B9%B3%E8%A1%A1%E7%9A%84%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91avl&#34;&gt;平衡的二叉查找树——AVL&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%97%AE%E9%A2%98&#34;&gt;复杂度问题：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8F%92%E5%85%A5%E6%96%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%97%B6&#34;&gt;插入新叶节点时：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A6%82%E4%BD%95%E9%87%8D%E6%96%B0%E5%B9%B3%E8%A1%A1%E6%97%8B%E8%BD%AC&#34;&gt;如何重新平衡——旋转：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E5%B9%B3%E8%A1%A1%E5%9B%A0%E5%AD%90&#34;&gt;如何调整平衡因子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%81%BF%E5%85%8D%E6%AD%BB%E8%83%A1%E5%90%8C&#34;&gt;避免死胡同&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8E%9F%E6%9C%AC%E8%B5%8B%E5%80%BC%E6%96%B9%E6%B3%95&#34;&gt;原本赋值方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E8%B5%8B%E5%80%BC%E6%96%B9%E6%B3%95&#34;&gt;修改后的赋值方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;平衡的二叉查找树avl&#34;&gt;平衡的二叉查找树——AVL&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;如何保持树的平衡，需要对每个节点跟踪一个“平衡因子”参数&lt;/li&gt;
&lt;li&gt;平衡因子：左右子树的高度差&lt;/li&gt;
&lt;li&gt;当每个节点的平衡因子在-1，0，1之间——平衡树&lt;/li&gt;
&lt;li&gt;当有节点的平衡因子超过范围——需要重新平衡&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;复杂度问题&#34;&gt;复杂度问题：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;get方法：问题规模——总结点数，对比次数——深度&lt;/li&gt;
&lt;li&gt;考虑最差情况下，左重avl，总节点数和的序列很接近fib——时间复杂度o(logn)&lt;/li&gt;
&lt;li&gt;put方法呢？1.需要更新一些父节点2.重新平衡最多旋转两次——时间复杂度还是o(logn)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;插入新叶节点时&#34;&gt;插入新叶节点时：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;作为右子节点插入，父节点的平衡度-1，反之+1&lt;/li&gt;
&lt;li&gt;这种影响会一直传递，直到某个父节点的平衡度被调整到0，不再向上影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何重新平衡旋转&#34;&gt;如何重新平衡——旋转：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;右重子树左旋转，左重子树右旋转&lt;/li&gt;
&lt;li&gt;举个例子，一个左重子树A，旋转之后将新根节点B（他的左子节B）的新右子节点A，但是如果原本这个新根节点B有右子节点C了， 就用A替换掉C， 把旧的右子节C改到旋转后的A的左子节点上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何调整平衡因子&#34;&gt;如何调整平衡因子&lt;/h3&gt;
&lt;p&gt;新平衡因子和旧平衡因子之间的关系&lt;/p&gt;
&lt;h3 id=&#34;避免死胡同&#34;&gt;避免死胡同&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;右重左旋转——》左重——》再旋转&lt;/li&gt;
&lt;li&gt;先检查，左旋转之前，检查右子节点的因子；右旋转之前，检查左子节点的平衡度&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;原本赋值方法&#34;&gt;原本赋值方法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#### 原本赋值方法
    def put(self, key,val):
        if self.root:   # 如果是空树，直接作为root，如果不是就调用_put
            self._put(key,val,self.root)
        else:
            self.root = TreeNode(key,val)  
            self.size = self.size+1  
    
    def _put(self,key,val,currentNode):   # 辅助方法
        if key &amp;lt; currentNode.key:  # 大就放在右节点，但如果有了右子树，递归到下一级
            if currentNode.hasleftchild():  
                self._put(key,val, currentNode.leftchild)  # 递归
            else:
                currentNode.leftchild = TreeNode(key,val,parent =currentNode)
        else:
            if currentNode.hasrightchild():
                self._put(key,val,currentNode.rightchild)
            else:
                currentNode.rightchild = TreeNode(key,val,parent =currentNode)
   
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;修改后的赋值方法&#34;&gt;修改后的赋值方法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 修改后的赋值方法
    def _put(self,key,val,currentNode):   # 辅助方法
        if key &amp;lt; currentNode.key:  # 大就放在右节点，但如果有了右子树，递归到下一级
            if currentNode.hasleftchild():  
                self._put(key,val, currentNode.leftchild)  # 递归
            else:
                currentNode.leftchild = TreeNode(key,val,parent =currentNode)
                self.updateBalance(currentNode.leftchild)
        else:
            if currentNode.hasrightchild():
                self._put(key,val,currentNode.rightchild)
            else:
                currentNode.rightchild = TreeNode(key,val,parent =currentNode)
                self.updateBalance(currentNode.rightchild)
    
    def updataBalance(self,node) :  # 递归调整平衡因子的大小
        if node.balanceFactor&amp;gt;1 or node.balanceFacotr&amp;lt;-1:
            self.rebalance(node)        # 如果不平衡了需要重新调整了
            return
        if not node.parent==None:    # 结束条件：到了根节点
            if node.isleftchild():
                node.parent.balanceFactor +=1
            elif node.isrightchild():
                node.parent.balanceFactor -=1
            if node.parent.balanceFactor!=0:
                self.updateBalance(node.parent)    #递归调整父节点
    
    def rotateLeft(self,rotRoot): # 需要旋转的那个节点
        newRoot= rotRoot.rightchild
        rotRoot.rightchild = newRoot.leftchild
        if newRoot.rightchild!=None: #如果原本有节点
            newRoot.leftchild.parent = rotRoot
        newRoot.parent = rotRoot.parent
        if rotRoot.isRoot():    
            self.root = newwRoot
        else :
            if rotRoot.isleftchild():
                rotRoot.parent.leftchild= newRoot
            else:
                rotBoot.parent.rightchild=newRoot
        newRoot.leftchild=rotRoot
        rotRoot.parent = newRoot
        rotRoot.balanceFactor = rotRoot.balanceFactor+1-min(newRoot.balanceFactor,0)
        newwRoot.balanceFactor =newRoot.balanceFactor+1+max(rotRoot.balanceFactor,0)
    
    def rotateRight(self,rotRoot): # 需要旋转的那个节点
        newRoot= rotRoot.leftchild
        rotRoot.leftchild = newRoot.rightchild
        if newRoot.leftchild!=None: #如果原本有节点
            newRoot.rightchild.parent = rotRoot
        newRoot.parent = rotRoot.parent
        if rotRoot.isRoot():    
            self.root = newRoot
        else :
            if rotRoot.isrightchild():
                rotRoot.parent.rightchild= newRoot
            else:
                rotBoot.parent.leftchild=newRoot
        newRoot.rightchild=rotRoot
        rotRoot.parent = newRoot
        rotRoot.balanceFactor = rotRoot.balanceFactor+1-min(newRoot.balanceFactor,0)
        newwRoot.balanceFactor =newRoot.balanceFactor+1+max(rotRoot.balanceFactor,0)
    
    def rebalance(self,node):
        if node.balanceFactor&amp;lt;0:
            if node.rigthchild.balanceFactor&amp;gt;0:
                ### 需要先旋转右子节点再旋转本身
                self.rotateRight(node.rightchild)
                self.rotateLeft(node)
            else: self.rotateLeft(node)   # 没有问题只旋转自己
        elif node.balanceFactor&amp;gt;0:
            if node.leftchild.balanceFactor&amp;lt;0:
                self.rotateLeft(node.leftchild)
                self.rotateRight(node)
            else:self.rotateRight(node)
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;x&lt;/th&gt;
&lt;th&gt;有序表&lt;/th&gt;
&lt;th&gt;散列&lt;/th&gt;
&lt;th&gt;二叉查找树&lt;/th&gt;
&lt;th&gt;avl&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;put&lt;/td&gt;
&lt;td&gt;o(n)&lt;/td&gt;
&lt;td&gt;o(1)-o(n)&lt;/td&gt;
&lt;td&gt;o(logn)-o(n)&lt;/td&gt;
&lt;td&gt;o(logn)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;get&lt;/td&gt;
&lt;td&gt;o(logn)&lt;/td&gt;
&lt;td&gt;o(1)-o(n)&lt;/td&gt;
&lt;td&gt;o(logn)-o(n)&lt;/td&gt;
&lt;td&gt;o(logn)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
">AVL树</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/shi-jian-guan-li-da-shi/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1602921323621.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;最近和朋友常聊关于时间和效率的问题&lt;/p&gt;
&lt;h2 id=&#34;focus&#34;&gt;focus&lt;/h2&gt;
&lt;p&gt;想学的东西永远很多，机器学习/数据结构/leetcode/kaggle/实习/python/java/linux/sql...如果只用GPA衡量能力，那该有多轻松...不要过度在意GPA/在意某次作业的得分。积累知识/挖掘潜力当然重要，但如果和兴趣或者未来希望从事的方向相差太远，一定要敢于放弃掉！&lt;/p&gt;
&lt;h2 id=&#34;行动而不是胡思乱想&#34;&gt;行动而不是胡思乱想&lt;/h2&gt;
&lt;p&gt;适度的同辈压力可以帮你提高学习效率，但是过分在意别人的状态，通常嫉妒过后只剩下自卑感，认定自己“基础不好”或者“什么也做不好”。生活全靠经营，还是要相信努力会有收获，即使这份回报不是即时或者显示的。&lt;/p&gt;
&lt;h2 id=&#34;完美主义者&#34;&gt;完美主义者&lt;/h2&gt;
&lt;p&gt;“她做着3份实习，谈着甜甜的恋爱，学习还能不落下”&lt;/p&gt;
&lt;p&gt;其实你真的真的已经很棒了（北大&amp;amp;有明确目标&amp;amp;对人友好真诚，在我心里就是坠棒滴！）很多时候我们觉得某个人很厉害，只需要对方有一个闪光点就够了。对自己也是一样的呀，没必要苛求完美。对有些人来说，承认自己的优点有时候比勇敢地谈谈缺点更难。&amp;quot;Good enough&amp;quot; is better than &amp;quot;perfect&amp;quot;.&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1602595914242.jpg&#34; alt=&#34;与自己和解&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">时间管理大师</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py1012-13/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#1012&#34;&gt;10.12&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91&#34;&gt;二叉查找树&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95&#34;&gt;前置知识：特殊方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86yield&#34;&gt;前置知识：yield&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%88%E5%BA%8F-%E4%B8%AD%E5%BA%8F-%E5%90%8E%E5%BA%8F&#34;&gt;先序、中序、后序&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%80%E7%AE%80%E5%8D%95%E7%94%A8%E9%80%92%E5%BD%92-%E5%A4%8D%E6%9D%82%E5%BA%A6on&#34;&gt;最简单——用递归 复杂度o(n)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%8A%A0%E7%9B%B4%E8%A7%82%E7%9A%84%E4%BE%8B%E5%AD%90&#34;&gt;一个更加直观的例子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%80%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0&#34;&gt;中序遍历——一个栈实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%83%E4%B9%A0%E7%86%9F%E6%82%89&#34;&gt;练习，熟悉&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1013&#34;&gt;10.13&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#remove&#34;&gt;remove&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%83%E4%B9%A0&#34;&gt;练习&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;p&gt;学习目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二叉查找树&lt;/li&gt;
&lt;li&gt;AVL树&lt;/li&gt;
&lt;li&gt;树结构练习题&lt;/li&gt;
&lt;li&gt;搭建自己的github主页&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;1012&#34;&gt;10.12&lt;/h1&gt;
&lt;h1 id=&#34;二叉查找树&#34;&gt;二叉查找树&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;性质：比父节点小的key都出现在左子树，其他的出现在右子树&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;由于插入顺序不同，生成的bst也不同&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;前置知识特殊方法&#34;&gt;前置知识：特殊方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;诸如__xxx__（前后两个下划线，中间是方法名）&lt;/li&gt;
&lt;li&gt;自己不需要调用它们，使用内置函数来用&lt;/li&gt;
&lt;li&gt;例如__len__，使用时用len(xx)而不是xx.len()，其实是调用xx.&lt;strong&gt;len&lt;/strong&gt;()&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;前置知识yield&#34;&gt;前置知识：yield&lt;/h2&gt;
&lt;p&gt;例子——fib&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一种：返回一个list，用迭代print出来（运行中占用的内存会随着参数n_max的增大而增大）&lt;/li&gt;
&lt;li&gt;第二种：通过 iterable 对象来迭代，内存占用小&lt;/li&gt;
&lt;li&gt;第三种：yield，保留第一种方法的简洁性同时获得iterable的效果&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 第一种
print(&#39;第1种&#39;)
def fib(n_max):
    listx = []
    n,a,b = 1,0,1
    while n &amp;lt;= n_max:
        listx.append(b)
        a,b = b, a+b
        n += 1
    return listx

for i in fib(6): print(i)

    
    
print(&#39;\n 第2种&#39;)
### 第二种
# 思路，通过next不断返回序列的下一个数字，把fab写成一个支持iterable 的class
class Fib(object):
    def __init__(self,n_max):
        self.max = n_max
        self.n,self.a,self.b = 1,0,1
        
    def __iter__(self):   
        return self
    
    def __next__(self):
        if self.n&amp;lt;=self.max:
            self.a,self.b = self.b, self.a+self.b
            self.n +=1
            return self.a
        raise StopIteration()   # 如果超过就推出循环

for n in Fib(6): print(n)
    
    
    
print(&#39;\n 第3种&#39;)  
### 第三种 使用yield
def fib(n_max):
    n, a, b = 1, 0, 1
    while n&amp;lt;= n_max:
        yield b     # 迭代时可看做return，只是fib变成一个生成器
        a,b, = b, a+b
        n = n+1

for n in fib(6): print(n)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;第1种
1
1
2
3
5
8

 第2种
1
1
2
3
5
8

 第3种
1
1
2
3
5
8
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 实现一个二叉搜索树：
        
### 1.node
class TreeNode:  # 键值、数据项、左右节点、父节点
    def __init__(self,key,val,left = None,right = None,parent =None):
        self.key = key
        self.payload =val
        self.leftchild=left
        self.rightchild = right
        self.parent = parent
        
    def hasleftchild(self):
        return self.leftchild
    
    def hasrightchild(self):
        return self.rightchild
    
    def hasanychild(self):
        return self.rightchild or self.leftchild
    
    def hasbothchild(self):
        return self.rightchild and self.leftchild
    
    def isleftchild(self):
        return self.parent and self.parent.leftchild==self
    
    def isrightchild(self):    # 父节点&amp;amp;是否是右子节点
        return self.parent and self.parent.rightchild==self
    
    def isroot(self):    # 是否是根节点
        return not self.parent 
    
    def isleaf(self):
        return not (self.leftchild or self.rightchild)
    
    def replaceNodeData(self,key,value,lc,rc):
        self.key = key
        self.payload = value
        self.leftchild = lc
        self.rigthchild = rc      # 新的子节点
        if self.hasleftchild():    #如果原本有子节点，链接到修改后的父节点
            self.leftchild.parent = self
        if self.hasrightchild():
            self.rightchild.parent=self
    
    def __iter__(self):  # 迭代器
        if self:
            if self.hasleftchild():
                for elem in self.leftchild:
                    yield elem    # 对每次迭代的返回值
            yield self.key
            if self.hasrightchild():
                for elem in self.rightchild:
                    yield elem
                    
    def findMin(self): 
        current = self
        while current.hasleftchild():   # 顺着左子树一直找
            current = current.leftchild
        return current
    
    def findSuccessor(self):    # 寻找后继(只考虑基本情况)
        succ = None
        if self.hasrightchild():
            succ = self.rightchild.findMin()
        return succ
    
    def spliceOut(self):  # 摘除叶节点
        if self.isleaf():
            if self.isleftchild():
                self.parent.leftchild = None
            else:
                self.parent.rightchild = None
                

### 2.BST
class BinarySearchTree:
    def __init__(self):
        self.root = None
        self.size = 0
    
    def length(self):
        return self.size
    
    def __len__(self):
        return self.size
    
    def __iter__(self):
        return self.root.__iter__()
    
    
    #### 赋值方法
    def put(self, key,val):
        if self.root:   # 如果是空树，直接作为root，如果不是就调用_put
            self._put(key,val,self.root)
        else:
            self.root = TreeNode(key,val)  
            self.size = self.size+1  
    
    def _put(self,key,val,currentNode):   # 辅助方法
        if key &amp;lt; currentNode.key:  # 大就放在右节点，但如果有了右子树，递归到下一级
            if currentNode.hasleftchild():  
                self._put(key,val, currentNode.leftchild)  # 递归
            else:
                currentNode.leftchild = TreeNode(key,val,parent =currentNode)
        else:
            if currentNode.hasrightchild():
                self._put(key,val,currentNode.rightchild)
            else:
                currentNode.rightchild = TreeNode(key,val,parent =currentNode)
    
    def __setitem__(self,key,val):   #索引赋值
        self.put(key,val)
        
        
    #### 搜索方法：
    def get(self, key):
        if self.root:   
            res = self._get(key, self.root)    # 从root开始找
            if res: 
                return res.payload   # 返回数据项
            else:
                return None           # 没找到
        else:
            return None
        
    def _get(self,key,currentNode):
        if not currentNode:              # 停止条件
            return None
        elif currentNode.key==key:   # 如果匹配
            return currentNode
        elif key&amp;lt;currentNode.key:     # 如果小于当前节点，往左子节点递归
            return self._get(key,currentNode.leftchild) 
        else: 
            return self._get(key,currentNode.rightchild)
    
    def __getitem__(self,key):
        return self.get(key)
    
    def __contains__(self,key):
        if self._get(key,self.root):
            return True
        else:
            return False  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;  

mytree1 = BinarySearchTree()

## 索引赋值
mytree1[3] = &amp;quot;yy&amp;quot;
mytree1[4] = &amp;quot;python&amp;quot;
mytree1[6] = &amp;quot;read&amp;quot;
mytree1[2] = &amp;quot;today&amp;quot;
mytree1[7] = &amp;quot;is&amp;quot;
mytree1[1] = &amp;quot;now&amp;quot;

len(mytree1)
print(&amp;quot;根节点 key={}，value={}&amp;quot;.format(mytree1.root.key,mytree1.root.payload))
print(&amp;quot;第一个左子节点 key={}，value={}&amp;quot;.format(mytree1.root.leftchild.key,mytree1.root.leftchild.payload))   # 第一个左子节点
print(&amp;quot;第一个右子节点 key={}，value={}&amp;quot;.format(mytree1.root.rightchild.key,mytree1.root.rightchild.payload))   # 第一个右子节点
mytree1.root.leftchild.isleaf()
mytree1.root.rightchild.hasbothchild() 

## 索引查找
6 in mytree1
print(mytree1[4])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;根节点 key=3，value=yy
第一个左子节点 key=2，value=today
第一个右子节点 key=4，value=python
python
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 迭代枚举所有key
for i in mytree1: print(i, mytree1[i])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1 now
2 today
3 yy
4 python
6 read
7 is
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;先序-中序-后序&#34;&gt;先序、中序、后序&lt;/h2&gt;
&lt;h3 id=&#34;最简单用递归-复杂度on&#34;&gt;最简单——用递归 复杂度o(n)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;首先都是从根向下迭代，只是输出时机不同&lt;/li&gt;
&lt;li&gt;先序：直接输出&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中序&lt;/strong&gt;：先存着，左边遍历完了再把存着的输出——结果就是从小到大排列的！！&lt;/li&gt;
&lt;li&gt;后序：先存着，两边都完了再输出&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 按照前面的插入顺序得到的树的样子：
from IPython.display import Image
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;     
Image(filename = &#39;Desktop/快乐研一/python/mytree1.jpg&#39;, width=400, height=400)

# 三种遍历方法：
def qianxu(root):
    if not root == None:
        print(root.key, root.payload)
        qianxu(root.leftchild)
        qianxu(root.rightchild)        
qianxu(mytree1.root)
print(&amp;quot;\n&amp;quot;)

def zhongxu(root):    # 从小到大排列的！
    if not root==None:
        zhongxu(root.leftchild)
        print(root.key,root.payload)
        zhongxu(root.rightchild)
zhongxu(mytree1.root)  
print(&amp;quot;\n&amp;quot;)

def houxu(root):
    if not root==None:
        zhongxu(root.leftchild)
        zhongxu(root.rightchild)
        print(root.key,root.payload)
houxu(mytree1.root)          
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;output_7_0.jpeg&#34; alt=&#34;jpeg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code&gt;3 yy
2 today
1 now
4 python
6 read
7 is


1 now
2 today
3 yy
4 python
6 read
7 is


1 now
2 today
4 python
6 read
7 is
3 yy
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Image(filename = &#39;Desktop/快乐研一/python/bianlitree.png&#39;, width=400, height=400)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;output_8_0.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;一个更加直观的例子&#34;&gt;一个更加直观的例子&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;根节点的左子节点，如果按照前序遍历:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[2,3,5,6,4,7,8,]&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;如果按照中序遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[2,3,4,5,6,7,8]&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;如果按照后序遍历&lt;br&gt;
[5,6,3,7,8,4,2]&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;中序遍历一个栈实现&#34;&gt;中序遍历——一个栈实现&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不断往左子树方向走，每走一次如果不是空，就将当前节点push进去&lt;/li&gt;
&lt;li&gt;左子树为空了，从栈中pop，然后转向右边节点&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def zhongxu_stack(root):
    mystack = []
    results = []
    
    while root or mystack:   
        if root:    
            mystack.append(root)
            root = root.leftchild
        else:     
            # 说明上一步节点没有左节点，pop回到上一步
            # 输出上一步的key，同时把当前设为上一步的右节点
            # 重复上述步骤
            # mystack 为空，说明左边已经遍历了
            # 两者同时为为空，说明右边也遍历完了，可以结束了
            tmp = mystack.pop()
            root = tmp.rightchild
            results.append(tmp.key)
    return results
    
zhongxu(mytree1.root)
zhongxu_stack(mytree1.root)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1 now
2 today
3 yy
4 python
6 read
7 is





[1, 2, 3, 4, 6, 7]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;练习熟悉&#34;&gt;练习，熟悉&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 1.给所有节点key+1
def plusOne(root):
    if not root==None:  # 结束条件
        root.key+=1
        plusOne(root.leftchild)
        plusOne(root.rightchild)

zhongxu(mytree1.root)
print(&#39;\n&#39;)
plusOne(mytree1.root)
zhongxu(mytree1.root)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1 now
2 today
3 yy
4 python
6 read
7 is


2 now
3 today
4 yy
5 python
7 read
8 is
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 2.判断两棵树是否一致
### 递归到左子树和右子树
### 如果两棵树没有子树，直接对比
### 如果不是同一边/子树不一致，直接F
def isSameTree(root1,root2):
    if (root1==None and root2==None): 
        return True
    if (root1==None or root2 == None):   # 一边有一边没有
        return False
    else:   # 非空先看当前数值
        if (not root1.key==root2.key):  # 数值不同
            return False
        else:    # 如果暂时相同就递归
            return (isSameTree(root1.leftchild,root2.leftchild) and isSameTree(root1.rightchild, root2.rightchild))

    
mytree1 = BinarySearchTree()
mytree1[3] = &amp;quot;&amp;quot;
mytree1[4] = &amp;quot;&amp;quot;
mytree1[6] = &amp;quot;&amp;quot;
mytree1[2] = &amp;quot;&amp;quot;
mytree1[7] = &amp;quot;&amp;quot;
mytree1[1] = &amp;quot;&amp;quot;

mytree2 = BinarySearchTree()
mytree2[3] = &amp;quot;&amp;quot;
mytree2[4] = &amp;quot;&amp;quot;
mytree2[6] = &amp;quot;&amp;quot;
mytree2[2] = &amp;quot;&amp;quot;
mytree2[7] = &amp;quot;&amp;quot;

isSameTree(mytree1.root, mytree2.root)
mytree2[1] = &amp;quot;&amp;quot;
isSameTree(mytree1.root, mytree2.root)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;False






True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;1013&#34;&gt;10.13&lt;/h1&gt;
&lt;p&gt;学习目标&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;remove 一个节点&lt;/li&gt;
&lt;li&gt;练习题【简单】:1.深度、2.路径总和、3.打印&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;remove&#34;&gt;remove&lt;/h2&gt;
&lt;p&gt;分为几种情况&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;叶节点，把父节点的对应的child改成None&lt;/li&gt;
&lt;li&gt;如果有一个子节点，把这个唯一的子节点上移，也就是把父节点的child改为子节点【逐个讨论左右、根节点问题】&lt;/li&gt;
&lt;li&gt;如果有两个子节点——寻找另一个合适的节点来替换。“合适的节点”下一个key值的节点，即右子树中最小的——“后继”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里又要考虑一个问题：后继节点怎么找？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点有右子树，那么该节点的后继节点是其右子树中val值最小的节点（也就是右子树中所谓的leftMostNode）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（下面不会遇到）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若一个节点没有右子树，那么判断该节点和其父节点的关系：&lt;/li&gt;
&lt;li&gt;若该节点是其父节点的左边孩子，那么该节点的后继结点即为其父节点&lt;/li&gt;
&lt;li&gt;若该节点是其父节点的右边孩子，那么需要沿着其父亲节点一直向树的顶端寻找，直到找到一个节点P，P节点是其父节点Q的左边孩子&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def remove(currentNode):
    if currentNode.isleaf():  ### 情况1 是叶节点：
        if currentNode == currentNode.parent.leftchild:
            currentNode.parent.leftchild == None
        else:
            currentNode.parent.rightchild ==None 
            
    elif currentNode.hasbothchild():  ### 情况3，有左右两个节点
        succ = currentNode.findSuccessor()   # 找后继
        succ.spliceOut
        currentNode.key = succ.key
        currentNode.payload = succ.payload
    
    else:  #### 情况2. 有一个子节点
        if currentNode.hasleftchild():  # 如果有的是左节点，把节点上移
            if currentNode.isleftchild:     # 如果当前节点是左节点，上移为parent 的左节点
                currentNode.leftchild.parent = currentNode.parent
            elif currentNode.isrightchild:  # 如果当前节点是左节点，上移为parent 的左节点
                currentNode.rightchild.parent= currentNode.parent
            else:   # 如果当前节点是根节点，把这个根节点的信息替换为左子节点的信息
                currentNode.replaceNodeData(currentNode.leftchild.key, currentNode.leftchild.payload,currentNode.leftchild.leftchild,currentNode.leftchild.rightchild)
        else:   #如果有的是右节点，同上
            if currentNode.isleftchild:   # 如果当前节点是左节点，上移为parent 的左节点
                currentNode.rightchild.parent = currentNode.parent
            elif currentNode.isrightchild:  # 如果当前节点是左节点，上移为parent 的左节点
                currentNode.rightchild.parent = currentNode.parent
            else:   # 如果当前节点是根节点，把这个根节点的信息替换为左子节点的信息
                currentNode.replaceNodeData(currentNode.rightchild.key, currentNode.rightchild.payload,currentNode.rightchild.leftchild,currentNode.rightchild.rightchild)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;练习&#34;&gt;练习&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 1.深度——第一反应：递归
def maxdepth(root):

    if root == None:   # 结束条件
        return 0

    depth1 = maxdepth(root.leftchild)+1   # 递归
    depth2 = maxdepth(root.rightchild)+1
    
    if depth1&amp;gt;depth2:   # 取出最大值
        return depth1
    else:
        return depth2
    
maxdepth(mytree1.root)


### 2.路径综合——第一反应：递归
# 如果比左边小右边大：差值对右边递归
# 如果比两边都大：差值对两边递归，取or
def sumPath(root, item):
    if item&amp;lt;0: 
        return False
    
    if not root:     # 如果已经到头item还没有匹配完，False
        return False
   
    if root.key == item and not root.leftchild and not root.rightchild:    
        return True
    
    print(&amp;quot;当前root={}，item={}&amp;quot;.format(root.key, item))
    left = sumPath(root.leftchild, item - root.key)
    right = sumPath(root.rightchild, item - root.key)

    return left or right

sumPath(mytree1.root, 1)  
sumPath(mytree1.root, 6)  
sumPath(mytree1.root, 7)
#### 最开始错误原因，没有判断是不是叶节点就输出True了


#### 3.每一层打印到一行—— 用队列处理
def printTree(root):
    results = []
    nodes = []

    nodes.append(root) 
    
    while len(nodes)&amp;gt;0:
        layers= [] 
        for i in range(len(nodes)):   # 一边把队首的pop出来，一边看如果有子节点就加入队列
            tmp = nodes.pop(0)
            layers.append(tmp.key)
            if tmp.leftchild:
                nodes.append(tmp.leftchild)
            if tmp.rightchild:
                nodes.append(tmp.rightchild)
        results.append(layers)
        print(results)

#测试
printTree(mytree1.root)  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;4



当前root=3，item=1





False



当前root=3，item=6
当前root=2，item=3
当前root=4，item=3





True



当前root=3，item=7
当前root=2，item=4
当前root=1，item=2
当前root=4，item=4
当前root=6，item=0





False



[[3]]
[[3], [2, 4]]
[[3], [2, 4], [1, 6]]
[[3], [2, 4], [1, 6], [7]]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
">二叉查找树</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/about/"" data-c="
          &lt;p&gt;shuyi_ruc@163.com&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1602554344262.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">我</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/10-8/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A0%91&#34;&gt;树&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9A%E4%B9%89&#34;&gt;定义&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;二叉树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89&#34;&gt;数的定义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B5%8C%E5%A5%97%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;嵌套实现一个二叉树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%94%A8%E9%93%BE%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91&#34;&gt;用链实现一个二叉树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90&#34;&gt;树的应用——表达式解析&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9E%84%E5%BB%BA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%A7%A3%E6%9E%90%E6%A0%91&#34;&gt;构建表达式解析树&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B1%82%E5%80%BC%E9%80%92%E5%BD%92&#34;&gt;求值——递归&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E9%80%92%E5%BD%92&#34;&gt;树的遍历——递归&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%BA%8C%E5%8F%89%E5%A0%86%E5%AE%9E%E7%8E%B0&#34;&gt;优先队列——二叉堆实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;树&#34;&gt;树&lt;/h1&gt;
&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;节点Node：key&lt;/li&gt;
&lt;li&gt;边Edge：链接两个节点&lt;/li&gt;
&lt;li&gt;根节点Root：没有入边&lt;/li&gt;
&lt;li&gt;路径Path：由边依次相连&lt;/li&gt;
&lt;li&gt;子节点children：入边来自同一个节点（父节点Parent），他们之间称作兄弟节点&lt;/li&gt;
&lt;li&gt;子树subtree：一个节点及其所有子孙节点和相关的边&lt;/li&gt;
&lt;li&gt;叶节点leaf：没有子节点&lt;/li&gt;
&lt;li&gt;层级level：从根节点开始到达一个节点的路劲所包含的边的数量&lt;/li&gt;
&lt;li&gt;高度=最大层级&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;二叉树&#34;&gt;二叉树&lt;/h3&gt;
&lt;p&gt;每个节点最多有两个子节点&lt;/p&gt;
&lt;h3 id=&#34;数的定义&#34;&gt;数的定义&lt;/h3&gt;
&lt;p&gt;普通 or 递归&lt;/p&gt;
&lt;h2 id=&#34;嵌套实现一个二叉树&#34;&gt;嵌套实现一个二叉树&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def BinaryTree(r):  
    return [r,[],[]]     # 创建二叉树，仅有跟节点

def insertLeft(root,newbranch):
    t = root.pop(1)   # 把原先的左子树pop出来
    if len(t)&amp;gt;1:         # 如果原先有树
        root.insert(1,[newbranch,t,[]])  # 把原先的左子树当做新的左子树的左子树
    else:
        root.insert(1,[newbranch,[],[]])  # 如果原先没有，就建立一个只有根节点的左子树
    return root

def insertRight(root,newbranch):
    t = root.pop(2) 
    if len(t)&amp;gt;1:
        root.insert(2,[newbranch,[],t])  
    else:
        root.insert(2,[newbranch,[],[]])
    return root

# 建立一个实例
mytree = BinaryTree(3)
insertLeft(mytree,5)
insertRight(mytree,1)
insertRight(mytree,6)
print(mytree)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[3, [5, [], []], []]






[3, [5, [], []], [1, [], []]]






[3, [5, [], []], [6, [], [1, [], []]]]



[3, [5, [], []], [6, [], [1, [], []]]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;用链实现一个二叉树&#34;&gt;用链实现一个二叉树&lt;/h2&gt;
&lt;p&gt;每一个方块，有一个数据项&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class BinaryTree:
    def __init__(self, rootObj):
        self.key=rootObj
        self.leftchild = None
        self.rightchild = None
        
    def insertleft(self,newnode):
        if self.leftchild == None:
            self.leftchild = BinaryTree(newnode)
        else:
            t = BinaryTree(newnode)
            t.leftchild = self.leftchild
            self.leftchild = t
    
    def insertright(self,newnode):
        if self.rightchild == None:
            self.rightchild = BinaryTree(newnode)
        else:
            t = BinaryTree(newnode)
            t.rightchild = self.rightchild
            self.rightchild = t
    
    def getRightchild(self):
        return self.rightchild
    
    def getLeftchild(self):
        return self.leftchild
    
    def setRoot(self,obj):
        self.key = obj
    
    def getRoot(self):
        return self.key      
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;r = BinaryTree(&#39;a&#39;)
r.insertleft(&#39;b&#39;)
r.insertright(&#39;c&#39;)
r.getRightchild().insertright(&#39;d&#39;)
r.getRightchild().getRoot()
r.getRightchild().getRightchild().getRoot()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&#39;c&#39;






&#39;d&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;树的应用表达式解析&#34;&gt;树的应用——表达式解析&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个子树都表示一个子表达式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面：1.构建表达式解析树，2.并求值，3.从表达式解析树恢复表达式的字符串形式&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;构建表达式解析树&#34;&gt;构建表达式解析树&lt;/h3&gt;
&lt;p&gt;首先，全括号表达式分解为括号、操作符和 数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是（：为当前添加一个新的左子节点，当前节点下降&lt;/li&gt;
&lt;li&gt;如果是操作符：为当前添加一个新右子节点，当前节点下降&lt;/li&gt;
&lt;li&gt;如果是数字：设置当前节点，并且当前节点上升到父节点&lt;/li&gt;
&lt;li&gt;如果是）：当前节点上升到父节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;但是：&lt;/strong&gt; 上升到父节点没有方法支持，如何做到？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用一个栈来记录跟踪父节点&lt;/li&gt;
&lt;li&gt;下降时，把下降前的节点push入栈，需要上升时候pop出来&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def build_parsetree(fpexp):
    fplist = list(fpexp)      # 把字符串切割
    eTree = BinaryTree(&#39; &#39;)  # 初始化tree
    pStack =[]                   # 初始化一个栈
    pStack.append(eTree)  # 入栈
    currentTree = eTree     # 定义当前tree
    
    for i in fplist:
        if i==&amp;quot;(&amp;quot;:
            currentTree.insertleft(&#39; &#39;)         # 添加一个新的左子节点
            pStack.append(currentTree)    # 下降前的节点push进栈
            currentTree = currentTree.getLeftchild()   # 下降到左子节点
        elif i not in [&#39;+&#39;,&amp;quot;-&amp;quot;,&amp;quot;*&amp;quot;,&amp;quot;/&amp;quot;,&amp;quot;)&amp;quot;] :      # 如果是数字
            currentTree.setRoot(int(i))         # 设置为节点值
            currentTree = pStack.pop(0)     # 上升为父节点
        elif i in [&#39;+&#39;,&#39;-&#39;,&#39;*&#39;,&amp;quot;/&amp;quot;]:
            currentTree.setRoot(i) 
            currentTree.insertright(&#39; &#39;)
            pStack.append(currentTree)
            currrentTree = currentTree.getRightchild()
        elif i ==&amp;quot;)&amp;quot;:
            currentTree = pStack.pop(0)
        else:
            raise ValueError
    
    return eTree
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;求值递归&#34;&gt;求值——递归&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;结束条件：叶节点&lt;/li&gt;
&lt;li&gt;缩小：分为左子树右子树&lt;/li&gt;
&lt;li&gt;调用自身：根据根节点计算&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import operator
def evaluate(parseTree):
    opers = {&#39;+&#39;:operator.add, &#39;-&#39;:operator.sub, &#39;/&#39;:operator.truediv,&#39;*&#39;:operator.mul}  # 操作符
    
    leftT = parseTree.getLeftchild()
    rightT = parseTree.getRightchild()
    
    if leftT and rightT:      # 空的说明是叶节点
        fn = opers[parseTree.getRoot()]
        return fn(evaluate(leftT), evaluate(rightT))   # 递归
    else:
        return parseTree.getRoot()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;树的遍历递归&#34;&gt;树的遍历——递归&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def preorder(tree):   # 前序
    if tree:
        print (tree.getRoot())
        preorder(tree.getLeftchild())
        preorder(tree.getRightchild())
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;优先队列二叉堆实现&#34;&gt;优先队列——二叉堆实现&lt;/h1&gt;
&lt;p&gt;优先队列入队时候：根据其优先级尽可能挤到前方&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;二叉堆：优先队列出入队复杂度保持在o(logn)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;堆次序&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何一个节点x，父节点p中的key均小于x中的key（任何一条路劲都是排序好的数列）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from IPython.display import Image
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;     
Image(filename = &#39;Desktop/快乐研一/python/ercha2.jpg&#39;, width=300, height=300)
Image(filename = &#39;Desktop/快乐研一/python/erchadui1.jpg&#39;, width=300, height=300)
Image(filename = &#39;Desktop/快乐研一/python/erchadui2.jpg&#39;, width=300, height=300)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;output_15_0.jpeg&#34; alt=&#34;jpeg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;output_15_1.jpeg&#34; alt=&#34;jpeg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;output_15_2.jpeg&#34; alt=&#34;jpeg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class BinHeap:
    def __init__(self):
        self.heapList=[0]   # 把下表为0的填起来，无用，方便后面下标整数乘除法
        self.currentSize = 0
    
    def percUp(self,i):      # 上浮
        while i//2&amp;gt;0:
            if self.heapList[i]&amp;lt;self.heapList[i//2]:   #  如果比父节点大——交换
                self.heapList[i], self.heapList[i//2]= self.heapList[i//2], self.heapList[i]
            i = i//2
    
    def insert(self,k):
        self.heapList.append(k)
        self.currentSize +=1
        self.percUp(self.currentSize)  # 对这个新增节点进行“上浮”操作
        
    def minchild(self,i):
        if i*2+1&amp;gt;self.currentSize: return i*2     # 如果只有左子节点，直接输出
        else:
            if self.heapList[i*2]&amp;lt;self.heapList[i*2+1]:  # 否则对比输出较大的
                return i*2
            else: return i*2+1
    
    def percDown(self,i):
        while i*2&amp;lt;=self.currentSize:
            minc = self.minchild(i)   # 最小的子节点的位置
            if self.heapList[i]&amp;gt;self.heapList[minc]:
                self.heapList[i],self.heapList[minc] = self.heaplist[minc],self.heapList[i]
            i = minc  # 下沉后继续判断
        
    def delMin(self):  # 删除根节点后，把最后一位移到根节点，然后做下沉
        self.heapList[1] = self.heapList[self.currentSize]
        self.currentSize -=1
        self.heapList.pop()
        self.percDown(1)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### heapq库是专门处理最小堆的库
import heapq
nums = [7, 2, 11, 5, 1, 54, 23]
heapq.heapify(nums)
nums
heapq.heappush(nums, 3)
nums
print([heapq.heappop(nums) for _ in range(len(nums))])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1, 2, 11, 5, 7, 54, 23]






[1, 2, 11, 3, 7, 54, 23, 5]



[1, 2, 3, 5, 7, 11, 23, 54]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &amp;lt;= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/last-stone-weight
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def lastStone(stones) -&amp;gt; int:
    if len(stones)==1: 
        return stones[0]
    stones=[-i for i in stones]  # 变成负数，方便pop出最大值

    import heapq
    heapq.heapify((stones))    # 引入二叉堆
    while len(stones)&amp;gt;1:
        max1 = -heapq.heappop(stones)
        max2 = -heapq.heappop(stones)
        if max1&amp;gt;max2:   # 如果大小不等，还有剩， 否则没有剩
            heapq.heappush(stones,max2-max1)
        print([-i for i in stones])
    if len(stones)==0:
        return 0
    else:
        return -stones[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;stones = [2,7,2,3,7,4,6,8]
lastStone(stones)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[7, 3, 6, 2, 2, 4, 1]
[4, 3, 1, 2, 2, 1]
[2, 2, 1, 1, 1]
[1, 1, 1]
[1]





1
&lt;/code&gt;&lt;/pre&gt;
">树与二叉堆</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py10-7/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE&#34;&gt;排序与查找&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE&#34;&gt;顺序查找&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE&#34;&gt;二分查找&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F&#34;&gt;冒泡排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F&#34;&gt;选择排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B0%A2%E5%B0%94%E6%8E%92%E5%BA%8F&#34;&gt;谢尔排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F&#34;&gt;归并排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F&#34;&gt;快速排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%A3%E5%88%97-hashing&#34;&gt;散列 Hashing&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0&#34;&gt;散列函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93&#34;&gt;区块链技术（分布式数据库）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1&#34;&gt;散列函数的设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3&#34;&gt;冲突解决&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%98%A0%E5%B0%84&#34;&gt;映射&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%9F%A5%E6%89%BE-2&#34;&gt;排序与查找&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-2&#34;&gt;快速排序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;排序与查找&#34;&gt;排序与查找&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;算法&lt;/th&gt;
&lt;th&gt;复杂度&lt;/th&gt;
&lt;th&gt;其他&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;冒泡、选择、插入&lt;/td&gt;
&lt;td&gt;o(n^2)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;谢尔排序&lt;/td&gt;
&lt;td&gt;o(n)-o(n^2)&lt;/td&gt;
&lt;td&gt;对于插入排序的改进&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;归并排序&lt;/td&gt;
&lt;td&gt;o(nlogn)&lt;/td&gt;
&lt;td&gt;但需要额外存储空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;快速排序&lt;/td&gt;
&lt;td&gt;最好为o(nlogn)，分裂点偏离中心时o(n^2)&lt;/td&gt;
&lt;td&gt;不需要额外存储空间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;总结：需要针对数据情况（比如随机性）来判断选择哪种算法~&lt;/p&gt;
&lt;h2 id=&#34;顺序查找&#34;&gt;顺序查找&lt;/h2&gt;
&lt;p&gt;按照下标增长逐个比对复杂度o(n)&lt;/p&gt;
&lt;h2 id=&#34;二分查找&#34;&gt;二分查找&lt;/h2&gt;
&lt;p&gt;算法复杂度o(logn)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    

# 有序表顺序查找
def orderedSearch(alist, item):
    found = False
    stop = False
    i=0   
    while i &amp;lt; len(alist) and not found and not stop:
        i = i+1
        if item &amp;lt; alist[i]: 
            stop = True
        elif item==alist[i]:
            found = True    
    return found

orderedSearch([1,4,5,7,8,22,34,76,90,105],23)


### 二分查找的递归算法
###  如果只剩下1个数字，直接对比，如果不是则不存在
def binarySearch(alist,item):
    found = False
    # 结束条件：
    if not len(alist)==0:  
        # 找到中间
        mid = len(alist)//2
        if item==alist[mid]: found = True  
        if item&amp;lt;alist[mid]: found = binarySearch(alist[:mid],item)
        if item&amp;gt;alist[mid]: found = binarySearch(alist[mid+1:],item) 
        print(alist)
    return found

binarySearch([1,4,5,7,8,16,22,34,66,73,89,90,101,105],5)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[5]
[1, 4, 5]
[1, 4, 5, 7, 8, 16, 22]
[1, 4, 5, 7, 8, 16, 22, 34, 66, 73, 89, 90, 101, 105]





True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;冒泡排序&#34;&gt;冒泡排序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对无序表多躺比较，每趟多次相邻对比交换，并交换。第i躺排序第i大的项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间复杂度为o(n^2)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改进，加入这一趟是否有exchange&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;alist = [34,82,66,14,56,80,9,44,69,21]
## 冒泡排序
for j in range(len(alist)-1):
    for i in range(len(alist)-j-1):
        if (alist[i]&amp;gt;alist[i+1]):   # 相邻对比交换
            alist[i],alist[i+1]=alist[i+1],alist[i]    # py支持直接交换，不用在写temp
    print(j+1, alist)

###  如何改进：如果某一趟没有任何改变，就不再继续了
alist = [34,82,66,14,56,80,9,44,69,21]
print(&amp;quot;\n&amp;quot;)
exchange=1
j=0
while j&amp;lt;len(alist)-1 and exchange&amp;gt;0:
    exchange=0
    j=j+1
    for i in range(len(alist)-j-1):
        if (alist[i]&amp;gt;alist[i+1]):   # 相邻对比交换
            alist[i],alist[i+1]=alist[i+1],alist[i]    # py支持直接交换，不用在写temp
            exchange+=1
    print(j, alist)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1 [34, 66, 14, 56, 80, 9, 44, 69, 21, 82]
2 [34, 14, 56, 66, 9, 44, 69, 21, 80, 82]
3 [14, 34, 56, 9, 44, 66, 21, 69, 80, 82]
4 [14, 34, 9, 44, 56, 21, 66, 69, 80, 82]
5 [14, 9, 34, 44, 21, 56, 66, 69, 80, 82]
6 [9, 14, 34, 21, 44, 56, 66, 69, 80, 82]
7 [9, 14, 21, 34, 44, 56, 66, 69, 80, 82]
8 [9, 14, 21, 34, 44, 56, 66, 69, 80, 82]
9 [9, 14, 21, 34, 44, 56, 66, 69, 80, 82]


1 [34, 66, 14, 56, 80, 9, 44, 69, 82, 21]
2 [34, 14, 56, 66, 9, 44, 69, 80, 82, 21]
3 [14, 34, 56, 9, 44, 66, 69, 80, 82, 21]
4 [14, 34, 9, 44, 56, 66, 69, 80, 82, 21]
5 [14, 9, 34, 44, 56, 66, 69, 80, 82, 21]
6 [9, 14, 34, 44, 56, 66, 69, 80, 82, 21]
7 [9, 14, 34, 44, 56, 66, 69, 80, 82, 21]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;选择排序&#34;&gt;选择排序&lt;/h2&gt;
&lt;p&gt;复杂度仍然是o(n^2)，但是性能优于冒牌。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;alist = [34,82,66,14,56,80,9,44,69,21]
for i in range(1,len(alist)):
    if len(alist[i:])&amp;gt;=1:
        tmp = alist[i]
        j=1
        while j &amp;lt;= i and alist[i-j]&amp;gt;tmp:   # 如果比前一个大，前一个往后挪
            alist[i-j+1]=alist[i-j]
            j = j+1 
        alist[i-j+1]=tmp         # 挪出来的空位插入
        print(alist)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[34, 82, 66, 14, 56, 80, 9, 44, 69, 21]
[34, 66, 82, 14, 56, 80, 9, 44, 69, 21]
[14, 34, 66, 82, 56, 80, 9, 44, 69, 21]
[14, 34, 56, 66, 82, 80, 9, 44, 69, 21]
[14, 34, 56, 66, 80, 82, 9, 44, 69, 21]
[9, 14, 34, 56, 66, 80, 82, 44, 69, 21]
[9, 14, 34, 44, 56, 66, 80, 82, 69, 21]
[9, 14, 34, 44, 56, 66, 69, 80, 82, 21]
[9, 14, 21, 34, 44, 56, 66, 69, 80, 82]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;谢尔排序&#34;&gt;谢尔排序&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;按照间隔划分子列表，分别插入排序后，整体更加接近有序。&lt;/li&gt;
&lt;li&gt;间隔越来越小，最后间隔为1时进行的插入排序，复杂度和对无序进行插入排序完全不同。&lt;/li&gt;
&lt;li&gt;复杂度为o(n^1.5)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def shellsort(alist):
    mid = len(alist)//2  # 初始间隔为n/2
    while mid&amp;gt;0:
        for i in range(mid):
            gapsort(alist,i,mid)
        print(mid,alist)
        mid = mid//2   # 间隔缩小一半

def gapsort(alist,start,gap):
    for i in range(start+gap,len(alist),gap):   # 按照间隔提取子列
        current = alist[i]
        j=i
        while j&amp;gt;=gap and alist[j-gap]&amp;gt;current:
            alist[j]=alist[j-gap]
            j=j-gap
        alist[j]=current


alist = [34,5,82,0,66,-2,14,56,80,9,23,87,100,42,33,51,44,69,21]
shellsort(alist)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;9 [9, 5, 82, 0, 42, -2, 14, 44, 69, 21, 23, 87, 100, 66, 33, 51, 56, 80, 34]
4 [9, -2, 14, 0, 42, 5, 23, 44, 56, 21, 33, 51, 69, 66, 34, 87, 100, 80, 82]
2 [9, -2, 14, 0, 23, 5, 33, 21, 34, 44, 42, 51, 56, 66, 69, 80, 82, 87, 100]
1 [-2, 0, 5, 9, 14, 21, 23, 33, 34, 42, 44, 51, 56, 66, 69, 80, 82, 87, 100]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;归并排序&#34;&gt;归并排序&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from IPython.display import Image
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;     
Image(filename = &#39;Desktop/快乐研一/python/guibin.jpg&#39;, width=400, height=400)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;output_9_0.jpeg&#34; alt=&#34;jpeg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def mergesort(alist):
    # 结束条件：
    if len(alist)&amp;lt;=1: return alist
    
    # 划分两半
    mid = len(alist)//2
    left = mergesort(alist[:mid])  # 递归调用
    right = mergesort(alist[mid:])
    
    # 如何合并？
    merged = []
    while left and right:    # 如果两边都有数据
        if left[0]&amp;lt;=right[0]: merged.append(left.pop(0))    # 从前往后一次对比大小
        else: merged.append(right.pop(0))
    merged.extend(right if right else left)    # 如果某一边有剩，接上
    
    return merged
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;alist = [34,5,82,0,66,-2,14,56,80,9,23,87,34,100,42,33,51,44,69,21]
mergesort(alist)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[-2, 0, 5, 9, 14, 21, 23, 33, 34, 34, 42, 44, 51, 56, 66, 69, 80, 82, 87, 100]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;快速排序&#34;&gt;快速排序&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fastsort(alist):
    # 结束条件
    if len(alist)&amp;lt;=1: return alist
    
    # 按照第一个数字作为对比中间值，设置左右两个mark分别对比，交换
    leftmark = 1
    rightmark = len(alist)-1
    
    while leftmark&amp;lt;rightmark:   # 左标向右移动，右标向左移动， 直到错开
        if alist[leftmark]&amp;gt;alist[0] and alist[rightmark]&amp;lt;alist[0]:  
            alist[leftmark],alist[rightmark] = alist[rightmark],alist[leftmark]
        else:
            if alist[leftmark]&amp;lt;=alist[0]:   # 左标向右移动，直到遇见大于list[0]的
                leftmark+=1
            if alist[rightmark]&amp;gt;=alist[0]:  # 右标向左移动，直到遇见小于list[0]的
                rightmark-=1
    
    if alist[rightmark]&amp;lt;alist[0]:
        alist[rightmark],alist[0]=alist[0],alist[rightmark]
    
    print(alist)
    
    # 递归调用前后两部分
    left = fastsort(alist[:rightmark])
    right = fastsort(alist[rightmark:])
    return left+right


alist = [90,34,5,82,0,66,-2,14,56,80,9,23,87,34,100,42,51,44,69,21]
fastsort(alist)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[69, 34, 5, 82, 0, 66, -2, 14, 56, 80, 9, 23, 87, 34, 21, 42, 51, 44, 90, 100]
[21, 34, 5, 44, 0, 66, -2, 14, 56, 51, 9, 23, 42, 34, 69, 87, 80, 82]
[-2, 9, 5, 14, 0, 21, 66, 44, 56, 51, 34, 23, 42, 34]
[-2, 9, 5, 14, 0]
[0, 5, 9, 14]
[0, 5]
[9, 14]
[21, 66, 44, 56, 51, 34, 23, 42, 34]
[34, 44, 56, 51, 34, 23, 42, 66]
[34, 23, 56, 51, 34, 44, 42]
[23, 34]
[42, 51, 34, 44, 56]
[34, 42, 51, 44]
[42, 51, 44]
[44, 51]
[69, 87, 80, 82]
[82, 80, 87]
[80, 82]
[90, 100]





[-2, 0, 5, 9, 14, 21, 23, 34, 34, 42, 44, 51, 56, 66, 69, 80, 82, 87, 90, 100]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;练习题目：寻找list中k个最小的数，用快速排序实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def kmin(alist,k):
    if len(alist)==k:
        return alist
    
    leftmark = 1
    rightmark = len(alist)-1
    while leftmark&amp;lt;rightmark:
        if alist[leftmark]&amp;gt;alist[0] and alist[rightmark]&amp;lt;alist[0]:  
            alist[leftmark],alist[rightmark] = alist[rightmark],alist[leftmark]
        else:
            if alist[leftmark]&amp;lt;=alist[0]:   # 左标向右移动，直到遇见大于list[0]的
                leftmark+=1
            if alist[rightmark]&amp;gt;=alist[0]:  # 右标向左移动，直到遇见小于list[0]的
                rightmark-=1
    if alist[rightmark]&amp;lt;alist[0]:
        alist[rightmark],alist[0]=alist[0],alist[rightmark]
    
    if rightmark&amp;gt;=k: 
        return kmin(alist[:rightmark], k)
    else: 
        return alist[:rightmark]+kmin(alist[rightmark:], k-rightmark)

alist
kmin(alist,5)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[-2, 9, 5, 14, 0, 21, 66, 44, 56, 51, 34, 23, 42, 34, 69, 87, 80, 82, 90, 100]






[-2, 0, 5, 9, 14]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;散列-hashing&#34;&gt;散列 Hashing&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;需要对于数据项的位置更加精准，有利于快速存储。&lt;/li&gt;
&lt;li&gt;用名称key来标识槽slot，用于保存数据项。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;散列函数&#34;&gt;散列函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;常用的散列方法——求余数，对于11求余数，结果一定是0-10~存在不同的槽里面&lt;/li&gt;
&lt;li&gt;完美散列函数：把每个数据项映射到不同的槽。特点：
&lt;ul&gt;
&lt;li&gt;压缩性、易计算、抗修改、抗冲突&lt;/li&gt;
&lt;li&gt;如MD5 SHA，python中的散列函数库：hashlib&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;区块链技术分布式数据库&#34;&gt;区块链技术（分布式数据库）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;核心问题：在没有控制中心的情况下，如果防止篡改和破坏&lt;/li&gt;
&lt;li&gt;区块链由区块block组成，block由head（记录生成时间、前一个区块的散列值等）和body（记录实际数据）组成。&lt;/li&gt;
&lt;li&gt;对于某个区块数据的改动，将会引起后续所有区块的变动，比如更新会比集中数据库慢很多。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;比特币平均10分钟生成一个区块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;散列函数的设计&#34;&gt;散列函数的设计&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;折叠法&lt;/li&gt;
&lt;li&gt;平方取中（最后都是对11求余数）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;冲突解决&#34;&gt;冲突解决&lt;/h3&gt;
&lt;h2 id=&#34;映射&#34;&gt;映射&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;字典dict&lt;/strong&gt;：键值关联，能够快速查找&lt;/p&gt;
&lt;h1 id=&#34;排序与查找-2&#34;&gt;排序与查找&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;算法&lt;/th&gt;
&lt;th&gt;复杂度&lt;/th&gt;
&lt;th&gt;其他&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;冒泡、选择、插入&lt;/td&gt;
&lt;td&gt;o(n^2)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;谢尔排序&lt;/td&gt;
&lt;td&gt;o(n)-o(n^2)&lt;/td&gt;
&lt;td&gt;对于插入排序的改进&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;归并排序&lt;/td&gt;
&lt;td&gt;o(nlogn)&lt;/td&gt;
&lt;td&gt;但需要额外存储空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;快速排序&lt;/td&gt;
&lt;td&gt;最好为o(nlogn)，分裂点偏离中心时o(n^2)&lt;/td&gt;
&lt;td&gt;不需要额外存储空间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;总结：需要针对数据情况（比如随机性）来判断选择哪种算法~&lt;/p&gt;
&lt;h2 id=&#34;快速排序-2&#34;&gt;快速排序&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    

def fastsort(alist):
    # 结束条件
    if len(alist)&amp;lt;=1: return alist
    
    # 按照第一个数字作为对比中间值，设置左右两个mark分别对比，交换
    leftmark = 1
    rightmark = len(alist)-1
    
    while leftmark&amp;lt;rightmark:   # 左标向右移动，右标向左移动， 直到错开
        if alist[leftmark]&amp;gt;alist[0] and alist[rightmark]&amp;lt;alist[0]:  
            alist[leftmark],alist[rightmark] = alist[rightmark],alist[leftmark]
        else:
            if alist[leftmark]&amp;lt;=alist[0]:   # 左标向右移动，直到遇见大于list[0]的
                leftmark+=1
            if alist[rightmark]&amp;gt;=alist[0]:  # 右标向左移动，直到遇见小于list[0]的
                rightmark-=1
    
    if alist[rightmark]&amp;lt;alist[0]:
        alist[rightmark],alist[0]=alist[0],alist[rightmark]
    
    print(alist)
    
    # 递归调用前后两部分
    left = fastsort(alist[:rightmark])
    right = fastsort(alist[rightmark:])
    return left+right

alist = [90,34,5,82,0,66,-2,14,56,80,9,23,87,34,100,42,51,44,69,21]
fastsort(alist)

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[69, 34, 5, 82, 0, 66, -2, 14, 56, 80, 9, 23, 87, 34, 21, 42, 51, 44, 90, 100]
[21, 34, 5, 44, 0, 66, -2, 14, 56, 51, 9, 23, 42, 34, 69, 87, 80, 82]
[-2, 9, 5, 14, 0, 21, 66, 44, 56, 51, 34, 23, 42, 34]
[-2, 9, 5, 14, 0]
[0, 5, 9, 14]
[0, 5]
[9, 14]
[21, 66, 44, 56, 51, 34, 23, 42, 34]
[34, 44, 56, 51, 34, 23, 42, 66]
[34, 23, 56, 51, 34, 44, 42]
[23, 34]
[42, 51, 34, 44, 56]
[34, 42, 51, 44]
[42, 51, 44]
[44, 51]
[69, 87, 80, 82]
[82, 80, 87]
[80, 82]
[90, 100]





[-2, 0, 5, 9, 14, 21, 23, 34, 34, 42, 44, 51, 56, 66, 69, 80, 82, 87, 90, 100]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
####练习题目：
#寻找list中k个最小的数，用快速排序实现
def kmin(alist,k):
    if len(alist)==k:
        return alist
    
    leftmark = 1
    rightmark = len(alist)-1
    while leftmark&amp;lt;rightmark:
        if alist[leftmark]&amp;gt;alist[0] and alist[rightmark]&amp;lt;alist[0]:  
            alist[leftmark],alist[rightmark] = alist[rightmark],alist[leftmark]
        else:
            if alist[leftmark]&amp;lt;=alist[0]:   # 左标向右移动，直到遇见大于list[0]的
                leftmark+=1
            if alist[rightmark]&amp;gt;=alist[0]:  # 右标向左移动，直到遇见小于list[0]的
                rightmark-=1
    if alist[rightmark]&amp;lt;alist[0]:
        alist[rightmark],alist[0]=alist[0],alist[rightmark]
    
    if rightmark&amp;gt;=k: 
        return kmin(alist[:rightmark], k)
    else: 
        return alist[:rightmark]+kmin(alist[rightmark:], k-rightmark)

alist = [90,34,5,82,0,66,-2,14,56,80,9,23,87,34,100,42,51,44,69,21]
alist
kmin(alist,5)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[90, 34, 5, 82, 0, 66, -2, 14, 56, 80, 9, 23, 87, 34, 100, 42, 51, 44, 69, 21]






[-2, 9, 5, 14, 0]
&lt;/code&gt;&lt;/pre&gt;
">排序算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/xue-dai-ma-xiao-gan-shou/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1602921336081.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;自学的困境&#34;&gt;自学的困境&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;我看了很多python零基础入门的书和教程，仿佛我也会一些东西了。但是接下来要做些什么，能做些什么，我其实真的不知道，会自我怀疑做的这件事是不是到底真的有用&lt;br&gt;
一定要去动手写一些代码。看是学不会一门新东西的，只有做了才行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐阅读：&lt;br&gt;
&lt;a href=&#34;https://mp.weixin.qq.com/s/Y2QNS4hapVTq78MsR1Gb9w&#34;&gt;为什么看懂了基础语法但还是学不会编程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;初次做项目-with-r&#34;&gt;初次做项目 with R&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;虽然是一个很简单很小的项目，也算第一次稀里糊涂自学一段时间R，虽然成果大部分的内容都源自百度哈哈哈&lt;/li&gt;
&lt;li&gt;每次pr都会被疯狂纠正的历史&lt;/li&gt;
&lt;li&gt;感谢批评，那也是进步飞快和养成良好代码习惯的阶段✊&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1602812555757.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1602812576571.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1602811835618.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1602812542934.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;初次做项目-with-py&#34;&gt;初次做项目 with py&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一次碰py就是突然被通知加入导师的商业分析项目，小白的我完全不懂py语法，面对师姐提出的要求真的一脸懵，最后勉强坚持学了一个周还是放弃了，当时炒鸡自卑觉得自己很差劲让师姐失望了。&lt;/li&gt;
&lt;li&gt;这应该就是为什么很长一段时间对python产生畏难心理的原因&lt;/li&gt;
&lt;li&gt;感受呢，就是学习还是要循序渐进。如果自学效果差很多地方不懂，先考虑换个更合适的教程，而不是自我责备哟~&lt;br&gt;
&lt;img src=&#34;https://yangggshuyi.github.io/post-images/1602812194125.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">学代码小感受</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py0926-0928/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#list-%E5%92%8C-dict&#34;&gt;list 和 dict&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8C%BA%E5%88%AB%E7%82%B9&#34;&gt;区别点&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#list&#34;&gt;list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dict&#34;&gt;dict&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AE%80%E5%8D%95%E5%B0%8F%E9%A2%98%E7%86%9F%E6%82%89python&#34;&gt;简单小题熟悉python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%98%E4%BD%8D%E8%AF%8D%E5%88%A4%E6%96%AD%E9%97%AE%E9%A2%98&#34;&gt;变位词判断问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84&#34;&gt;一些基本结构&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A0%88&#34;&gt;栈&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D&#34;&gt;括号匹配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E8%BF%9B%E5%88%B6&#34;&gt;二进制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E7%BB%B4%E6%B6%88%E6%B6%88%E4%B9%90&#34;&gt;一维消消乐&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B%E8%AE%B0%E5%BD%95&#34;&gt;棒球比赛记录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%98%9F%E5%88%97&#34;&gt;队列&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%87%BB%E9%BC%93%E4%BC%A0%E8%8A%B1%E7%83%AD%E5%9C%9F%E8%B1%86%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98&#34;&gt;击鼓传花/热土豆/约瑟夫问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%89%93%E5%8D%B0%E6%A8%A1%E6%8B%9F&#34;&gt;打印模拟&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E5%9B%9E%E6%96%87%E8%AF%8D&#34;&gt;双端队列——回文词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%93%BE%E8%A1%A8&#34;&gt;链表&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%97%A0%E5%BA%8F&#34;&gt;无序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%89%E5%BA%8F&#34;&gt;有序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%93%BE%E8%A1%A8%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%80%BB%E7%BB%93&#34;&gt;链表复杂度的总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#list-2&#34;&gt;list&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%80%92%E5%BD%92&#34;&gt;递归&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;list-和-dict&#34;&gt;list 和 dict&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from IPython.display import Image
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;     
Image(filename = &#39;Desktop/快乐研一/python/list_dict.jpg&#39;, width=300, height=300)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;output_1_0.jpeg&#34; alt=&#34;jpeg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;区别点&#34;&gt;区别点&lt;/h2&gt;
&lt;p&gt;python最重要的两种数据类型，注意的点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dict内部没有顺序关系&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;list&#34;&gt;list&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;按索引取值赋值：，随机访问，优&lt;/li&gt;
&lt;li&gt;添加：append优于+&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;+&amp;quot;事实上生成了一个新的列表再复制过去（类似x+=1优于x = x+1）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;删除pop()优于pop(i)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dict&#34;&gt;dict&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;取值get赋值set。 dict.get(&#39;key值&#39;) 键值存在，则返回对应值&lt;/li&gt;
&lt;li&gt;检索in， key in dict&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;简单小题熟悉python&#34;&gt;简单小题熟悉python&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 题目一
# 输出一个数，即他们的商，保持小数点后4位（%.4f）
# 如果除数为0，则输出：NA（两个字母）
numerator = float(input(&amp;quot;请输入分子&amp;quot;))
denominator = float(input(&amp;quot;请输入分母&amp;quot;))
if denominator!=0:
    num = numerator/denominator
    print(&#39;%.4f&#39; % num)
else:
    print(&amp;quot;NA&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;请输入分子3
请输入分母5
0.6000
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 题目二
# 给出行数和列数，打印一个由*号构成的实心矩形
# 输入格式: 一行，用空格隔开的两个整数m、n
m,n = map(int,input(&amp;quot;请输入两个整数，用空格隔开:&amp;quot;).split())
for i in range(0,n): print( &amp;quot;*&amp;quot;*m)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 题目三
# 输入格式:一行，由空格隔开的一系列整数，数量2个以上，找到最小的数
lst = []    #定义一个空列表
str = input(&amp;quot;请输入一列整数，用空格隔开:&amp;quot;)
lst1 = list(map(int, str.split()))   # 用空格分割
lst1.sort()
print(&amp;quot;最小值为:{}&amp;quot;.format(lst1[0]))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;变位词判断问题&#34;&gt;变位词判断问题&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 我的思路
# 对于26个字母，分别计算每个字母出现次数——26维——对比两个词对应向量是否一致。

# 定义函数
def anagramSolution1(s_1,s_2):
    s1 = list(s_1)  ## 转化为list
    s2 = list(s_2)
    isanagram = False
    
    if len(s1)==len(s2):
        zimu = list(map(chr, range(ord(&#39;a&#39;), ord(&#39;z&#39;)+1)))    ## 获取26个字母的序列
        count1 = [0]*len(zimu)       
        count2 = [0]*len(zimu)
        
        ## 统计26个字母在字符中出现次数
        for j in range(0,len(zimu)):   
            for i in range(0,len(s1)): 
                if zimu[j] == s1[i]: count1[j] += 1
                if zimu[j] == s2[i]: count2[j] += 1
        if count1==count2: isanagram = True   ## 对比出现次数是否一致
    return isanagram

#  测试
anagramSolution1(&amp;quot;aabb&amp;quot;,&amp;quot;abb&amp;quot;)  
anagramSolution1(&amp;quot;aabbzz&amp;quot;,&amp;quot;abzabz&amp;quot;)  
anagramSolution1(&amp;quot;python&amp;quot;,&amp;quot;typhon&amp;quot;)  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;False






True






True
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;##  其他思路——code最短的方法
# 转化为list后排序，然后对比
def anagramSolution2(s_1,s_2):
    s1 = list(s_1)  ## 转化为list
    s2 = list(s_2)
    s1.sort()
    s2.sort()
    isanagram = False
    if s1==s2: isanagram = True
    return isanagram

#  测试
anagramSolution2(&amp;quot;aabb&amp;quot;,&amp;quot;abb&amp;quot;)  
anagramSolution2(&amp;quot;aabbzz&amp;quot;,&amp;quot;abzabz&amp;quot;)  
anagramSolution2(&amp;quot;python&amp;quot;,&amp;quot;typhon&amp;quot;)  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;False






True






True
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;一些基本结构&#34;&gt;一些基本结构&lt;/h1&gt;
&lt;p&gt;线性结构：数据项之间只存在先后次序关系，区别在于增减方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈 stack：加入和移除都在同一段，“后进先出”e.g.叠盘子&lt;/li&gt;
&lt;li&gt;队列 queue&lt;/li&gt;
&lt;li&gt;双端队列 deque&lt;/li&gt;
&lt;li&gt;列表 list&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;栈&#34;&gt;栈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将ADT Stack实现为python 的一个class&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Image(filename = &#39;Desktop/快乐研一/python/stack.jpg&#39;, width=300, height=300)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;output_11_0.jpeg&#34; alt=&#34;jpeg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## py - STACK
class Stack:
    def __init__(self):
        self.items = []
    def isEmpty(self):
        return self.items ==[]
    def push(self, item):
        self.items.append(item)   # append o(1)
    def pop(self):
        return self.items.pop()    # pop o(1)
    def peek(self):
        return self.items[-1]    # 小知识：-1也是取出list中最后一个
    def size(self):
        return len(self.items)

# 实例化
s = Stack()
s.push(4)
s.push(&#39;yyy&#39;)
print(s.items)
print(s.size())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[4, &#39;yyy&#39;]
2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;括号匹配&#34;&gt;括号匹配&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 简单应用——括号匹配
def parChecker(strings_):
    strings = list(strings_)
   
    s = Stack()
    stillbalance = True
    i=0
    
    while i &amp;lt; len(strings) and stillbalance:
        if strings[i]==&amp;quot;(&amp;quot;:
            s.push(strings[i])
        else: 
            if strings[i]==&amp;quot;)&amp;quot;: 
                if s.isEmpty()==True: stillbalance = False    # 没有匹配的左括号，就F
                else: s.pop()    # 如果匹配就pop掉
        i =i+1
    
    results = stillbalance and s.isEmpty()    # 如果多余左括号，也要F
    return(results,stillbalance,s.isEmpty())

# 测试
parChecker(&amp;quot;2(2+x)x(x(sss))&amp;quot;)
parChecker(&amp;quot;2(2+x)x(x)(sss))&amp;quot;)  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(True, True, True)






(False, False, True)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 复杂应用——括号匹配（[{

strings = list(&amp;quot;2(s[x()x{er[]c}]s)0&amp;quot;)
# 同上，如果多出一个左或者右括号，F
# (] pop时如果最近的两个括号不是一类，也F

# 了解字符串的in 和 index
left = &amp;quot;({[&amp;quot;
right = &amp;quot;)}]&amp;quot;
a = &amp;quot;)&amp;quot;
a in right,a in left,left.index(&amp;quot;{&amp;quot;)==right.index(&amp;quot;}&amp;quot;),left.index(&amp;quot;[&amp;quot;)==right.index(&amp;quot;}&amp;quot;)

#######################
##    修改上面的函数为     ##
def parChecker2(strings_):
    strings = list(strings_)
    s = Stack()
    left = &amp;quot;({[&amp;quot;
    right = &amp;quot;)}]&amp;quot;
    stillbalance = True
    i=0
    
    while i &amp;lt; len(strings) and stillbalance:
        if strings[i] in left:
            s.push(strings[i])
        else: 
            if strings[i] in right: 
                if s.isEmpty()==True: 
                    stillbalance = False   
                else:  
                    tmp = s.pop()
                    if left.index(tmp)!=right.index(strings[i]): stillbalance = False       #  如果括号类型不匹配，F                       
        i =i+1
    
    results = stillbalance and s.isEmpty()    
    return(results, stillbalance, s.isEmpty())

# 测试
parChecker2(&amp;quot;2(s[x()x{er[]c}]s)0()&amp;quot;) 
parChecker2(&amp;quot;22{()}2asda[]2(&amp;quot;)
parChecker2(&amp;quot;2(s[x()x{er[]c}]s)0{]&amp;quot;)  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(True, False, True, False)






(True, True, True)






(False, True, False)






(False, False, True)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;二进制&#34;&gt;二进制&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;回忆整数二进制的含义，十进制转化为二进制：不断除以2，得到余数和需要的输出时反转关系——栈&lt;/li&gt;
&lt;li&gt;栈反转次序：每次push进去一个，先输入的压在后面了&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 函数十进制转二进制
def mybinary(num):
    s=Stack()
    while num&amp;gt;0:
        t = num % 2      # 取余数
        s.push(t)
        num = num//2   # 整数除
    return(s.items[::-1])

# 测试
mybinary(2)
mybinary(233)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[1, 0]






[1, 1, 1, 0, 1, 0, 0, 1]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;一维消消乐&#34;&gt;一维消消乐&lt;/h3&gt;
&lt;p&gt;逐个消去相邻的相同字符对&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入一个字符串，可能带有相邻的相同字符，如“aabbbc”&lt;/li&gt;
&lt;li&gt;输出一个字符串，消去了相邻的成对字符，如“bc”&lt;/li&gt;
&lt;li&gt;abbacddccc00，这里bb被消了以后，第二个a挨上来了，所以两个a也相邻，同样消去&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 定义函数
def xiaoxiaole(string):
    strings = list(string)
    s =Stack()
    s.push(strings[0])
    
    # 消消乐
    for i in range(1, len(strings)):
        if s.isEmpty()==True: 
            s.push(strings[i])
        else:
            if strings[i]!=s.peek():
                s.push(strings[i])
            else: s.pop()
    
    # 输出            
    if s.isEmpty()==True: 
        results = &amp;quot;None&amp;quot;
    else:
        results=&amp;quot;&amp;quot;
        for j in range(0,s.size()):
            results = results + s.items[j]
    
    return(results)

## 测试
xiaoxiaole(&amp;quot;abbacddccc00&amp;quot;)
xiaoxiaole(&amp;quot;beepooxxxyz&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&#39;None&#39;






&#39;bpxyz&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;棒球比赛记录&#34;&gt;棒球比赛记录&lt;/h3&gt;
&lt;p&gt;给定一个字符串列表，每个字符串可以是以下四种类型之一：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;整数（一轮的得分）：直接表示您在本轮中获得的积分数。&lt;/li&gt;
&lt;li&gt;&amp;quot;+&amp;quot;（一轮的得分）：表示本轮获得的得分是前两轮有效 回合得分的总和。&lt;/li&gt;
&lt;li&gt;&amp;quot;D&amp;quot;（一轮的得分）：表示本轮获得的得分是前一轮有效 回合得分的两倍。&lt;/li&gt;
&lt;li&gt;&amp;quot;C&amp;quot;（一个操作，这不是一个回合的分数）：表示您获得的最后一个有效回合的分数是无效的，应该被移除。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要返回你在所有回合中得分的总和&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def baseballscore(string):
    
    score = Stack()
    for i in range(0,len(string)):
        if string[i].isdigit() or string[i].lstrip(&#39;-&#39;).isdigit(): 
            score.push(int(string[i]))
        else: 
            if string[i]==&amp;quot;C&amp;quot;:
                score.pop()
            if string[i]==&amp;quot;+&amp;quot;:
                score.push(score.items[-1]+score.items[-2])
            if string[i]==&amp;quot;D&amp;quot;:
                score.push(score.peek()*2)
    return(sum(score.items))


baseballscore([&amp;quot;5&amp;quot;,&amp;quot;2&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;D&amp;quot;,&amp;quot;+&amp;quot;])
baseballscore([&amp;quot;5&amp;quot;,&amp;quot;-2&amp;quot;,&amp;quot;4&amp;quot;,&amp;quot;C&amp;quot;,&amp;quot;D&amp;quot;,&amp;quot;9&amp;quot;,&amp;quot;+&amp;quot;,&amp;quot;+&amp;quot;])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;30






27
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;队列&#34;&gt;队列&lt;/h2&gt;
&lt;p&gt;添加发生在尾端，移除发生在首端“先进先出”&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Image(filename = &#39;Desktop/快乐研一/python/queue1.jpg&#39;, width=300, height=300)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;output_23_0.jpeg&#34; alt=&#34;jpeg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 用list[0]作为队尾
class Queue:
    def __init__(self):
        self.items =[]
    def isEmpty(self):
        return self.items == []
    def enqueue(self, item):  # 复杂度o(n)
        return self.items.insert(0,item)
    def dequeue(self):      # 复杂度o1
        return self.items.pop()
    def size(self):
        return len(self.items)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;击鼓传花热土豆约瑟夫问题&#34;&gt;击鼓传花/热土豆/约瑟夫问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;输入：参加游戏人列表、每轮传递次数num&lt;/li&gt;
&lt;li&gt;输出：最后剩下的人名&lt;/li&gt;
&lt;li&gt;思路：传递时队首的人移除再从队尾加入，当传递num次时从队首移除但是不加入队尾，如此反复。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 定义函数
def hotpotato(namelist, num):
    thequeue = Queue() 
    for name in namelist:
        thequeue.enqueue(name)  # 初始化队列
    
    while thequeue.size() &amp;gt;1:  
        for i in range(0,num):  # 开始一轮
            thequeue.enqueue(thequeue.dequeue())
        thequeue.dequeue()   # 每轮结束踢出队首
    
    return(thequeue.dequeue())   # 最后剩下的

## 测试
hotpotato([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;,&#39;g&#39;,&#39;h&#39;], 7)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&#39;d&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;打印模拟&#34;&gt;打印模拟&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;按照概率生成打印作业，加入队列&lt;/li&gt;
&lt;li&gt;如果打印机空闲，则取队首打印，打印机忙碌，记录等待时间&lt;/li&gt;
&lt;li&gt;如果打印机忙碌，则按照打印速度进行&lt;/li&gt;
&lt;li&gt;如果完成，打印机进入空闲&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要计算平均等待&amp;amp;打印时间：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成作业+开始打印都要记录&lt;/li&gt;
&lt;li&gt;记录页数，除以打印时间&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 1.生成作业（ 180秒内会有一次作业）
import random

def newTask():   
    num = random.randrange(1,61)
    if num==6:
        return True    # 以1/60的概率生成作业
    else:                  # 59/60的概率不生成作业
        return False

    
# 2.记录打印时间、页数、等待时间
class Task:
    def __init__(self, time):
        self.timestamp = time   # 记录时间
        self.pages = random.randrange(1,21)
        
    def getStamp(self):
        return self.timestamp
    s
    def getPages(self):
        return self.pages
    
    def waitTime(self, currenttime):
        return currenttime - self.timestamp
    
    
# 3.生成打印机，记录打印进行、是否忙、开始打印新作业
class Printer():
    def __init__(self,ppm):         # ppm——打印速度
        self.pagerate = ppm        # 打印速度
        self.currentTask = None  # 当前的打印任务
        self.timeRemaining = 0   # 正在进行的任务还需要多久
        
    def tick(self):   # 打印进行
        if self.currentTask!=None:   # 对于当前的打印任务
            self.timeRemaining = self.timeRemaining - 1   # 当前任务进行中
            if self.timeRemaining &amp;lt;=0:    # 打印完毕
                self.currentTask = None
                
    def busy(self):    # 判断打印机是不是空闲
        if self.currentTask !=None:
            return True
        else:
            return False 
   
    def startNext(self,newtask):  # 打印新的作业
        self.currentTask = newtask
        self.timeRemaining = newtask.getPages()*60/self.pagerate
        
#### 正式模拟
def simulation(numSeconds, pagesPerMinute):  # 总时长，打印机每分钟打印页数
    labprinter = Printer(pagesPerMinute)   # 初始化打印机
    printQueue = Queue()       # 初始化一个空队列，准备存储打印队列
    waitingtime = []                # 初始化一个列表，准备存储每个task的等待时间
    
    # 开始模拟
    for currentSecond in range(numSeconds) :   # 在整个时间内
        
        # 1.生成任务
        if newTask():         # 每秒随机生成任务，如果成功生成了新任务
            task = Task(currentSecond)   # 记录任务的生成时间
            printQueue.enqueue(task)    # 任务队列增加一个
        
        # 2.打印机制
        if(not labprinter.busy()) and(not printQueue.isEmpty()):
            # 如果打印机处于空闲，并且任务队列不为空，就开始打印
            nexttask = printQueue.dequeue()   # 从队首拿出这个新任务
            waitingtime.append(nexttask.waitTime(currentSecond))# 更新等待时间
            labprinter.startNext(nexttask)
        
        labprinter.tick() # 有正在进行的任务，就进行，没有就标记完成
        
        if not printQueue.isEmpty():print(&amp;quot;%6d s，还有%d个任务&amp;quot;%(currentSecond, printQueue.size()))
    
    # 计算平均等待时间
    averageWait = sum(waitingtime)/len(waitingtime)
    print(&amp;quot;平均等待时间 %6.2f s，还剩 %d 个任务&amp;quot;%(averageWait, printQueue.size()))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;simulation(500,15) 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;   116 s，还有1个任务
   117 s，还有1个任务
   118 s，还有1个任务
   119 s，还有1个任务
   120 s，还有1个任务
   121 s，还有1个任务
   122 s，还有1个任务
   123 s，还有1个任务
   124 s，还有1个任务
   125 s，还有1个任务
   126 s，还有1个任务
   127 s，还有1个任务
   128 s，还有1个任务
   129 s，还有1个任务
   130 s，还有1个任务
   131 s，还有1个任务
   132 s，还有2个任务
   133 s，还有2个任务
   134 s，还有2个任务
   135 s，还有2个任务
   136 s，还有2个任务
   137 s，还有2个任务
   138 s，还有2个任务
   139 s，还有2个任务
   140 s，还有2个任务
   141 s，还有2个任务
   142 s，还有2个任务
   143 s，还有2个任务
   144 s，还有2个任务
   145 s，还有2个任务
   146 s，还有2个任务
   147 s，还有2个任务
   148 s，还有2个任务
   149 s，还有2个任务
   150 s，还有2个任务
   151 s，还有2个任务
   152 s，还有2个任务
   153 s，还有2个任务
   154 s，还有2个任务
   155 s，还有2个任务
   156 s，还有2个任务
   157 s，还有2个任务
   158 s，还有2个任务
   159 s，还有2个任务
   160 s，还有2个任务
   161 s，还有2个任务
   162 s，还有2个任务
   163 s，还有2个任务
   164 s，还有1个任务
   165 s，还有1个任务
   166 s，还有1个任务
   167 s，还有1个任务
   168 s，还有1个任务
   169 s，还有1个任务
   170 s，还有1个任务
   171 s，还有1个任务
   172 s，还有1个任务
   173 s，还有1个任务
   174 s，还有1个任务
   175 s，还有1个任务
   176 s，还有2个任务
   177 s，还有2个任务
   178 s，还有2个任务
   179 s，还有2个任务
   180 s，还有2个任务
   181 s，还有2个任务
   182 s，还有2个任务
   183 s，还有2个任务
   184 s，还有2个任务
   185 s，还有2个任务
   186 s，还有2个任务
   187 s，还有2个任务
   188 s，还有2个任务
   189 s，还有2个任务
   190 s，还有2个任务
   191 s，还有2个任务
   192 s，还有2个任务
   193 s，还有2个任务
   194 s，还有2个任务
   195 s，还有2个任务
   196 s，还有2个任务
   197 s，还有2个任务
   198 s，还有2个任务
   199 s，还有2个任务
   200 s，还有2个任务
   201 s，还有2个任务
   202 s，还有2个任务
   203 s，还有2个任务
   204 s，还有2个任务
   205 s，还有3个任务
   206 s，还有3个任务
   207 s，还有3个任务
   208 s，还有3个任务
   209 s，还有3个任务
   210 s，还有3个任务
   211 s，还有3个任务
   212 s，还有3个任务
   213 s，还有3个任务
   214 s，还有3个任务
   215 s，还有3个任务
   216 s，还有3个任务
   217 s，还有3个任务
   218 s，还有3个任务
   219 s，还有3个任务
   220 s，还有3个任务
   221 s，还有3个任务
   222 s，还有3个任务
   223 s，还有3个任务
   224 s，还有3个任务
   225 s，还有3个任务
   226 s，还有3个任务
   227 s，还有3个任务
   228 s，还有3个任务
   229 s，还有3个任务
   230 s，还有3个任务
   231 s，还有3个任务
   232 s，还有3个任务
   233 s，还有3个任务
   234 s，还有3个任务
   235 s，还有3个任务
   236 s，还有3个任务
   237 s，还有3个任务
   238 s，还有3个任务
   239 s，还有3个任务
   240 s，还有2个任务
   241 s，还有2个任务
   242 s，还有2个任务
   243 s，还有2个任务
   244 s，还有2个任务
   245 s，还有2个任务
   246 s，还有2个任务
   247 s，还有2个任务
   248 s，还有2个任务
   249 s，还有2个任务
   250 s，还有2个任务
   251 s，还有2个任务
   252 s，还有2个任务
   253 s，还有2个任务
   254 s，还有2个任务
   255 s，还有2个任务
   256 s，还有2个任务
   257 s，还有2个任务
   258 s，还有2个任务
   259 s，还有2个任务
   260 s，还有2个任务
   261 s，还有2个任务
   262 s，还有2个任务
   263 s，还有2个任务
   264 s，还有2个任务
   265 s，还有2个任务
   266 s，还有2个任务
   267 s，还有2个任务
   268 s，还有1个任务
   269 s，还有1个任务
   270 s，还有1个任务
   271 s，还有1个任务
   272 s，还有1个任务
   273 s，还有1个任务
   274 s，还有1个任务
   275 s，还有1个任务
   276 s，还有1个任务
   277 s，还有1个任务
   278 s，还有1个任务
   279 s，还有1个任务
   280 s，还有1个任务
   281 s，还有1个任务
   282 s，还有1个任务
   283 s，还有1个任务
   284 s，还有1个任务
   285 s，还有1个任务
   286 s，还有1个任务
   287 s，还有1个任务
   288 s，还有1个任务
   289 s，还有1个任务
   290 s，还有1个任务
   291 s，还有1个任务
   448 s，还有1个任务
   449 s，还有1个任务
   450 s，还有1个任务
   451 s，还有1个任务
   452 s，还有1个任务
   453 s，还有1个任务
   454 s，还有1个任务
   455 s，还有1个任务
   456 s，还有1个任务
   457 s，还有1个任务
   458 s，还有1个任务
   459 s，还有1个任务
   460 s，还有1个任务
   461 s，还有1个任务
   462 s，还有1个任务
   463 s，还有1个任务
   464 s，还有2个任务
   465 s，还有2个任务
   466 s，还有2个任务
   467 s，还有2个任务
   468 s，还有2个任务
   469 s，还有2个任务
   470 s，还有2个任务
   471 s，还有2个任务
   472 s，还有2个任务
   473 s，还有2个任务
   474 s，还有2个任务
   475 s，还有2个任务
   476 s，还有2个任务
   477 s，还有2个任务
   478 s，还有1个任务
   479 s，还有1个任务
   480 s，还有1个任务
   481 s，还有1个任务
   482 s，还有1个任务
   483 s，还有1个任务
   484 s，还有1个任务
   485 s，还有1个任务
   486 s，还有1个任务
   487 s，还有1个任务
   488 s，还有1个任务
   489 s，还有1个任务
   490 s，还有1个任务
   491 s，还有1个任务
   492 s，还有1个任务
   493 s，还有1个任务
   494 s，还有1个任务
   495 s，还有1个任务
   496 s，还有1个任务
   497 s，还有1个任务
   498 s，还有1个任务
   499 s，还有1个任务
平均等待时间  40.56 s，还剩 1 个任务
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;双端队列回文词&#34;&gt;双端队列——回文词&lt;/h2&gt;
&lt;p&gt;队首队尾都可以加入或者移除&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 懒得实现了，直接用list操作
队首：x.pop(0) x.insert(0,new)
队尾: x.pop()  x.append(new)
size: len(x)
是否为空：x==[]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 回文词判定
def ishuiwen(string):
    string = list(string)
    stillhuiwen = True
    while len(string) &amp;gt; 1 and stillhuiwen:
        tou = string.pop(0)
        wei = string.pop()
        if tou!=wei: stillhuiwen = False
    return(stillhuiwen)

# 测试
ishuiwen(&amp;quot;上海自来水来自海上&amp;quot;)
ishuiwen(&amp;quot;上海自来水不来自海上&amp;quot;)
ishuiwen(&amp;quot;上海自来水水来自海上&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;True






False






True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;链表&#34;&gt;链表&lt;/h2&gt;
&lt;h3 id=&#34;无序&#34;&gt;无序&lt;/h3&gt;
&lt;p&gt;数据项存放位置没有规则，在数据项之间建立链接指向，就可以保持其前后相对位置，第一个和最后一个需要显示标记出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 节点Node&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- 节点至少包括两个信息：数据本身&amp;amp;指向下一个节点的引用信息
- data + next
- 无序表本身不包含数据项，它包含的head只是对第一个节点的引用。
- 判断isEmpty很容易，self.head是不是none即可
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## node实现
class Node:
    def __init__(self,initdata):
        self.data = initdata   # 数据项
        self.next = None       # 指向
        
    def getData(self):
        return self.data
    
    def getNext(self):
        return self.next
    
    def setData(self, newdata):
        self.data = new.data
    
    def setNext(self,newnext):
        self.next = newnext

## 链表实现
class Unorderedlist:    # 只需要一个引用第一个节点的head
    def __init__(self):
        self.head = None
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 使用
lian = Unorderedlist()
node1 = Node(&amp;quot;第一个数据&amp;quot;)
node2 = Node(&amp;quot;第二个数据&amp;quot;)
lian.head = node1
lian.head.setNext(node2)
lian.head.getData() ,lian.head.getNext().getData()   # 第二个节点的数据项
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(&#39;第一个数据&#39;, &#39;第二个数据&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. add&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最快捷的——在表头添加，次序时倒过来的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. size&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从head开始遍历，累加经过的节点个数（不是none就+1）&lt;br&gt;
- 链式存储求size要走循环，o(n)&lt;br&gt;
- 顺序存储求size，拿最后一项地址-第一项地址，复杂度o1&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. search&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从head开始遍历，判断当前节点数据项是否为目标&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.remove&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先遍历查找，然后删除，删除是把前一个节点的next指向当前的下一个节点（跳过当前）。所以遍历过程中需要保留当前的前一个节点，即不断更新（previous,current)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;双链表：每个节点有数据项本身+previous+next&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 实现
lian = Unorderedlist()
node1 = Node(&amp;quot;第一个数据&amp;quot;)
node2 = Node(&amp;quot;第二个数据&amp;quot;)
lian.head = node1
lian.head.setNext(node2)
lian.head.getData() ,lian.head.getNext().getData()   # 第二个节点的数据项


##### 1.add
def add(self, item):      # 添加在表头
    tmp = Node(item)   # 根据当前数据项生成新节点
    tmp.setNext(self.head)  # 新节点的指向原本的head
    self.head = tmp     # 把当前head替换成新节点
# 使用add加上一个
add(lian, &amp;quot;新加的第一个数据&amp;quot;)
lian.head.getData(),lian.head.getNext().getData(),lian.head.getNext().getNext().getData()


######2.size
def size(self):
    counter = 0
    tmp = self.head
    while tmp!=None:    # 指向不是none
        tmp = tmp.getNext()  # 就跳到下一个
        counter+=1         # 并且计数+1
    return counter
# 测试
size(lian)


######3.search
def search(self, item):
    tmp = self.head
    match = False
    while (tmp!=None) and (not match):
        if tmp.getData()==item:
            match = True
        else:
            tmp = tmp.getNext()
    return match
# 测试
print(&amp;quot;是否包含“第三个数据”：{} \n是否包含“第二个数据”：{}&amp;quot;.format(search(lian,&#39;第三个数据&#39;),search(lian,&#39;第二个数据&#39;)))


#####4.remove
def remove(self,item):
    found = False
    current = self.head
    previous = None
    
    while not found:
        if current.getData() == item: 
            found==True
        else: 
            previous = current    # 一个迭代的思路
            current = current.getNext()
        
    if previous == None:
        self.head = current.getNext()
    else:
        previous.setNext(current.getNext())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(&#39;第一个数据&#39;, &#39;第二个数据&#39;)






(&#39;新加的第一个数据&#39;, &#39;第一个数据&#39;, &#39;第二个数据&#39;)






3



是否包含“第三个数据”：False 
是否包含“第二个数据”：True
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;有序&#34;&gt;有序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据项的相对位置取决于大小，“大小”判定方式可以自己定义&lt;/li&gt;
&lt;li&gt;采用链表的方式实现，但是 &lt;strong&gt;区别在于search 和 add&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;search：当数据项大于item时候，可以stop了，直接返回F&lt;/li&gt;
&lt;li&gt;add：需要维护有序性，找到第一个比item大的项，插到前面，需要previous+current，不断更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 实现下有序表的add:
def add(self, item):
    current = self.head
    previous = None
    stop = False
    
    while current!=None and (not stop):
        if current.getData()&amp;gt;item:
            stop = True
        else: 
            previous = current
            current = current.getNext()
    
    newnode = Node(item)
    if previous == None:
        newnode.setNext(self.head)
        self.head = newnode
    else:
        newnode.setNext(current)
        previous.setNext(newnode)

# 测试
class Orderedlist:    # 只需要一个引用第一个节点的head
    def __init__(self):
        self.head = None
youxu = Orderedlist() 
node1 = Node(3)
youxu.head = node1
add(youxu,1)
add(youxu,5)
youxu.head.getData(),youxu.head.getNext().getData(), youxu.head.getNext().getNext().getData()

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(1, 3, 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;链表复杂度的总结&#34;&gt;链表复杂度的总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;size、search、remove、有序表add——遍历 o(n)&lt;/li&gt;
&lt;li&gt;isEmpty、无序表add ——o(1)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;list-2&#34;&gt;list&lt;/h3&gt;
&lt;p&gt;基于顺序存储，并优化了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;不太熟悉的：
remove(item)   查找并删除某个item
search(item)    查找item，返回bool值
index(item)      查找item，返回索引值
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;name&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;特点&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;基本操作&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;栈&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;后进先出&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;push, pop, isEmpty&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;队列&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;先进先出&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;enqueue, dequeue, isEmpty&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;双端队列&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;两头进出&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;链表&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;自由进出，保持相对位置，不需要连续的存储空间&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;练习题目——基数排序：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;题目内容：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实现一个基数排序算法，用于10进制的正整数从小到大的排序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;思路是保持10个队列(队列0、队列1......队列9、队列main)，&lt;br&gt;
开始，所有的数都在main队列，没有排序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;第一趟将所有的数根据其10进制个位(0&lt;sub&gt;9)，放入相应的队列0&lt;/sub&gt;9，全放好后，按照FIFO的顺序，将每个队列的数合并排到main队列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;第二趟再从main队列队首取数，根据其十位的数值，放入相应队列0~9，全放好后，仍然按照FIFO的顺序，将每个队列的数合并排到main队列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;第三趟放百位，再合并；第四趟放千位，再合并。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;直到最多的位数放完，合并完，这样main队列里就是排好序的数列了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;输入格式:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个列表mylist，其中mylist包含一些需要排序的正整数，正整数互不相同且均不超过100000，且个数在1至1000之间。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;输出格式：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一个与mylist等长的列表。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a = [8, 91, 341, 22, 65, 381,109,1000, 4, 55, 18,77,225,343,6]
temp=[]
main = a                          # 最开始所有元素都在main
maxlen = len(str(max(a)))   # 最大位数

for i in range(10):              #  先预备10维数组，分别准备存0~9
    temp.append([])

for j in range(maxlen):       # 每一次循环都把j位的数字排序好    
    while main!=[]:               
        num = main.pop()      # 取出main队列的最后一位，并从main中删除
        i = num//(10**j)%10  # 取出对应位数的数字
        temp[i].append(num)       # 根据对应位数的数字，填入  
    for i in range(10):           # 按照某位上的数字大小排序
        while temp[i]!=[]:       # j位上等于i，就加入main
            main.append(temp[i].pop())    # 顺便清空mylist，准备下一位数
    print(j+1, main)     
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1 [1000, 91, 341, 381, 22, 343, 4, 65, 55, 225, 6, 77, 8, 18, 109]
2 [1000, 4, 6, 8, 109, 18, 22, 225, 341, 343, 55, 65, 77, 381, 91]
3 [1000, 4, 6, 8, 18, 22, 55, 65, 77, 91, 109, 225, 341, 343, 381]
4 [4, 6, 8, 18, 22, 55, 65, 77, 91, 109, 225, 341, 343, 381, 1000]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;递归&#34;&gt;递归&lt;/h1&gt;
">栈、队列</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/BP0922/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%AC%E5%91%A8%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92&#34;&gt;本周学习计划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bp%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E4%BA%8E%E5%8D%95%E4%B8%AA%E6%A0%B7%E6%9C%AC&#34;&gt;BP神经网络（基于单个样本）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B&#34;&gt;算法基本流程：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%95%E6%A0%B7%E6%9C%AC%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%BA%90%E7%A0%81&#34;&gt;单样本梯度下降源码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C&#34;&gt;更复杂的神经网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9A%8F%E6%9C%BA%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95&#34;&gt;随机梯度下降法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%8F%E9%AA%8C&#34;&gt;经验&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%87%BA%E7%8E%B0%E4%BB%A5%E4%B8%8B%E6%83%85%E5%86%B5%E8%AF%B7%E6%B3%A8%E6%84%8F&#34;&gt;出现以下情况请注意&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%AD%A3%E5%88%99%E9%A1%B9&#34;&gt;正则项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BD%92%E4%B8%80%E5%8C%96%E6%A0%87%E5%87%86%E5%8C%96&#34;&gt;归一化（标准化）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%82%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96&#34;&gt;参数初始化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1%E7%8E%B0%E8%B1%A1&#34;&gt;梯度消失现象&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A2%AF%E5%BA%A6%E7%9B%B8%E5%85%B3%E4%B8%A4%E5%A4%A7%E9%97%AE%E9%A2%98&#34;&gt;梯度相关两大问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#tensorflow&#34;&gt;TensorFlow&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;本周学习计划&#34;&gt;本周学习计划&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;周一 SVM&lt;/li&gt;
&lt;li&gt;周二 BP算法，基本框架理解&lt;/li&gt;
&lt;li&gt;周三 随机梯度下降，adam优化算法，TensorFlow&lt;/li&gt;
&lt;li&gt;周四 卷积神经网络，TensorFlow&lt;/li&gt;
&lt;li&gt;周五 卷积神经网络，TensorFlow&lt;/li&gt;
&lt;li&gt;下周 时间序列的深度学习模型 LSTM&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;bp神经网络基于单个样本&#34;&gt;BP神经网络（基于单个样本）&lt;/h1&gt;
&lt;h2 id=&#34;算法基本流程&#34;&gt;算法基本流程：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;首先给出w和b的值&lt;/li&gt;
&lt;li&gt;向前选择：计算并且保留每一层输出值，直到最后一层的输出值y&lt;/li&gt;
&lt;li&gt;向后传播：对于每一个w和b，计算偏导（具体计算时，先算枢纽变量偏导，再计算各参数偏导）&lt;/li&gt;
&lt;li&gt;迭代更新：梯度下降原理迭代更新w和b&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell 
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;单样本梯度下降源码&#34;&gt;单样本梯度下降源码&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 加载绝对路径的本地图片
#from IPython.display import Image
#Image(filename = &#39;/Users/mac/Desktop/快乐研一/python/机器学习/bp算法/2.jpeg&#39;, width=400, height=400)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np

# 首先给出w和b的初始值，w为6维，b为3维
w = np.arange(0,1,0.18)
b = np.arange(3)

# 给出单个样本数据的增广向量，假设两个变量取值为5和10，y的取值为0.9
x = (5, 10, 0.5)

# 定义sigmoid函数及其导函数
def sigmoid(z):          # sigmoid函数
    return 1/(1+np.exp(-z))

def sigmoid_der(z):    # sigmoid导函数
    return sigmoid(z)*(1-sigmoid(z))   
  
################################
### 第一次向前选择，计算各层输出值 ###

# 第一层两个神经元wTx+b:
a1 = w[0]*x[0] + w[1]*x[1]+b[0]
a2 = w[2]*x[0] + w[3]*x[1]+b[1]

# 激活函数z=sigmoid(a)
z1 = sigmoid(a1)
z2 = sigmoid(a2)

# 第二层一个神经元 wTz+b:
z3 = sigmoid(w[4]*z1 + w[5]*z2+b[2])

# 计算误差平方
e2 = np.square(z3-x[2])

##################################
### 第一次向后传播，各系数按梯度调整 ###

learning_rate = 0.5   # 学习率设为0.5

# 从第二层的系数开始更新：
w[4] = w[4] - learning_rate * (z3 - x[2]) * z1
w[5] = w[5] - learning_rate * (z3 - x[2]) * z2
b[2] = b[2] - learning_rate * (z3 - x[2])

# 再更新第一层的系数：
w[0] = w[0] - learning_rate * (z3-x[2])* w[4] * sigmoid_der(a1) * x[0]
w[1] = w[1] - learning_rate * (z3-x[2])* w[4] * sigmoid_der(a1) * x[1]
w[2] = w[2]- learning_rate * (z3-x[2])* w[5] * sigmoid_der(a2) * x[0]
w[3] = w[3] - learning_rate * (z3-x[2])* w[5] * sigmoid_der(a2) * x[1]
b[0] = b[0] - learning_rate * (z3 - x[2]) * w[4] * sigmoid_der(a1)
b[1] = b[1] - learning_rate * (z3 - x[2]) * w[5] * sigmoid_der(a2)

# 返回值
print(&#39;第一次迭代后：\n第一层权重w：{}，b：{}\n第二层权重w：{}，b：{}\n预测值{}&#39;.format(w[0:4],b[0:2],w[4:6],b[2],z3))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;第一次迭代后：
第一层权重w：[-0.07425249  0.03149502  0.35978514  0.53957028]，b：[0 0]
第二层权重w：[0.51782656 0.6644722 ]，b：1
预测值0.9711849782403342
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#################################
### 下面整理成为一个循环，定义函数  ###

def mybp(w, b, x, learning_rate):   # 分别为w和b的初始值、输入数据的增广向量、学习率
   
     # 1.向前选择
    a1 = w[0]*x[0] + w[1]*x[1]+b[0]
    a2 = w[2]*x[0] + w[3]*x[1]+b[1]
    z1 = sigmoid(a1)
    z2 = sigmoid(a2)
    z3 = sigmoid(w[4]*z1 + w[5]*z2+b[2])
    e2 = np.square(z3-x[2])
    
    # 2.向后传播迭代
    w[4] = w[4] - learning_rate * (z3 - x[2]) * z1
    w[5] = w[5] - learning_rate * (z3 - x[2]) * z2
    b[2] = b[2] - learning_rate * (z3 - x[2])
    w[0] = w[0] - learning_rate * (z3-x[2])* w[4] * sigmoid_der(a1) * x[0]
    w[1] = w[1] - learning_rate * (z3-x[2])* w[4] * sigmoid_der(a1) * x[1]
    w[2] = w[2]- learning_rate * (z3-x[2])* w[5] * sigmoid_der(a2) * x[0]
    w[3] = w[3] - learning_rate * (z3-x[2])* w[5] * sigmoid_der(a2) * x[1]
    b[0] = b[0] - learning_rate * (z3 - x[2]) * w[4] * sigmoid_der(a1)
    b[1] = b[1] - learning_rate * (z3 - x[2]) * w[5] * sigmoid_der(a2)
    
    # 输出y预测值、迭代后的系数w和b、误差平方
    return z3,w,b,e2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;w = np.arange(0,1,0.18)
b = np.arange(3)
x = (5, 11, 0.5)

# 循环迭代
for i in range(66):  # 迭代次数
    y_pred,w,b,e2 = mybp(w, b, x, 0.3)
    print(&#39;第{}次迭代，预测值为({})，迭代后第一层w：{}，迭代后第二层w：{}&#39;.format(i, np.round(y_pred,8),np.round(w[0:4],4),np.round(w[4:6],4)))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;第0次迭代，预测值为(0.97159866)，迭代后第一层w：[-0.0449  0.0812  0.3599  0.5398]，迭代后第二层w：[0.5957 0.7585]
第1次迭代，预测值为(0.89585902)，迭代后第一层w：[-0.1137 -0.0702  0.3597  0.5394]，迭代后第二层w：[0.5172 0.6398]
第2次迭代，预测值为(0.67848608)，迭代后第一层w：[-0.136  -0.1192  0.3597  0.5393]，迭代后第二层w：[0.5061 0.5863]
第3次迭代，预测值为(0.6563031)，迭代后第一层w：[-0.1484 -0.1465  0.3596  0.5392]，迭代后第二层w：[0.5004 0.5394]
第4次迭代，预测值为(0.64167738)，迭代后第一层w：[-0.1568 -0.1649  0.3596  0.5391]，迭代后第二层w：[0.4967 0.497 ]
第5次迭代，预测值为(0.62975449)，迭代后第一层w：[-0.163  -0.1785  0.3595  0.539 ]，迭代后第二层w：[0.494  0.4581]
第6次迭代，预测值为(0.61933944)，迭代后第一层w：[-0.1678 -0.1892  0.3595  0.5389]，迭代后第二层w：[0.4919 0.4223]
第7次迭代，预测值为(0.60998463)，迭代后第一层w：[-0.1717 -0.1978  0.3595  0.5388]，迭代后第二层w：[0.4903 0.3893]
第8次迭代，预测值为(0.60147204)，迭代后第一层w：[-0.175  -0.205   0.3595  0.5388]，迭代后第二层w：[0.4889 0.3589]
第9次迭代，预测值为(0.59367392)，迭代后第一层w：[-0.1777 -0.211   0.3594  0.5388]，迭代后第二层w：[0.4877 0.3308]
第10次迭代，预测值为(0.58650416)，迭代后第一层w：[-0.1801 -0.2162  0.3594  0.5387]，迭代后第二层w：[0.4867 0.3048]
第11次迭代，预测值为(0.57989849)，迭代后第一层w：[-0.1821 -0.2207  0.3594  0.5387]，迭代后第二层w：[0.4858 0.2809]
第12次迭代，预测值为(0.57380521)，迭代后第一层w：[-0.1839 -0.2246  0.3594  0.5387]，迭代后第二层w：[0.4851 0.2587]
第13次迭代，预测值为(0.56818064)，迭代后第一层w：[-0.1855 -0.2281  0.3594  0.5386]，迭代后第二层w：[0.4844 0.2383]
第14次迭代，预测值为(0.56298663)，迭代后第一层w：[-0.1869 -0.2311  0.3594  0.5386]，迭代后第二层w：[0.4838 0.2194]
第15次迭代，预测值为(0.55818912)，迭代后第一层w：[-0.1881 -0.2338  0.3594  0.5386]，迭代后第二层w：[0.4833 0.202 ]
第16次迭代，预测值为(0.55375728)，迭代后第一层w：[-0.1892 -0.2362  0.3594  0.5386]，迭代后第二层w：[0.4828 0.1858]
第17次迭代，预测值为(0.54966302)，迭代后第一层w：[-0.1902 -0.2384  0.3593  0.5386]，迭代后第二层w：[0.4824 0.1709]
第18次迭代，预测值为(0.54588051)，迭代后第一层w：[-0.191  -0.2403  0.3593  0.5386]，迭代后第二层w：[0.482  0.1572]
第19次迭代，预测值为(0.54238604)，迭代后第一层w：[-0.1918 -0.242   0.3593  0.5385]，迭代后第二层w：[0.4817 0.1445]
第20次迭代，预测值为(0.53915768)，迭代后第一层w：[-0.1926 -0.2436  0.3593  0.5385]，迭代后第二层w：[0.4814 0.1327]
第21次迭代，预测值为(0.53617521)，迭代后第一层w：[-0.1932 -0.2451  0.3593  0.5385]，迭代后第二层w：[0.4811 0.1219]
第22次迭代，预测值为(0.53341996)，迭代后第一层w：[-0.1938 -0.2463  0.3593  0.5385]，迭代后第二层w：[0.4808 0.1119]
第23次迭代，预测值为(0.53087463)，迭代后第一层w：[-0.1943 -0.2475  0.3593  0.5385]，迭代后第二层w：[0.4806 0.1026]
第24次迭代，预测值为(0.52852327)，迭代后第一层w：[-0.1948 -0.2486  0.3593  0.5385]，迭代后第二层w：[0.4804 0.0941]
第25次迭代，预测值为(0.52635111)，迭代后第一层w：[-0.1953 -0.2496  0.3593  0.5385]，迭代后第二层w：[0.4802 0.0861]
第26次迭代，预测值为(0.52434451)，迭代后第一层w：[-0.1957 -0.2505  0.3593  0.5385]，迭代后第二层w：[0.48   0.0788]
第27次迭代，预测值为(0.52249085)，迭代后第一层w：[-0.196  -0.2513  0.3593  0.5385]，迭代后第二层w：[0.4799 0.0721]
第28次迭代，预测值为(0.52077847)，迭代后第一层w：[-0.1964 -0.252   0.3593  0.5385]，迭代后第二层w：[0.4797 0.0659]
第29次迭代，预测值为(0.5191966)，迭代后第一层w：[-0.1967 -0.2527  0.3593  0.5385]，迭代后第二层w：[0.4796 0.0601]
第30次迭代，预测值为(0.5177353)，迭代后第一层w：[-0.197  -0.2533  0.3593  0.5385]，迭代后第二层w：[0.4795 0.0548]
第31次迭代，预测值为(0.51638536)，迭代后第一层w：[-0.1972 -0.2539  0.3593  0.5385]，迭代后第二层w：[0.4794 0.0499]
第32次迭代，预测值为(0.51513828)，迭代后第一层w：[-0.1975 -0.2544  0.3593  0.5385]，迭代后第二层w：[0.4793 0.0453]
第33次迭代，预测值为(0.51398623)，迭代后第一层w：[-0.1977 -0.2549  0.3593  0.5385]，迭代后第二层w：[0.4792 0.0412]
第34次迭代，预测值为(0.51292195)，迭代后第一层w：[-0.1979 -0.2553  0.3593  0.5385]，迭代后第二层w：[0.4791 0.0373]
第35次迭代，预测值为(0.51193874)，迭代后第一层w：[-0.1981 -0.2557  0.3593  0.5385]，迭代后第二层w：[0.479  0.0337]
第36次迭代，预测值为(0.51103042)，迭代后第一层w：[-0.1982 -0.2561  0.3593  0.5385]，迭代后第二层w：[0.4789 0.0304]
第37次迭代，预测值为(0.51019128)，迭代后第一层w：[-0.1984 -0.2564  0.3593  0.5385]，迭代后第二层w：[0.4789 0.0273]
第38次迭代，预测值为(0.50941603)，迭代后第一层w：[-0.1985 -0.2568  0.3593  0.5385]，迭代后第二层w：[0.4788 0.0245]
第39次迭代，预测值为(0.50869982)，迭代后第一层w：[-0.1987 -0.2571  0.3593  0.5385]，迭代后第二层w：[0.4788 0.0219]
第40次迭代，预测值为(0.50803813)，迭代后第一层w：[-0.1988 -0.2573  0.3593  0.5385]，迭代后第二层w：[0.4787 0.0195]
第41次迭代，预测值为(0.50742681)，迭代后第一层w：[-0.1989 -0.2576  0.3593  0.5385]，迭代后第二层w：[0.4787 0.0173]
第42次迭代，预测值为(0.50686202)，迭代后第一层w：[-0.199  -0.2578  0.3593  0.5385]，迭代后第二层w：[0.4786 0.0152]
第43次迭代，预测值为(0.50634022)，迭代后第一层w：[-0.1991 -0.258   0.3593  0.5385]，迭代后第二层w：[0.4786 0.0133]
第44次迭代，预测值为(0.50585812)，迭代后第一层w：[-0.1992 -0.2582  0.3593  0.5385]，迭代后第二层w：[0.4785 0.0115]
第45次迭代，预测值为(0.50541271)，迭代后第一层w：[-0.1993 -0.2584  0.3593  0.5385]，迭代后第二层w：[0.4785 0.0099]
第46次迭代，预测值为(0.50500118)，迭代后第一层w：[-0.1993 -0.2585  0.3593  0.5385]，迭代后第二层w：[0.4785 0.0084]
第47次迭代，预测值为(0.50462096)，迭代后第一层w：[-0.1994 -0.2587  0.3593  0.5385]，迭代后第二层w：[0.4784 0.007 ]
第48次迭代，预测值为(0.50426967)，迭代后第一层w：[-0.1995 -0.2588  0.3593  0.5385]，迭代后第二层w：[0.4784 0.0058]
第49次迭代，预测值为(0.50394509)，迭代后第一层w：[-0.1995 -0.2589  0.3593  0.5385]，迭代后第二层w：[0.4784 0.0046]
第50次迭代，预测值为(0.5036452)，迭代后第一层w：[-0.1996 -0.2591  0.3593  0.5385]，迭代后第二层w：[0.4784 0.0035]
第51次迭代，预测值为(0.50336812)，迭代后第一层w：[-0.1996 -0.2592  0.3593  0.5385]，迭代后第二层w：[0.4783 0.0025]
第52次迭代，预测值为(0.50311211)，迭代后第一层w：[-0.1997 -0.2593  0.3593  0.5385]，迭代后第二层w：[0.4783 0.0015]
第53次迭代，预测值为(0.50287557)，迭代后第一层w：[-0.1997 -0.2594  0.3593  0.5385]，迭代后第二层w：[0.4783 0.0007]
第54次迭代，预测值为(0.50265701)，迭代后第一层w：[-0.1997 -0.2594  0.3593  0.5385]，迭代后第二层w：[ 4.783e-01 -1.000e-04]
第55次迭代，预测值为(0.50245507)，迭代后第一层w：[-0.1998 -0.2595  0.3593  0.5385]，迭代后第二层w：[ 0.4783 -0.0009]
第56次迭代，预测值为(0.50226848)，迭代后第一层w：[-0.1998 -0.2596  0.3593  0.5385]，迭代后第二层w：[ 0.4783 -0.0015]
第57次迭代，预测值为(0.50209608)，迭代后第一层w：[-0.1998 -0.2597  0.3593  0.5385]，迭代后第二层w：[ 0.4783 -0.0022]
第58次迭代，预测值为(0.50193678)，迭代后第一层w：[-0.1999 -0.2597  0.3593  0.5385]，迭代后第二层w：[ 0.4782 -0.0027]
第59次迭代，预测值为(0.50178959)，迭代后第一层w：[-0.1999 -0.2598  0.3593  0.5385]，迭代后第二层w：[ 0.4782 -0.0033]
第60次迭代，预测值为(0.5016536)，迭代后第一层w：[-0.1999 -0.2598  0.3593  0.5385]，迭代后第二层w：[ 0.4782 -0.0038]
第61次迭代，预测值为(0.50152794)，迭代后第一层w：[-0.1999 -0.2599  0.3593  0.5385]，迭代后第二层w：[ 0.4782 -0.0042]
第62次迭代，预测值为(0.50141183)，迭代后第一层w：[-0.2    -0.2599  0.3593  0.5385]，迭代后第二层w：[ 0.4782 -0.0047]
第63次迭代，预测值为(0.50130454)，迭代后第一层w：[-0.2    -0.26    0.3593  0.5385]，迭代后第二层w：[ 0.4782 -0.0051]
第64次迭代，预测值为(0.50120541)，迭代后第一层w：[-0.2    -0.26    0.3593  0.5385]，迭代后第二层w：[ 0.4782 -0.0054]
第65次迭代，预测值为(0.50111381)，迭代后第一层w：[-0.2    -0.2601  0.3593  0.5385]，迭代后第二层w：[ 0.4782 -0.0057]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;更复杂的神经网络&#34;&gt;更复杂的神经网络&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 加载绝对路径的本地图片
#from IPython.display import Image
#Image(filename = &#39;/Users/mac/Desktop/快乐研一/python/机器学习/bp算法/1.jpeg&#39;, width=50, height=50)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;随机梯度下降法&#34;&gt;随机梯度下降法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;把样本分组，每组50-200个样本，每组叫做一个BATCH&lt;/li&gt;
&lt;li&gt;每次输入一个BATCH，用它们的梯度平均值来调整参数&lt;/li&gt;
&lt;li&gt;把所有BATCH遍历也就是把样本遍历一次，叫做一个EPOCH&lt;/li&gt;
&lt;li&gt;做多次EPOCH，每次打乱样本顺序再划分BATCH，以增加BATCH内样本随机性&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;经验&#34;&gt;经验&lt;/h1&gt;
&lt;h2 id=&#34;出现以下情况请注意&#34;&gt;出现以下情况请注意&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当在训练集上目标函数的平均值增大时：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模型不够复杂以至于不能完全拟合&lt;/li&gt;
&lt;li&gt;已经训练的很好了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CV 训练集 验证集 测试集&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调整学习率：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果目标函数变化太小——α太小&lt;/li&gt;
&lt;li&gt;如果刚开始目标函数就增加——α太大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;正则项&#34;&gt;正则项&lt;/h2&gt;
&lt;p&gt;即加入L1或者L2正则（回忆下岭回归和lasso的特点），避免过拟合&lt;/p&gt;
&lt;h2 id=&#34;归一化标准化&#34;&gt;归一化（标准化）&lt;/h2&gt;
&lt;p&gt;最好做归一化！！！&lt;/p&gt;
&lt;p class=&#39;katex-block&#39;&gt;&lt;span class=&#34;katex-display&#34;&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\frac{x-mean}{std}
&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.9463300000000001em;vertical-align:-0.686em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:1.2603300000000002em;&#34;&gt;&lt;span style=&#34;top:-2.314em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.677em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.686em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;参数初始化&#34;&gt;参数初始化&lt;/h2&gt;
&lt;h2 id=&#34;梯度消失现象&#34;&gt;梯度消失现象&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;由于初始值w和b是人为选定的，如果一开始wTx+b的绝对值很大，根据sigmoid函数图像会发现梯度将会趋近于0，经过后向传播所有梯度都会接近0.——&lt;strong&gt;导致训练缓慢&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一种有效的解决方案是，初始化时从区间&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msqrt&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/msqrt&gt;&lt;/mfrac&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mfrac&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msqrt&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/msqrt&gt;&lt;/mfrac&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;(-\frac{1}{\sqrt{d}}, \frac{1}{\sqrt{d}})&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.383108em;vertical-align:-0.538em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.845108em;&#34;&gt;&lt;span style=&#34;top:-2.5335085em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord sqrt mtight&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.937845em;&#34;&gt;&lt;span class=&#34;svg-align&#34; style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mtight&#34; style=&#34;padding-left:0.833em;&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.8978450000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;hide-tail mtight&#34; style=&#34;min-width:0.853em;height:1.08em;&#34;&gt;&lt;svg width=&#39;400em&#39; height=&#39;1.08em&#39; viewBox=&#39;0 0 400000 1080&#39; preserveAspectRatio=&#39;xMinYMin slice&#39;&gt;&lt;path d=&#39;M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.102155em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.394em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.538em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mopen nulldelimiter&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mfrac&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.845108em;&#34;&gt;&lt;span style=&#34;top:-2.5335085em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord sqrt mtight&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.937845em;&#34;&gt;&lt;span class=&#34;svg-align&#34; style=&#34;top:-3em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mtight&#34; style=&#34;padding-left:0.833em;&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;d&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-2.8978450000000002em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;hide-tail mtight&#34; style=&#34;min-width:0.853em;height:1.08em;&#34;&gt;&lt;svg width=&#39;400em&#39; height=&#39;1.08em&#39; viewBox=&#39;0 0 400000 1080&#39; preserveAspectRatio=&#39;xMinYMin slice&#39;&gt;&lt;path d=&#39;M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,
-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,
-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,
35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,
-221c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467
s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422
s-65,47,-65,47z M834 80H400000v40H845z&#39;/&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.102155em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.23em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;frac-line&#34; style=&#34;border-bottom-width:0.04em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.394em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:3em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.538em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose nulldelimiter&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;均匀取值，d是参数所在层的神经元个数。使得WTX+B尽量靠近0.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BATCH normalization，我们希望每一层输出值都在0附近，从而避免梯度消失线性，因此对每一层做基于均值和方差的标准化/归一化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;梯度相关两大问题&#34;&gt;梯度相关两大问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;“梯度分类不平衡”&lt;/strong&gt;，由于每个分量的梯度绝对值有大有小，优化路径变成z型，速度下降。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;“梯度方向随机性”&lt;/strong&gt; 引入momentum概念，考虑这次梯度和上次梯度的加权求和，降低搜索路径的随机性。&lt;/li&gt;
&lt;li&gt;Adam算法（进一步学习）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;tensorflow&#34;&gt;TensorFlow&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import tensorflow as tf
print(&#39;加载成功!&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;加载成功!
&lt;/code&gt;&lt;/pre&gt;
">手动实现——单样本bp算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/LDASVM-0921/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8Bldasvm&#34;&gt;分类模型——LDA&amp;amp;SVM&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AF%BB%E5%85%A5%E5%92%8C%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE&#34;&gt;读入和处理数据&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sklearn%E4%B8%ADsvm%E6%9C%89linearsvc-nusvc%E5%92%8Csvc%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95&#34;&gt;Sklearn中SVM有LinearSVC、NuSVC和SVC三种方法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#linearsvc&#34;&gt;LinearSVC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nusvc&#34;&gt;NuSVC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#svc&#34;&gt;SVC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%9F%E4%B8%80%E6%96%B9%E6%B3%95&#34;&gt;统一方法：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E4%BE%8B%E9%AB%98%E6%96%AF%E6%A0%B8svm&#34;&gt;实例——高斯核SVM&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B0%83%E5%8F%82%E6%8A%80%E5%B7%A7c&#34;&gt;调参技巧——C&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%99%E5%AE%9A%E8%B6%85%E5%8F%82%E6%95%B0%E5%80%BC&#34;&gt;给定超参数值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B6%85%E5%8F%82%E6%95%B0%E8%87%AA%E5%8A%A8%E6%90%9C%E7%B4%A2%E6%A8%A1%E5%9D%97gridsearchcv&#34;&gt;超参数自动搜索模块GridSearchCV&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E4%BE%8Blda&#34;&gt;实例——LDA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;分类模型ldasvm&#34;&gt;分类模型——LDA&amp;amp;SVM&lt;/h1&gt;
&lt;p&gt;结合一个实例分析，约会数据分析，暂时取二变量方便理解&lt;/p&gt;
&lt;h2 id=&#34;读入和处理数据&#34;&gt;读入和处理数据&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#j加载
import os
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    


## 不显示warnings
import warnings
warnings.filterwarnings(&amp;quot;ignore&amp;quot;)

## 读入数据
os.chdir(&amp;quot;/Users/mac/Desktop/狗熊会/分类model/约会数据集&amp;quot;)
yuehui0 = pd.read_csv(&amp;quot;Speed Dating Data.csv&amp;quot;,encoding=&amp;quot;gbk&amp;quot;)
yuehui0.head()

## 提取变量——是否接受dec、好感度like、吸引力attr
yuehui1 = yuehui0[[&amp;quot;dec&amp;quot;,&amp;quot;like&amp;quot;,&amp;quot;attr&amp;quot;]]
yuehui1.shape

## 删除缺失
yuehui1.dropna(axis = 0, how = &amp;quot;any&amp;quot;, thresh = None, subset = None, inplace = True)
yuehui1.shape
yuehui1.info()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;iid&lt;/th&gt;
      &lt;th&gt;id&lt;/th&gt;
      &lt;th&gt;gender&lt;/th&gt;
      &lt;th&gt;idg&lt;/th&gt;
      &lt;th&gt;condtn&lt;/th&gt;
      &lt;th&gt;wave&lt;/th&gt;
      &lt;th&gt;round&lt;/th&gt;
      &lt;th&gt;position&lt;/th&gt;
      &lt;th&gt;positin1&lt;/th&gt;
      &lt;th&gt;order&lt;/th&gt;
      &lt;th&gt;...&lt;/th&gt;
      &lt;th&gt;attr3_3&lt;/th&gt;
      &lt;th&gt;sinc3_3&lt;/th&gt;
      &lt;th&gt;intel3_3&lt;/th&gt;
      &lt;th&gt;fun3_3&lt;/th&gt;
      &lt;th&gt;amb3_3&lt;/th&gt;
      &lt;th&gt;attr5_3&lt;/th&gt;
      &lt;th&gt;sinc5_3&lt;/th&gt;
      &lt;th&gt;intel5_3&lt;/th&gt;
      &lt;th&gt;fun5_3&lt;/th&gt;
      &lt;th&gt;amb5_3&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;...&lt;/td&gt;
      &lt;td&gt;5.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;...&lt;/td&gt;
      &lt;td&gt;5.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;...&lt;/td&gt;
      &lt;td&gt;5.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;...&lt;/td&gt;
      &lt;td&gt;5.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;...&lt;/td&gt;
      &lt;td&gt;5.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;7.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;5 rows × 195 columns&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;(8378, 3)






(8122, 3)



&amp;lt;class &#39;pandas.core.frame.DataFrame&#39;&amp;gt;
Int64Index: 8122 entries, 0 to 8377
Data columns (total 3 columns):
dec     8122 non-null int64
like    8122 non-null float64
attr    8122 non-null float64
dtypes: float64(2), int64(1)
memory usage: 253.8 KB
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 划分训练和测试
from sklearn.model_selection import train_test_split
x_train,x_test, y_train, y_test = train_test_split(yuehui1[[&amp;quot;like&amp;quot;,&amp;quot;attr&amp;quot;]], yuehui1[&#39;dec&#39;], test_size = 0.25, random_state = 0)
print(&#39;训练集维度: {}, 测试集维度：{} \n&#39;.format(y_train.shape, y_test.shape))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;训练集维度: (6091,), 测试集维度：(2031,) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;sklearn中svm有linearsvc-nusvc和svc三种方法&#34;&gt;Sklearn中SVM有LinearSVC、NuSVC和SVC三种方法&lt;/h1&gt;
&lt;h2 id=&#34;linearsvc&#34;&gt;LinearSVC&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;penalty:正则化参数，L1和L2两种参数可选，仅LinearSVC有。&lt;/li&gt;
&lt;li&gt;loss:损失函数，有‘hinge’和‘squared_hinge’两种可选，前者又称L1损失，后者称为L2损失，默认是是’squared_hinge’，其中hinge是SVM的标准损失，squared_hinge是hinge的平方。&lt;/li&gt;
&lt;li&gt;dual:是否转化为对偶问题求解，默认是True。&lt;/li&gt;
&lt;li&gt;tol:残差收敛条件，默认是0.0001，与LR中的一致。&lt;/li&gt;
&lt;li&gt;C:惩罚系数，用来控制损失函数的惩罚系数，类似于LR中的正则化系数。&lt;/li&gt;
&lt;li&gt;multi_class:负责多分类问题中分类策略制定，有‘ovr’和‘crammer_singer’ 两种参数值可选，默认值是’ovr’，&#39;ovr&#39;的分类原则是将待分类中的某一类当作正类，其他全部归为负类，通过这样求取得到每个类别作为正类时的正确率，取正确率最高的那个类别为正类；‘crammer_singer’ 是直接针对目标函数设置多个参数值，最后进行优化，得到不同类别的参数值大小。&lt;/li&gt;
&lt;li&gt;fit_intercept:是否计算截距，与LR模型中的意思一致。&lt;/li&gt;
&lt;li&gt;class_weight:与其他模型中参数含义一样，也是用来处理不平衡样本数据的，可以直接以字典的形式指定不同类别的权重，也可以使用balanced参数值。&lt;/li&gt;
&lt;li&gt;verbose:是否冗余，默认是False.&lt;/li&gt;
&lt;li&gt;random_state:随机种子的大小。&lt;/li&gt;
&lt;li&gt;max_iter:最大迭代次数，默认是1000。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对象&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;coef_:各特征的系数（重要性）。&lt;/li&gt;
&lt;li&gt;intercept_:截距的大小（常数值）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;nusvc&#34;&gt;NuSVC&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;nu:训练误差部分的上限和支持向量部分的下限，取值在（0，1）之间，默认是0.5&lt;/li&gt;
&lt;li&gt;kernel:核函数，核函数是用来将非线性问题转化为线性问题的一种方法，默认是“rbf”核函数，常用的核函数有以下几种：linear poly rbf sigmod&lt;/li&gt;
&lt;li&gt;degree:当核函数是多项式核函数的时候，用来控制函数的最高次数。（多项式核函数是将低维的输入空间映射到高维的特征空间）&lt;/li&gt;
&lt;li&gt;gamma:核函数系数，默认是“auto”，即特征维度的倒数。&lt;/li&gt;
&lt;li&gt;coef0:核函数常数值(y=kx+b中的b值)，只有‘poly’和‘sigmoid’核函数有，默认值是0。&lt;/li&gt;
&lt;li&gt;max_iter:最大迭代次数，默认值是-1，即没有限制。&lt;/li&gt;
&lt;li&gt;probability:是否使用概率估计，默认是False。&lt;/li&gt;
&lt;li&gt;decision_function_shape:与&#39;multi_class&#39;参数含义类似。&lt;/li&gt;
&lt;li&gt;cache_size:缓冲大小，用来限制计算量大小，默认是200M。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对象&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;support_:以数组的形式返回支持向量的索引。&lt;/li&gt;
&lt;li&gt;support_vectors_:返回支持向量。&lt;/li&gt;
&lt;li&gt;n_support_:每个类别支持向量的个数。&lt;/li&gt;
&lt;li&gt;dual_coef_:支持向量系数。&lt;/li&gt;
&lt;li&gt;coef_:每个特征系数（重要性），只有核函数是LinearSVC的时候可用。&lt;/li&gt;
&lt;li&gt;intercept_:截距值（常数值）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;svc&#34;&gt;SVC&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C:惩罚系数&lt;br&gt;
和NuSVC方法基本一致，唯一区别就是损失函数的度量方式不同&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;统一方法&#34;&gt;统一方法：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;decision_function(X):获取数据集X到分离超平面的距离。&lt;/li&gt;
&lt;li&gt;fit(X, y):在数据集(X,y)上使用SVM模型。&lt;/li&gt;
&lt;li&gt;get_params([deep]):获取模型的参数。&lt;/li&gt;
&lt;li&gt;predict(X):预测数据值X的标签。&lt;/li&gt;
&lt;li&gt;score(X,y):返回给定测试集和对应标签的平均准确率。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;实例高斯核svm&#34;&gt;实例——高斯核SVM&lt;/h1&gt;
&lt;h2 id=&#34;调参技巧c&#34;&gt;调参技巧——C&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C越大，训练样本的准确率越高，泛化能力减低&lt;/li&gt;
&lt;li&gt;减小C，泛化能力强。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;给定超参数值&#34;&gt;给定超参数值&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 加载svm模块
from sklearn import svm
my_svm = svm.SVC(C = 88, kernel=&#39;rbf&#39;)   # 高斯核svm，惩罚系数选择等于1
my_svm.fit(x_train, y_train)   # 调用fit 训练样本

# 查看支持向量
my_svm.support_vectors_    # 支持向量
my_svm.n_support_            # 每一类支持向量的个数(还挺多)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;SVC(C=88, cache_size=200, class_weight=None, coef0=0.0,
  decision_function_shape=&#39;ovr&#39;, degree=3, gamma=&#39;auto&#39;, kernel=&#39;rbf&#39;,
  max_iter=-1, probability=False, random_state=None, shrinking=True,
  tol=0.001, verbose=False)






array([[7., 7.],
       [8., 6.],
       [8., 6.],
       ...,
       [6., 6.],
       [5., 6.],
       [7., 6.]])






array([1512, 1504], dtype=int32)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 预测情况
y_pred = my_svm.predict(x_test)   # 计算预测结果

# 模型测试
print(&#39;训练集上准确率：&#39;+str(round(my_svm.score(x_train, y_train),4)))  # 训练集上准确率
print(&#39;预测集上准确率：&#39;+str(round(my_svm.score(x_test, y_test),4)))    # 预测集上准确率

# 加载混淆矩阵函数
from sklearn.metrics import confusion_matrix
c_m = confusion_matrix(y_test,y_pred)
# 输出混淆矩阵
print(c_m)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;训练集上准确率：0.7611
预测集上准确率：0.7622
[[978 192]
 [291 570]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;超参数自动搜索模块gridsearchcv&#34;&gt;超参数自动搜索模块GridSearchCV&lt;/h2&gt;
&lt;p&gt;系统地遍历多种参数组合，通过交叉验证确定最佳效果参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sklearn.model_selection import GridSearchCV

# 给出交叉验证参数范围
C_range = np.logspace(-2, 8, 12, base=2)   # 给出参数范围，可以用range，也可以用这个对数等比数列确定C，一定大于0！！
param_grid = [{&#39;kernel&#39;: [&#39;rbf&#39;], &#39;C&#39;: C_range}]

# 给出分类器
my_svm1 = svm.SVC(kernel=&#39;rbf&#39;)    # 高斯核SVM

# 自动搜索最优参数
grid_search= GridSearchCV(my_svm1, param_grid, cv = 3, n_jobs = -1)  #3折交叉

# fit
grid_search.fit(x_train,y_train)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;GridSearchCV(cv=3, error_score=&#39;raise&#39;,
       estimator=SVC(C=1.0, cache_size=200, class_weight=None, coef0=0.0,
  decision_function_shape=&#39;ovr&#39;, degree=3, gamma=&#39;auto&#39;, kernel=&#39;rbf&#39;,
  max_iter=-1, probability=False, random_state=None, shrinking=True,
  tol=0.001, verbose=False),
       fit_params=None, iid=True, n_jobs=-1,
       param_grid=[{&#39;kernel&#39;: [&#39;rbf&#39;], &#39;C&#39;: array([2.50000e-01, 4.69465e-01, 8.81591e-01, 1.65551e+00, 3.10881e+00,
       5.83792e+00, 1.09628e+01, 2.05866e+01, 3.86589e+01, 7.25960e+01,
       1.36325e+02, 2.56000e+02])}],
       pre_dispatch=&#39;2*n_jobs&#39;, refit=True, return_train_score=&#39;warn&#39;,
       scoring=None, verbose=0)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 预测情况
y_pred2 = grid_search.predict(x_test)   # 计算预测结果

# 模型测试
print(&#39;训练集上准确率：&#39;+str(round(grid_search.score(x_train, y_train),4)))  # 训练集上准确率
print(&#39;预测集上准确率：&#39;+str(round(grid_search.score(x_test, y_test),4)))    # 预测集上准确率

# 加载混淆矩阵函数
from sklearn.metrics import confusion_matrix
c_m2 = confusion_matrix(y_test,y_pred2)
# 输出混淆矩阵
print(c_m2)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;训练集上准确率：0.7577
预测集上准确率：0.7578
[[1004  166]
 [ 326  535]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;实例lda&#34;&gt;实例——LDA&lt;/h1&gt;
&lt;p&gt;sklearn.discriminant_analysis.LinearDiscriminantAnalysis&lt;/p&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;solver：奇异值分解&amp;quot;svd&amp;quot;（默认）、最小二乘&amp;quot;lsqr&amp;quot;和特征分解&amp;quot;eigen&amp;quot;。一般来说特征非常多的时候推荐使用&amp;quot;svd&amp;quot;，而特征不多的时候推荐使用&amp;quot;eigen&amp;quot;&lt;/li&gt;
&lt;li&gt;shrinkage :正则化参数,默认值是None&lt;/li&gt;
&lt;li&gt;priors:类别权重&lt;/li&gt;
&lt;li&gt;n_components:LDA降维时降到的维度。如果不是用于降维，用默认的None。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 加载和fit
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
lda = LinearDiscriminantAnalysis(solver = &amp;quot;eigen&amp;quot;)
lda.fit(x_train, y_train)   # 调用fit 训练样本

# 预测和展示
y_pred3 = lda.predict(x_test)   # 计算预测结果

# 模型测试
print(&#39;训练集上准确率：&#39;+str(round(lda.score(x_train, y_train),4)))  # 训练集上准确率
print(&#39;预测集上准确率：&#39;+str(round(lda.score(x_test, y_test),4)))    # 预测集上准确率

# 加载混淆矩阵函数
from sklearn.metrics import confusion_matrix
c_m3 = confusion_matrix(y_test,y_pred3)

# 输出混淆矩阵
print(c_m3)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;LinearDiscriminantAnalysis(n_components=None, priors=None, shrinkage=None,
              solver=&#39;eigen&#39;, store_covariance=False, tol=0.0001)



训练集上准确率：0.7519
预测集上准确率：0.7558
[[862 308]
 [188 673]]
&lt;/code&gt;&lt;/pre&gt;
">sklearn——LDA&SVM</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/0920-ACompleteExample/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#sklearn&#34;&gt;sklearn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%AB%98%E8%80%83%E6%95%B0%E6%8D%AE%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92%E5%AE%9E%E4%BE%8B%E5%AE%8C%E6%95%B4&#34;&gt;高考数据——逻辑回归实例（完整）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE&#34;&gt;读入数据&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%84%E7%90%86%E7%BC%BA%E5%A4%B1%E9%87%8D%E5%A4%8D&#34;&gt;处理缺失重复&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%84%E7%90%86str%E5%8F%98%E9%87%8F&#34;&gt;处理str变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%92%E5%88%86%E8%AE%AD%E7%BB%83%E9%9B%86%E5%92%8C%E6%B5%8B%E8%AF%95%E9%9B%86%E7%BB%99%E5%87%BAx%E5%92%8Cy&#34;&gt;划分训练集和测试集，给出X和Y&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A0%87%E5%87%86%E5%8C%96%E8%BF%99%E9%87%8C%E6%9A%82%E6%97%B6%E4%B8%8D%E8%BF%9B%E8%A1%8C&#34;&gt;标准化（这里暂时不进行）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BB%BA%E7%AB%8Blogistic-model&#34;&gt;建立logistic model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%9C&#34;&gt;预测结果&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%AB%98%E8%80%83%E6%95%B0%E6%8D%AE%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92&#34;&gt;高考数据——线性回归&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;sklearn&#34;&gt;sklearn&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;sklearn&lt;/strong&gt; 机器学习（重点）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用train_test_split()——切分训练集、验证集、测试集&lt;/li&gt;
&lt;li&gt;模型初始化（针对模型各种参数的调整都是在这一步）&lt;/li&gt;
&lt;li&gt;调用fit()——训练样本&lt;/li&gt;
&lt;li&gt;调用score()——计算平均准确率。&lt;/li&gt;
&lt;li&gt;结果展示&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;高考数据逻辑回归实例完整&#34;&gt;高考数据——逻辑回归实例（完整）&lt;/h1&gt;
&lt;h2 id=&#34;读入数据&#34;&gt;读入数据&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#j加载
import os
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    

## 分类变量——转化为虚拟变量
os.chdir(&amp;quot;/Users/mac/Desktop/快乐研一/python/data&amp;quot;)
gaokao = pd.read_csv(&amp;quot;高考待预处理.csv&amp;quot;)
gaokao.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;大学名称&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;重点学科&lt;/th&gt;
      &lt;th&gt;博士点&lt;/th&gt;
      &lt;th&gt;分数线&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;复旦大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;30.0&lt;/td&gt;
      &lt;td&gt;178.0&lt;/td&gt;
      &lt;td&gt;687.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;清华大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;37.0&lt;/td&gt;
      &lt;td&gt;253.0&lt;/td&gt;
      &lt;td&gt;686.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;处理缺失重复&#34;&gt;处理缺失重复&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 检查缺失重复问题
gaokao.isnull().sum(axis=0)
gaokao[gaokao.duplicated()]

# 处理缺失重复
gaokao = gaokao.drop_duplicates(subset = [&#39;大学名称&#39;])  # 去重复
gaokao.dropna(axis = 0, how=&#39;any&#39;, thresh = None, subset = None, inplace=True)   # omit na值

# 复查一遍
gaokao.isnull().sum(axis=0)
gaokao[gaokao.duplicated()]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;大学名称    2
类型      2
重点学科    4
博士点     4
分数线     4
dtype: int64
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;大学名称&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;重点学科&lt;/th&gt;
      &lt;th&gt;博士点&lt;/th&gt;
      &lt;th&gt;分数线&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;td&gt;上海交通大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;9.0&lt;/td&gt;
      &lt;td&gt;78.0&lt;/td&gt;
      &lt;td&gt;664.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;24&lt;/th&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;大学名称    0
类型      0
重点学科    0
博士点     0
分数线     0
dtype: int64
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;大学名称&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;重点学科&lt;/th&gt;
      &lt;th&gt;博士点&lt;/th&gt;
      &lt;th&gt;分数线&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;处理str变量&#34;&gt;处理str变量&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 对重点学科和分数线高低做分类
gaokao[&#39;重点学科（分类）&#39;] = pd.cut(gaokao[&#39;重点学科&#39;], 3, labels = [u&amp;quot;LOW&amp;quot;,u&amp;quot;MED&amp;quot;,u&amp;quot;TOP&amp;quot;])   # 直接三等分
gaokao[&#39;分数线（高低）&#39;] = pd.cut(gaokao[&#39;分数线&#39;], 2, labels = [u&amp;quot;低于平均&amp;quot;,u&amp;quot;高于平均&amp;quot;])   # 对分数线做划分二等分

# 转化为哑变量
leixing = pd.get_dummies(gaokao.类型, prefix=&amp;quot;type&amp;quot;)   # 全部生成虚拟变量，列名前面加上type
gaokao = gaokao.join(leixing)   # join进原数据里

fenshu = pd.get_dummies(gaokao[&#39;分数线（高低）&#39;] , prefix=&amp;quot;分数线&amp;quot;) 
gaokao = gaokao.join(fenshu)   # join进原数据里
gaokao.head()

# 查看变量类型
gaokao.dtypes
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;大学名称&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;重点学科&lt;/th&gt;
      &lt;th&gt;博士点&lt;/th&gt;
      &lt;th&gt;分数线&lt;/th&gt;
      &lt;th&gt;重点学科（分类）&lt;/th&gt;
      &lt;th&gt;分数线（高低）&lt;/th&gt;
      &lt;th&gt;type_农业&lt;/th&gt;
      &lt;th&gt;type_医药&lt;/th&gt;
      &lt;th&gt;type_工科&lt;/th&gt;
      &lt;th&gt;type_师范&lt;/th&gt;
      &lt;th&gt;type_林业&lt;/th&gt;
      &lt;th&gt;type_民族&lt;/th&gt;
      &lt;th&gt;type_综合&lt;/th&gt;
      &lt;th&gt;type_财经&lt;/th&gt;
      &lt;th&gt;分数线_低于平均&lt;/th&gt;
      &lt;th&gt;分数线_高于平均&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
      &lt;td&gt;TOP&lt;/td&gt;
      &lt;td&gt;高于平均&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;复旦大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;30.0&lt;/td&gt;
      &lt;td&gt;178.0&lt;/td&gt;
      &lt;td&gt;687.0&lt;/td&gt;
      &lt;td&gt;MED&lt;/td&gt;
      &lt;td&gt;高于平均&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;清华大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;37.0&lt;/td&gt;
      &lt;td&gt;253.0&lt;/td&gt;
      &lt;td&gt;686.0&lt;/td&gt;
      &lt;td&gt;MED&lt;/td&gt;
      &lt;td&gt;高于平均&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;上海交通大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;9.0&lt;/td&gt;
      &lt;td&gt;78.0&lt;/td&gt;
      &lt;td&gt;664.0&lt;/td&gt;
      &lt;td&gt;LOW&lt;/td&gt;
      &lt;td&gt;高于平均&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;南京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;21.0&lt;/td&gt;
      &lt;td&gt;44.0&lt;/td&gt;
      &lt;td&gt;662.0&lt;/td&gt;
      &lt;td&gt;LOW&lt;/td&gt;
      &lt;td&gt;高于平均&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;大学名称          object
类型            object
重点学科         float64
博士点          float64
分数线          float64
重点学科（分类）    category
分数线（高低）     category
type_农业        uint8
type_医药        uint8
type_工科        uint8
type_师范        uint8
type_林业        uint8
type_民族        uint8
type_综合        uint8
type_财经        uint8
分数线_低于平均       uint8
分数线_高于平均       uint8
dtype: object
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;划分训练集和测试集给出x和y&#34;&gt;划分训练集和测试集，给出X和Y&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 载入函数train_test_split划分训练和测试集
from sklearn.model_selection import train_test_split
# 划分训练集和测试集
x_train,x_test, y_train, y_test = train_test_split(gaokao.iloc[:,[2,3,7,8,9,10]], gaokao[&#39;分数线_高于平均&#39;], test_size = 0.33, random_state = 0)
# 输出样本量
print(&#39;训练集维度: {}, 测试集维度：{} \n&#39;.format(y_train.shape, y_test.shape))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;训练集维度: (85,), 测试集维度：(43,) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;标准化这里暂时不进行&#34;&gt;标准化（这里暂时不进行）&lt;/h2&gt;
&lt;h2 id=&#34;建立logistic-model&#34;&gt;建立logistic model&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;multi_class:分类方式选择参数，有&amp;quot;ovr(默认)&amp;quot;和&amp;quot;multinomial&amp;quot;两个值可选择，在二元逻辑回归中无区别&lt;/li&gt;
&lt;li&gt;cv:几折交叉验证&lt;/li&gt;
&lt;li&gt;solver:优化算法选择参数，当penalty为&amp;quot;l1&amp;quot;时，参数只能是&amp;quot;liblinear(坐标轴下降法)&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;quot;lbfgs&amp;quot;和&amp;quot;cg&amp;quot;都是关于目标函数的二阶泰勒展开&lt;/li&gt;
&lt;li&gt;当penalty为&amp;quot;l2&amp;quot;时，参数可以是&amp;quot;lbfgs(拟牛顿法)&amp;quot;,&amp;quot;newton_cg(牛顿法变种)&amp;quot;,&amp;quot;seg(minibactch随机平均梯度下降)&amp;quot;&lt;/li&gt;
&lt;li&gt;维度&amp;lt;10000时，选择&amp;quot;lbfgs&amp;quot;法，维度&amp;gt;10000时，选择&amp;quot;cs&amp;quot;法比较好，显卡计算的时候，lbfgs&amp;quot;和&amp;quot;cs&amp;quot;都比&amp;quot;seg&amp;quot;快&lt;/li&gt;
&lt;li&gt;penalty:正则化选择参数，用于解决过拟合，可选&amp;quot;l1&amp;quot;,&amp;quot;l2&amp;quot;&lt;/li&gt;
&lt;li&gt;tol:当目标函数下降到该值是就停止，叫：容忍度，防止计算的过多&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#构建并训练模型
from sklearn.linear_model import LogisticRegression  #加载函数
logreg = LogisticRegression(penalty=&amp;quot;l2&amp;quot;)  # 模型初始化
logreg.fit(x_train, y_train)   # 调用fit 训练样本

# 查看回归系数
x_train.columns.values
np.around(logreg.coef_,2)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;LogisticRegression(C=1.0, class_weight=None, dual=False, fit_intercept=True,
          intercept_scaling=1, max_iter=100, multi_class=&#39;ovr&#39;, n_jobs=1,
          penalty=&#39;l2&#39;, random_state=None, solver=&#39;liblinear&#39;, tol=0.0001,
          verbose=0, warm_start=False)






array([&#39;重点学科&#39;, &#39;博士点&#39;, &#39;type_农业&#39;, &#39;type_医药&#39;, &#39;type_工科&#39;, &#39;type_师范&#39;],
      dtype=object)






array([[-0.08,  0.34,  0.07, -0.59, -0.25, -0.47]])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;预测结果&#34;&gt;预测结果&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;y_pred = logreg.predict(x_test)   # 计算预测结果

# 模型测试
print(logreg.score(x_train, y_train))   # 训练集上准确率
print(logreg.score(x_test, y_test))     # 预测集上准确率

# 加载混淆矩阵函数
from sklearn.metrics import confusion_matrix
c_m = confusion_matrix(y_test,y_pred)
# 输出混淆矩阵
print(c_m)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0.9529411764705882
0.9534883720930233
[[15  2]
 [ 0 26]]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# ROC曲线
import matplotlib.pyplot as plt   # 画图
from sklearn.metrics import roc_auc_score,roc_curve  #计算auc

# 提取预测概率值
y_pred2=logreg.predict_proba(x_test)    # 预测出的概率值
y_0=list(y_pred2[:,1])    #取第二列数据，转化我list

# 计算ROC曲线的横纵轴fpr/tpr真假正例率、thresholds分割门槛
fpr,tpr,thresholds=roc_curve(y_test,y_0)  #计算fpr,tpr,thresholds
auc = roc_auc_score(y_test,y_0) #计算auc
print(&#39;auc值为：&#39;,str(auc))

# 画曲线图
plt.figure()
plt.plot(fpr,tpr)
plt.title(&#39;$ROC—curve$&#39;)
plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;auc值为： 0.9683257918552036





&amp;lt;Figure size 432x288 with 0 Axes&amp;gt;






[&amp;lt;matplotlib.lines.Line2D at 0x1a244dd470&amp;gt;]






Text(0.5,1,&#39;$ROC—curve$&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;output_13_4.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;高考数据线性回归&#34;&gt;高考数据——线性回归&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 划分训练集和测试集，给出X和Y
# 划分训练集和测试集
gaokao.columns
x_train,x_test, y_train, y_test = train_test_split(gaokao.iloc[:,[2,3,7,8,9,10]], gaokao[&#39;分数线&#39;], test_size = 0.33, random_state = 0)

# 模型
from sklearn import linear_model
linear_reg = linear_model.LinearRegression()
# fit训练集拟合
linear_reg.fit(x_train, y_train)   # 调用fit 训练样本

# 查看回归系数
x_train.columns.values
np.around(linear_reg.coef_,2)

# 查看R方
from sklearn.metrics import mean_squared_error , r2_score
print(&#39;R2: %.3f&#39; % r2_score(y_test,linear_reg.predict(x_test)))

# 可视化
# 设置字体
import matplotlib.font_manager as mfm
font_path = r&amp;quot;/Users/mac/Library/Fonts/字体管家方萌简（非商业使用）v1.1.ttf&amp;quot;
prop = mfm.FontProperties(fname = font_path)
# 画布
fig = plt.figure(figsize=(8,6))   # 创建一张18*6的画布
ax1 = fig.add_subplot(111)        # 创建子图
# 画图
ax1.set_xlabel(&#39;真实值&#39;, fontproperties=prop, fontsize=25)
ax1.set_ylabel(&#39;预测值&#39;, fontproperties=prop, fontsize=25)
ax1.scatter(y_test ,linear_reg.predict(x_test) ,color=&#39;blue&#39;)
# show
plt.show()
plt.close()  # plt.show()结束后仍然保存在内存中, 切记关闭！！！在jupyter理！！！
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Index([&#39;大学名称&#39;, &#39;类型&#39;, &#39;重点学科&#39;, &#39;博士点&#39;, &#39;分数线&#39;, &#39;重点学科（分类）&#39;, &#39;分数线（高低）&#39;, &#39;type_农业&#39;,
       &#39;type_医药&#39;, &#39;type_工科&#39;, &#39;type_师范&#39;, &#39;type_林业&#39;, &#39;type_民族&#39;, &#39;type_综合&#39;,
       &#39;type_财经&#39;, &#39;分数线_低于平均&#39;, &#39;分数线_高于平均&#39;],
      dtype=&#39;object&#39;)






LinearRegression(copy_X=True, fit_intercept=True, n_jobs=1, normalize=False)






array([&#39;重点学科&#39;, &#39;博士点&#39;, &#39;type_农业&#39;, &#39;type_医药&#39;, &#39;type_工科&#39;, &#39;type_师范&#39;],
      dtype=object)






array([  2.06,   0.47,  23.7 , -23.  ,  13.  ,  28.82])



R2: 0.447





Text(0.5,0,&#39;真实值&#39;)






Text(0,0.5,&#39;预测值&#39;)






&amp;lt;matplotlib.collections.PathCollection at 0x1a257a4fd0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;output_15_8.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
">数据分析实例——高考数据</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py0929-0930/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%9B%9E%E9%A1%BE%E7%BB%83%E4%B9%A0%E9%A2%98&#34;&gt;基本结构回顾练习题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%80%92%E5%BD%92&#34;&gt;递归&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A6%81%E7%82%B9&#34;&gt;要点：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%80%92%E5%BD%92%E4%BD%9C%E5%9B%BE&#34;&gt;递归作图：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98&#34;&gt;经典问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%83%E4%B9%A0%E9%A2%98&#34;&gt;练习题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E5%92%8C%E8%B4%AA%E5%BF%83%E7%AD%96%E7%95%A5&#34;&gt;优化问题和贪心策略&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;基本结构回顾练习题&#34;&gt;基本结构回顾练习题&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;实现一个MyQueue类，该类用两个栈来实现一个队列。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;queue = new MyQueue();
queue.push(1);
queue.push(2);
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false
你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size 和 is empty 操作是合法的。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用队列实现，给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 1.用两个栈实现队列
class myQueue:
    def __init__(self):
        self.items = []
        self.tmp = []
    
    def isEmpty(self):
        return self.items == []
    
    def enqueue(self, item):    # 只能从队尾加入
        return self.items.append(item)
    
    def dequeue(self):          # 只能从队首出去
        for i in range(len(self.items)):
            self.tmp.append(self.items.pop())
        self.items = self.tmp
        return self.items.pop() 
    
## 测试
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;   
duilie = myQueue()
duilie.items = [1,2,3]
duilie.isEmpty()
duilie.enqueue(2)
duilie.items
duilie.dequeue()
duilie.items
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;False






[1, 2, 3, 2]






1






[2, 3, 2]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 2.设计一个栈支持min函数
class myStack:
    def __init__(self):
        self.items = []
        self.min_item = []

    def push(self, item):
        self.items.append(item)
        if self.min_item==[] or self.min_item[-1]&amp;gt;=item:
            self.min_item.append(item)
        
    def pop(self):
        if self.min_item[-1]==self.items.pop():
            self.min_item.pop()
        
            
    def getMin(self):
        return self.min_item[-1]

## 测试
zhan = myStack()
zhan.push(2.2)
zhan.items,zhan.min_item
zhan.push(3.4)
zhan.items,zhan.min_item
zhan.push(1.8)
zhan.items,zhan.min_item
zhan.getMin()
zhan.pop()
zhan.items,zhan.min_item,zhan.getMin()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;([2.2], [2.2])






([2.2, 3.4], [2.2])






([2.2, 3.4, 1.8], [2.2, 1.8])






1.8






([2.2, 3.4], [2.2], 2.2)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 3.滑动窗口的最大值，输入num和窗宽k，用队列实现
def maxK(k,nums):
    maxnum = []
    while len(nums)&amp;gt;=k:
        maxnum.append(nums[0])
        for i in range(1,k):
            if maxnum[-1] &amp;lt; nums[i]:
                maxnum.pop()
                maxnum.append(nums[i])
        nums.pop(0)
    return maxnum

# 测试
maxK(k=5, nums = [1, 3, -1, 3.2, -5, 4, 3, 6, 7.5, 2, 6.8, 9])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[3.2, 4, 4, 6, 7.5, 7.5, 7.5, 9]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;递归&#34;&gt;递归&lt;/h1&gt;
&lt;h2 id=&#34;要点&#34;&gt;要点：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;把问题分解为更小规模相同问题&lt;/li&gt;
&lt;li&gt;调用自身&lt;/li&gt;
&lt;li&gt;要有一个基本结束条件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#### 递归理解小故事：
def tell_story(i):
    if i &amp;gt; 0:      # 结束条件
        i = i-1 
        print(&#39;从前有座山，山里有座庙，庙里有个老和尚，他在讲：&#39;)
        return tell_story(i)   # 调用自身

# 测试
tell_story(3)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;从前有座山，山里有座庙，庙里有个老和尚，他在讲：
从前有座山，山里有座庙，庙里有个老和尚，他在讲：
从前有座山，山里有座庙，庙里有个老和尚，他在讲：
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#### list累加
num=[1,3,5,7,9]
def listSum(num):
    if len(num)==1:   # 基本结束条件
        return num[0]
    else:
        return num[0]+listSum(num[1:])   # 第一次：a0+a1，第二次a0+a1+a2，第三次...直到len=1

# 测试
listSum(num)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;25
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#### 任意进制转化
def toStr(n, base):
    converString = &amp;quot;0123456789ABCDEF&amp;quot;  # 最大为16进制
    if n &amp;lt; base:
        return converString[n]
    else:
        return toStr(n//base,base)+converString[n%base]

# 测试
toStr(35,2)
toStr(192345,16)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&#39;100011&#39;






&#39;2EF59&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;递归调用的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次调用时，现场数据压入系统调用栈（栈帧）&lt;/li&gt;
&lt;li&gt;返回时，从栈顶获得返回地址，弹出栈帧，按地址返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;递归作图&#34;&gt;递归作图：&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 画一个五角星
import turtle
t2 = turtle.Turtle()
t2.pencolor(&#39;red&#39;)
for i in range(6):
    t2.forward(100)
    t2.right(144)
turtle.done()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#### 画一个螺旋
import turtle
t3 = turtle.Turtle()

def drawS(t,linelen):
    if linelen&amp;gt;0:
        t.forward(linelen)
        t.right(90)
        drawS(t,linelen-5)

drawS(t3,100)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#### 画一个二叉树
import turtle

def plotTree(t,branch):
    if branch&amp;gt;5:
        t.forward(branch)
        t.right(20)
        plotTree(t,branch-15)
        t.left(40)
        plotTree(t,branch-15)
        t.right(20)
        t.backward(branch)
    
t4 = turtle.Turtle()
t4.left(90)
t4.backward(70)
plotTree(t4,80)
turtle.done()

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from IPython.display import Image
Image(filename = &#39;Desktop/快乐研一/python/ercha.jpg&#39;, width=300, height=300)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;output_12_0.jpeg&#34; alt=&#34;jpeg&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;经典问题&#34;&gt;经典问题&lt;/h2&gt;
&lt;p&gt;1——汉诺塔&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 三柱子汉诺塔实现
def moveTower(n,fromT,withT,toT):
    if n&amp;gt;=1:
        moveTower(n-1,fromT,toT,withT)
        print(f&amp;quot;moving disk{n} from {fromT} to {toT}&amp;quot;)
        moveTower(n-1,withT,fromT, toT)

moveTower(3,&amp;quot;#1&amp;quot;,&amp;quot;#2&amp;quot;,&amp;quot;#3&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;moving disk1 from #1 to #3
moving disk2 from #1 to #2
moving disk1 from #3 to #2
moving disk3 from #1 to #3
moving disk1 from #2 to #1
moving disk2 from #2 to #3
moving disk1 from #1 to #3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2——探索迷宫&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;### 1.考虑用矩阵实现一个迷宫
### 2.墙壁 + 通道  
### 3.避免死循环，记录走过的路径，避开
### 4.结束条件：①碰到墙②碰到走过的③碰到边界
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;练习题&#34;&gt;练习题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;斐波那契数列&lt;/li&gt;
&lt;li&gt;青蛙跳台阶&lt;/li&gt;
&lt;li&gt;跳水台问题&lt;/li&gt;
&lt;li&gt;井字游戏（稍难）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 1.斐波那契数列
## 从0和1开始，用前面两项相加得到当前项
def fib(n):   # 第几个数
    if n==0: return 0
    if n==1: return 1
    if n&amp;gt;1:
        return fib(n-1)+fib(n-2)      
#测试
for i in range(10): print(fib(i))
    
    
## 2.青蛙跳台阶问题
## 青蛙一次可以跳上一级台阶，也可以跳两级，问跳上n级台阶总共有几种跳法
def numWays(n):
    if n==1:return(1)
    if n==2:return(2)
    if n-2&amp;gt;=1:return(numWays(n-1)+numWays(n-2))
# 测试
numWays(7)


## 3.跳水板
## 正好使用n块木板（有两种长度）生成所有可能长度：
def boardlen(n,short,longer):
    length = []
    for i in range(n+1):
         length.append((n-i)*short+i*longer)
    return length
# 测试：
boardlen(4,2,3)


## 4.递归乘法——正整数相乘
# 如果写成循环非常简单
A=1;B=10;tmp=0
for i in range(A):
    tmp = tmp+B
print(tmp)
# 如果写成递归呢
def multiply(A:int,B:int) -&amp;gt; int:
    if A==1: 
        return B
    if A&amp;gt;=2: 
        return multiply(A-1,B)+B
## 测试
multiply(3, 9)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0
1
1
2
3
5
8
13
21
34





21






[8, 9, 10, 11, 12]






10






27
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;井字游戏（递归）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import random
## 井字游戏（递归）
# 结束条件：1.放满了，2.三个相同字符填充行、列、对角线
# 用递归列出所有可能的结束情况，每次递归下一次
def wins(jin):
    ifwin = False
    if jin[0]==jin[4]==jin[8]!=0 or jin[2]==jin[4]==jin[6]!=0: ifwin=True   # 对角
    if jin[0]==jin[1]==jin[2]!=0 or jin[3]==jin[4]==jin[5]!=0 or jin[6]==jin[7]==jin[8]!=0: ifwin = True  # 行
    if jin[0]==jin[3]==jin[6]!=0 or jin[1]==jin[4]==jin[7]!=0 or jin[2]==jin[5]==jin[8]!=0: ifwin=True   # 列
    return ifwin

def xiaqi(jin,jin_num):   # 每一次下棋
    ## 停止条件
    if len(jin_num)&amp;gt;=1 and (not wins(jin)):
        
    ## 递归调用
        locat = random.choice(jin_num)   # 从空位中选出一个位置
        ## 轮到谁下棋
        if len(jin_num)%2==0:
            jin[locat]=&amp;quot;乙&amp;quot;
        else:jin[locat]=&amp;quot;甲&amp;quot;
        jin_num.remove(locat)
        print(&amp;quot;第{}次：\n{}\n{}\n{}&amp;quot;.format(len(jin)-len(jin_num),jin[0:3],jin[3:6],jin[6:9]))
        return xiaqi(jin, jin_num)   # 下完之后的棋盘和空位继续下棋

    ##  停止之后，判断局势
    if len(jin_num)==0 and (not wins(jin)): print(&amp;quot;平局&amp;quot;)
    if wins(jin): 
        if len(jin_num)%2==0:
            print(&amp;quot;甲 win!&amp;quot;)
        else:
            print(&amp;quot;乙 win!&amp;quot;)
        
xiaqi(jin = [0]*9, jin_num = list(range(0,9)))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;第1次：
[0, 0, 0]
[&#39;甲&#39;, 0, 0]
[0, 0, 0]
第2次：
[0, 0, 0]
[&#39;甲&#39;, 0, 0]
[0, &#39;乙&#39;, 0]
第3次：
[0, 0, 0]
[&#39;甲&#39;, 0, &#39;甲&#39;]
[0, &#39;乙&#39;, 0]
第4次：
[0, &#39;乙&#39;, 0]
[&#39;甲&#39;, 0, &#39;甲&#39;]
[0, &#39;乙&#39;, 0]
第5次：
[0, &#39;乙&#39;, 0]
[&#39;甲&#39;, &#39;甲&#39;, &#39;甲&#39;]
[0, &#39;乙&#39;, 0]
甲 win!
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;优化问题和贪心策略&#34;&gt;优化问题和贪心策略&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 硬币找零问题
### 一共有1分，5分，10分，25分四种硬币，寻找兑换硬币最少数量
def coins(coinValue, change):  #输入硬币体系，和需要找零的金额
    min_coins = change   # 最大是change次
    if change in coinValue: min_coins = 1
    else:
        for i in range(len(coinValue)):
            if change &amp;gt; coinValue[i]:
                tmp = coins(coinValue, change - coinValue[i])+1   # 如果先兑换一个一分的
                if tmp &amp;lt; min_coins:
                    min_coins = tmp
    return min_coins

coins([1,5,10,25],53)    
# 超级慢，重复计算太多 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 改进方法
def newcoin(coinValue,change,mychange,mymin_coin):
    min_coins = change
    if change in coinValue:
        min_coins=1
    elif change in mychange:
        return mymin_coin[mychange.index(change)]
    else:
        for i in range(len(coinValue)):
            if change &amp;gt;= coinValue[i]:
                tmp = newcoin(coinValue, change-coinValue[i], mychange, mymin_coin)+1
                if tmp &amp;lt; min_coins:
                    min_coins = tmp
                    mychange.append(change-coinValue[i])
                    mymin_coin.append(tmp)
    return min_coins

## 测试
newcoin([1,5,10,25],53,[],[])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;5
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 博物馆盗窃问题
### 假设已经拿了k件，拿第k-1件
### 1.如果前k件的重量和20公斤差值小于2——停止
### 从所有能拿的东西里，选一件拿走-》递归，价值=前k件价值最大值+这一件的价值，在对比计算价值最大值
def max_value(currentkg, maxkg,currentvalue,itemkg,itemvalue):
    maxvalues = 0
    if currentkg+min(itemkg) &amp;gt; maxkg: 
        currenkg = min(itemkg)
        maxvalues = itemvalue[itemkg.index(min(itemkg))]
    else:
        for i in range(len(itemkg)):
            if currentkg + itemkg[i] &amp;lt;= maxkg:
                currentkg, currentvalue = max_value(currentkg+itemkg[i], maxkg, currentvalue,itemkg,itemvalue)
                tmp = currentvalue+itemvalue[i]
                if tmp &amp;gt;= maxvalues:
                    maxvalues = tmp
    return currentkg, maxvalues

# 测试
max_value(0,12,0,[2,4,6],[8,20,32])
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(12, 56)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 分发糖果，有 N 个孩子站成了一条直线
# 每个孩子至少分配到 1 个糖果。
# 相邻的孩子中，评分高的孩子必须获得更多的糖果高
# 老师至少准备多少糖果
# 最少糖果=上一个最少糖果+-1，
def min_candy(grade, number, candy, current_sum):
    if number==1:
        candy=1
        current_sum=1
    else:
        candy,current_sum = min_candy(grade, number-1, candy, current_sum)
        if grade[number-1] &amp;gt; grade[number-2]:
            candy = candy+1
            current_sum = current_sum+candy
        if grade[number-1]==grade[number-2]:
            current_sum = current_sum+candy
        if grade[number-1]&amp;lt;grade[number-2]:
            if candy==1:
                current_sum = current_sum+2
                candy = 1
            else:
                candy = 1
                current_sum = current_sum+candy
    return candy,current_sum
    
print(&amp;quot;总糖果数{}&amp;quot;.format(min_candy([10,20,30,30,20,10,20,40,50,30,10,20],12,0,0)[1]))
1+2+3+3+2+1+2+3+4+2+1+2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;总糖果数26





26
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
&lt;/code&gt;&lt;/pre&gt;
">递归问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/py0919/"" data-c="
          &lt;h1 id=&#34;dataframe&#34;&gt;Dataframe&lt;/h1&gt;
&lt;h2 id=&#34;增减列-改列名&#34;&gt;增减列、改列名&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;df = df.drop(&#39;列&#39;, axis = 1)     删除某列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;df = df.join(x)  cbind列在最后&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;df[&#39;新列名&#39;] = 一个向量，创建新的一列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;df.columns  # 查看变量名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;df.columns = [&#39;A&#39;,&#39;B&#39;,...] ，把完整新列名赋值过去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;df.rename(columns={&#39;a&#39;:&#39;A&#39;}) ，只修改一个列名&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    

## 分类变量——转化为虚拟变量
import os
import pandas as pd
os.chdir(&amp;quot;/Users/mac/Desktop/快乐研一/python/data&amp;quot;)
gaokao = pd.read_csv(&amp;quot;高考_numpy专用.csv&amp;quot;)
gaokao.shape
boshi = gaokao[&#39;博士点&#39;]

## 列的删除&amp;amp;新增
gaokao = gaokao.drop(&#39;博士点&#39;, axis = 1)  # 删除一列
gaokao.shape
gaokao = gaokao.join(boshi)    # cbind一列
#gaokao[&#39;博士+1&#39;] = boshi+1    # 新增一列
gaokao.shape
gaokao.head()

# 列名处理
gaokao.columns  # 查看变量名
gaokao = gaokao.rename(columns = {&#39;大学名称&#39;:&amp;quot;大学名&amp;quot;})
gaokao.head()

#  预处理
gaokao = gaokao.drop_duplicates(subset = [&#39;大学名&#39;])  # 去重复
gaokao.dropna(axis=0, how=&#39;any&#39;, thresh = None, subset = None, inplace=True)   # omit na值
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(98, 5)






(98, 4)






(98, 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;大学名称&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;重点学科&lt;/th&gt;
      &lt;th&gt;分数线&lt;/th&gt;
      &lt;th&gt;博士点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;复旦大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;30.0&lt;/td&gt;
      &lt;td&gt;687.0&lt;/td&gt;
      &lt;td&gt;178.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;清华大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;37.0&lt;/td&gt;
      &lt;td&gt;686.0&lt;/td&gt;
      &lt;td&gt;253.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;Index([&#39;大学名称&#39;, &#39;类型&#39;, &#39;重点学科&#39;, &#39;分数线&#39;, &#39;博士点&#39;], dtype=&#39;object&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;大学名&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;重点学科&lt;/th&gt;
      &lt;th&gt;分数线&lt;/th&gt;
      &lt;th&gt;博士点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;复旦大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;30.0&lt;/td&gt;
      &lt;td&gt;687.0&lt;/td&gt;
      &lt;td&gt;178.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;清华大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;37.0&lt;/td&gt;
      &lt;td&gt;686.0&lt;/td&gt;
      &lt;td&gt;253.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;单列运算&#34;&gt;单列运算&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;方法1：可以用自定义函数：df[&#39;col&#39;].map(FUNCTION)&lt;/li&gt;
&lt;li&gt;方法2：更常用的基本运算！numpy中函数: np.xxx(df[&#39;列名&#39;])&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意！np.mean(df,0)0表示按列计算，1表示按列计算&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 基本统计量
import numpy as np
gaokao.describe()
#np.cumsum(gaokao[&#39;重点学科&#39;])   # 列和
#np.var(gaokao)                        # 自动按列计算——variance
np.mean(gaokao,0)                    #  按列计算取0，按行计算取1
#np.log(gaokao[&#39;分数线&#39;]+1)         # 对于一列取对数
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;重点学科&lt;/th&gt;
      &lt;th&gt;分数线&lt;/th&gt;
      &lt;th&gt;博士点&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;count&lt;/th&gt;
      &lt;td&gt;91.000000&lt;/td&gt;
      &lt;td&gt;91.000000&lt;/td&gt;
      &lt;td&gt;91.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;mean&lt;/th&gt;
      &lt;td&gt;12.263736&lt;/td&gt;
      &lt;td&gt;596.000000&lt;/td&gt;
      &lt;td&gt;72.274725&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;std&lt;/th&gt;
      &lt;td&gt;11.896624&lt;/td&gt;
      &lt;td&gt;36.016354&lt;/td&gt;
      &lt;td&gt;68.272992&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;min&lt;/th&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;530.000000&lt;/td&gt;
      &lt;td&gt;4.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;25%&lt;/th&gt;
      &lt;td&gt;4.000000&lt;/td&gt;
      &lt;td&gt;570.000000&lt;/td&gt;
      &lt;td&gt;20.500000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;50%&lt;/th&gt;
      &lt;td&gt;9.000000&lt;/td&gt;
      &lt;td&gt;589.000000&lt;/td&gt;
      &lt;td&gt;45.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;75%&lt;/th&gt;
      &lt;td&gt;16.500000&lt;/td&gt;
      &lt;td&gt;613.000000&lt;/td&gt;
      &lt;td&gt;108.500000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;max&lt;/th&gt;
      &lt;td&gt;81.000000&lt;/td&gt;
      &lt;td&gt;694.000000&lt;/td&gt;
      &lt;td&gt;283.000000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;大学名       0.000000
类型        0.043956
重点学科     12.263736
分数线     596.000000
博士点      72.274725
dtype: float64
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;大小排序&#34;&gt;大小排序&lt;/h2&gt;
&lt;p&gt;df.sort_values(by=&amp;quot;XXXX&amp;quot; , ascending=False)  默认由大到小&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;gaokao.sort_values(by = &amp;quot;分数线&amp;quot;, ascending = False).iloc[0:5, [0,3]]
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;大学名&lt;/th&gt;
      &lt;th&gt;分数线&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;复旦大学&lt;/td&gt;
      &lt;td&gt;687.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;清华大学&lt;/td&gt;
      &lt;td&gt;686.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;上海交通大学&lt;/td&gt;
      &lt;td&gt;664.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;南京大学&lt;/td&gt;
      &lt;td&gt;662.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h1 id=&#34;分类变量处理&#34;&gt;分类变量处理&lt;/h1&gt;
&lt;h2 id=&#34;table&#34;&gt;table&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;pd.unique(分类变量) 查看一共有哪些类型&lt;/li&gt;
&lt;li&gt;pd.value_counts(分类变量)查看各类型数量&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pd.unique(gaokao[&amp;quot;类型&amp;quot;])     # 查看一共有哪些类型
pd.value_counts(gaokao[&amp;quot;类型&amp;quot;])   # 查看各类型数量
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;array([&#39;综合&#39;, &#39;师范&#39;, &#39;工科&#39;, &#39;医药&#39;, &#39;农业&#39;, &#39;民族&#39;, &#39;林业&#39;], dtype=object)






工科    41
综合    30
师范    10
农业     5
林业     2
医药     2
民族     1
Name: 类型, dtype: int64
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;分组统计&#34;&gt;分组统计&lt;/h2&gt;
&lt;p&gt;groupby+agg，可以再加上sort_values做排序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 按照某分类变量——分组计算
gaokao.groupby(by = &#39;类型&#39;).agg({&#39;分数线&#39;: &amp;quot;mean&amp;quot;}).sort_values
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;bound method DataFrame.sort_values of            分数线
类型            
农业  577.400000
医药  594.000000
工科  590.487805
师范  578.700000
林业  591.000000
民族  612.000000
综合  612.333333&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;连续变量分组&#34;&gt;连续变量分组&lt;/h2&gt;
&lt;p&gt;pd.cut(xxx, k/bins，labels = xxx)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接给数字，做等分&lt;/li&gt;
&lt;li&gt;或者自己设定bins&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fenwei = gaokao[&#39;重点学科&#39;].quantile(np.arange(0, 1.1, 0.25))   # 计算分位数
fenwei
bins = list(fenwei)   # 把分位数作为分割处
gaokao[&#39;重点学科（分类）&#39;] = pd.cut(gaokao[&#39;重点学科&#39;], bins, labels = [u&amp;quot;四流&amp;quot;,u&amp;quot;三流&amp;quot;,u&amp;quot;二流&amp;quot;,u&amp;quot;一流&amp;quot;])    # 按照指定bins划分
gaokao.head()
gaokao[&#39;重点学科（分类）&#39;] = pd.cut(gaokao[&#39;重点学科&#39;], 3, labels = [u&amp;quot;LOW&amp;quot;,u&amp;quot;MED&amp;quot;,u&amp;quot;TOP&amp;quot;])   # 直接三等分
gaokao[&#39;分数线高低&#39;] = pd.cut(gaokao[&#39;分数线&#39;], 2, labels = [u&amp;quot;低于平均&amp;quot;,u&amp;quot;高于平均&amp;quot;])   # 对分数线做划分二等分
gaokao.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;0.00     0.0
0.25     4.0
0.50     9.0
0.75    16.5
1.00    81.0
Name: 重点学科, dtype: float64
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;大学名&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;重点学科&lt;/th&gt;
      &lt;th&gt;分数线&lt;/th&gt;
      &lt;th&gt;博士点&lt;/th&gt;
      &lt;th&gt;重点学科（分类）&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
      &lt;td&gt;四流&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;复旦大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;30.0&lt;/td&gt;
      &lt;td&gt;687.0&lt;/td&gt;
      &lt;td&gt;178.0&lt;/td&gt;
      &lt;td&gt;四流&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;清华大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;37.0&lt;/td&gt;
      &lt;td&gt;686.0&lt;/td&gt;
      &lt;td&gt;253.0&lt;/td&gt;
      &lt;td&gt;四流&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;上海交通大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;9.0&lt;/td&gt;
      &lt;td&gt;664.0&lt;/td&gt;
      &lt;td&gt;78.0&lt;/td&gt;
      &lt;td&gt;二流&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;南京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;21.0&lt;/td&gt;
      &lt;td&gt;662.0&lt;/td&gt;
      &lt;td&gt;44.0&lt;/td&gt;
      &lt;td&gt;四流&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;大学名&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;重点学科&lt;/th&gt;
      &lt;th&gt;分数线&lt;/th&gt;
      &lt;th&gt;博士点&lt;/th&gt;
      &lt;th&gt;重点学科（分类）&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
      &lt;td&gt;LOW&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;复旦大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;30.0&lt;/td&gt;
      &lt;td&gt;687.0&lt;/td&gt;
      &lt;td&gt;178.0&lt;/td&gt;
      &lt;td&gt;MED&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;清华大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;37.0&lt;/td&gt;
      &lt;td&gt;686.0&lt;/td&gt;
      &lt;td&gt;253.0&lt;/td&gt;
      &lt;td&gt;MED&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;上海交通大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;9.0&lt;/td&gt;
      &lt;td&gt;664.0&lt;/td&gt;
      &lt;td&gt;78.0&lt;/td&gt;
      &lt;td&gt;TOP&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;南京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;21.0&lt;/td&gt;
      &lt;td&gt;662.0&lt;/td&gt;
      &lt;td&gt;44.0&lt;/td&gt;
      &lt;td&gt;TOP&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;虚拟变量&#34;&gt;虚拟变量&lt;/h2&gt;
&lt;p&gt;pd.get_dummies(分类变量, prefix=&amp;quot;新列名前缀&amp;quot;)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;leixing = pd.get_dummies(gaokao.类型, prefix=&amp;quot;type&amp;quot;)   # 全部生成虚拟变量，列名前面加上type
gaokao = gaokao.join(leixing)   # join进原数据里
gaokao.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;大学名&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;重点学科&lt;/th&gt;
      &lt;th&gt;分数线&lt;/th&gt;
      &lt;th&gt;博士点&lt;/th&gt;
      &lt;th&gt;重点学科（分类）&lt;/th&gt;
      &lt;th&gt;type_农业&lt;/th&gt;
      &lt;th&gt;type_医药&lt;/th&gt;
      &lt;th&gt;type_工科&lt;/th&gt;
      &lt;th&gt;type_师范&lt;/th&gt;
      &lt;th&gt;type_林业&lt;/th&gt;
      &lt;th&gt;type_民族&lt;/th&gt;
      &lt;th&gt;type_综合&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
      &lt;td&gt;LOW&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;复旦大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;30.0&lt;/td&gt;
      &lt;td&gt;687.0&lt;/td&gt;
      &lt;td&gt;178.0&lt;/td&gt;
      &lt;td&gt;MED&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;清华大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;37.0&lt;/td&gt;
      &lt;td&gt;686.0&lt;/td&gt;
      &lt;td&gt;253.0&lt;/td&gt;
      &lt;td&gt;MED&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;上海交通大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;9.0&lt;/td&gt;
      &lt;td&gt;664.0&lt;/td&gt;
      &lt;td&gt;78.0&lt;/td&gt;
      &lt;td&gt;TOP&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;南京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;21.0&lt;/td&gt;
      &lt;td&gt;662.0&lt;/td&gt;
      &lt;td&gt;44.0&lt;/td&gt;
      &lt;td&gt;TOP&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h1 id=&#34;sklearn&#34;&gt;sklearn&lt;/h1&gt;
&lt;p&gt;1.&lt;strong&gt;Statsmodels&lt;/strong&gt;（了解）&lt;/p&gt;
&lt;p&gt;连续变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;√处理：异常值问题&lt;/li&gt;
&lt;li&gt;√描述：相关系数图&lt;/li&gt;
&lt;li&gt;√建模Statsmodels，回归&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分类变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;√处理：哑变量处理 pandas.get_dummies&lt;/li&gt;
&lt;li&gt;√描述：箱线图、条形图&lt;/li&gt;
&lt;li&gt;√建模：方差分析与回归系数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回归检验：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;√回归拟合图、检验图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.&lt;strong&gt;sklearn&lt;/strong&gt; 机器学习（重点）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用train_test_split()——切分训练集、验证集、测试集&lt;/li&gt;
&lt;li&gt;模型初始化（针对模型各种参数的调整都是在这一步）&lt;/li&gt;
&lt;li&gt;调用fit()——训练样本&lt;/li&gt;
&lt;li&gt;调用score()——计算平均准确率。&lt;/li&gt;
&lt;li&gt;结果展示&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;划分训练集和测试集&#34;&gt;划分训练集和测试集&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 加载sklearn
from sklearn import tree
from sklearn.model_selection import train_test_split

# 读入火锅
data = pd.read_excel(&amp;quot;https://github.com/xiangyuchang/xiangyuchang.github.io/blob/master/BearData/shops_nm_cleaned.xlsx?raw=true&amp;quot;, encoding=&#39;utf8&#39;)

# 划分训练集、验证集、测试集
X_train, X_val, y_train, y_val = train_test_split(data.iloc[:, 1:-1], data.iloc[:, -1], test_size=0.3, random_state=0) #划分训练集与验证集
X_val, X_test, y_val, y_test = train_test_split(X_val, y_val, test_size=0.3, random_state=0) #划分验证集与测试集

print(&#39;训练集维度: {}, 验证集维度: {}，测试集维度：{} \n&#39;.format(y_train.shape, y_val.shape, y_test.shape))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;训练集维度: (489,), 验证集维度: (147,)，测试集维度：(63,) 
&lt;/code&gt;&lt;/pre&gt;
">dataframe&预处理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/pandas1/"" data-c="
          &lt;p&gt;shuyi；&lt;strong&gt;周三&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;学习目标&#34;&gt;学习目标：&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据预处理——numpy&amp;amp;pandas&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读入数据&lt;/li&gt;
&lt;li&gt;过滤重复&lt;/li&gt;
&lt;li&gt;处理缺失&lt;/li&gt;
&lt;li&gt;描述分析&lt;/li&gt;
&lt;li&gt;apply&lt;/li&gt;
&lt;li&gt;group by&lt;/li&gt;
&lt;li&gt;时间序列&lt;/li&gt;
&lt;li&gt;merge&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;画图——先学会最基本的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;散点图&lt;/li&gt;
&lt;li&gt;条形图&lt;/li&gt;
&lt;li&gt;直方图&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;火锅数据集作为例子学习&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把双十一、高考、直播、网剧，四个数据集作为练习题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;希望：&lt;strong&gt;掌握数据描述统计&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;画图基本matplotlib&#34;&gt;画图基本——Matplotlib&lt;/h1&gt;
&lt;h2 id=&#34;画布的概念&#34;&gt;画布的概念&lt;/h2&gt;
&lt;p&gt;matplotlib 中的pyplot函数:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;figure(figsize = (长，宽))：创建画布&lt;/li&gt;
&lt;li&gt;add_subplot(行，列，第几个位置）：分割画布&lt;/li&gt;
&lt;li&gt;plt.show()：画图&lt;/li&gt;
&lt;li&gt;plt.close()：关闭画布，jupyter里一定要关闭&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;预设&#34;&gt;预设&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;支持中文&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要设置字体路径 prop = mfm.FontProperties(fname = font_path)&lt;/p&gt;
&lt;p&gt;加文字时设置 fontproperties=prop即可&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;画图主题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如plt.style.use(&#39;ggplot&#39;)  # 指定全局画图主题为ggplot&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图片显示&lt;br&gt;
在jupyter 里显示图片需要加上：&lt;strong&gt;%matplotlib inline&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;坐标轴-辅助线-标题-图例&#34;&gt;坐标轴、辅助线、标题、图例&lt;/h2&gt;
&lt;p&gt;具体看狗熊会python画图&lt;/p&gt;
&lt;p&gt;[https://mmbiz.qpic.cn/mmbiz_png/1y1ObuUF34zwoIN91WUYmTtxkMRYD6QxZYk8URAW2XRo6WkOdDj6BVLsHDEWB8MFBmAWP3LwlRKVn5gicXdlwkQ/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1.png]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
#from IPython.core.interactiveshell import InteractiveShell
#InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;  

# matplotlib 中的pyplot函数，用于画图
import matplotlib.pyplot as plt      # 命名为plt

# 在jupyter 里显示图片
import numpy as np
%matplotlib inline

# font_manager函数，用于指定中文字体样式、大小
import matplotlib.font_manager as mfm

# 设置字体
font_path = r&amp;quot;/Users/mac/Library/Fonts/字体管家方萌简（非商业使用）v1.1.ttf&amp;quot;
prop = mfm.FontProperties(fname = font_path)

# 画图主题
plt.style.use(&#39;seaborn-white&#39;)  # 指定全局画图主题为ggplot

# 画布
fig = plt.figure(figsize=(16,9))   # 创建一张18*6的画布
ax1 = fig.add_subplot(111)        # 创建子图
#fig.add_subplot(2,2,1)           # 创建2*2=4张图，ax1画在第一张图上
ax1.set_title(&#39;你好&#39;, fontproperties=prop, fontsize=50)   # 图标题
ax1.hlines(y = 0.5, xmin = 0, xmax=1)
plt.show()  # 画图
plt.close()  # plt.show()结束后仍然保存在内存中, 切记关闭！！！在jupyter理！！！
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;Text(0.5,1,&#39;你好&#39;)






&amp;lt;matplotlib.collections.LineCollection at 0x114802d30&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;output_2_2.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 读入数据
import pandas as pd # 导入Pandas模块
merge_data = pd.read_excel(&amp;quot;https://github.com/xiangyuchang/xiangyuchang.github.io/blob/master/BearData/merge_shop_coupon_nm.xlsx?raw=true&amp;quot;) #读入数据
print(&#39;数据的维度是：&#39;, merge_data.shape)
merge_data.head() #查看数据的前5行
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;数据的维度是： (197, 12)
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;店名&lt;/th&gt;
      &lt;th&gt;关键词&lt;/th&gt;
      &lt;th&gt;城市&lt;/th&gt;
      &lt;th&gt;评分&lt;/th&gt;
      &lt;th&gt;评价数&lt;/th&gt;
      &lt;th&gt;人均&lt;/th&gt;
      &lt;th&gt;地址&lt;/th&gt;
      &lt;th&gt;营业时间&lt;/th&gt;
      &lt;th&gt;菜名&lt;/th&gt;
      &lt;th&gt;商家等级&lt;/th&gt;
      &lt;th&gt;购买人数&lt;/th&gt;
      &lt;th&gt;团购价&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;老北京涮羊肉&lt;/td&gt;
      &lt;td&gt;火锅&lt;/td&gt;
      &lt;td&gt;xa&lt;/td&gt;
      &lt;td&gt;4.4&lt;/td&gt;
      &lt;td&gt;877&lt;/td&gt;
      &lt;td&gt;45.5&lt;/td&gt;
      &lt;td&gt;西安市雁塔区朱雀大街250号东方大酒店西门斜对面（子午路站下车向北走60米路西）&lt;/td&gt;
      &lt;td&gt;11:00-21:00&lt;/td&gt;
      &lt;td&gt;【羊肉】【豆腐】【麻酱】【精品肥牛】【粉丝】【羔羊肉】【牛肚】【油豆皮】【香菇】【豆皮】【土...&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1692&lt;/td&gt;
      &lt;td&gt;118.5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;大龙燚火锅(粉巷店)&lt;/td&gt;
      &lt;td&gt;火锅&lt;/td&gt;
      &lt;td&gt;xa&lt;/td&gt;
      &lt;td&gt;4.6&lt;/td&gt;
      &lt;td&gt;2253&lt;/td&gt;
      &lt;td&gt;100.0&lt;/td&gt;
      &lt;td&gt;西安市碑林区粉巷南院门15A南苑中央广场食尚南苑2F&lt;/td&gt;
      &lt;td&gt;周一至周日 10:00-21:00&lt;/td&gt;
      &lt;td&gt;【麻辣排骨】【千层毛肚】【鸳鸯锅】【鸭血】【天味香肠】【薄土豆】【功夫黄瓜】【清汤锅】【印度...&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;19584&lt;/td&gt;
      &lt;td&gt;88.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;鲜上鲜文鱼庄(凤城五路店)&lt;/td&gt;
      &lt;td&gt;火锅&lt;/td&gt;
      &lt;td&gt;xa&lt;/td&gt;
      &lt;td&gt;4.5&lt;/td&gt;
      &lt;td&gt;1398&lt;/td&gt;
      &lt;td&gt;56.0&lt;/td&gt;
      &lt;td&gt;西安市未央区凤城五路地铁D口出人人乐5楼&lt;/td&gt;
      &lt;td&gt;全天&lt;/td&gt;
      &lt;td&gt;【生菜】【鸳鸯锅】【千叶豆腐】【荷包豆腐】【生鱼片】【毛肚】【文鱼】【鱼丸】【撒尿牛丸】【山...&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;11798&lt;/td&gt;
      &lt;td&gt;52.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;蜜悦士鲜牛肉时尚火锅(凯德广场店)&lt;/td&gt;
      &lt;td&gt;火锅&lt;/td&gt;
      &lt;td&gt;xa&lt;/td&gt;
      &lt;td&gt;4.4&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;63.0&lt;/td&gt;
      &lt;td&gt;西安市雁塔区南二环凯德广场四楼东南角&lt;/td&gt;
      &lt;td&gt;10:00-21:00&lt;/td&gt;
      &lt;td&gt;【吊龙伴】【三花腱】【番茄锅】【招牌牛舌】【油豆皮】【油炸豆腐皮】【菌汤鸳鸯锅】【手工面】【...&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;40&lt;/td&gt;
      &lt;td&gt;59.9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;大自在火锅(和平村店)&lt;/td&gt;
      &lt;td&gt;火锅&lt;/td&gt;
      &lt;td&gt;xa&lt;/td&gt;
      &lt;td&gt;4.3&lt;/td&gt;
      &lt;td&gt;214&lt;/td&gt;
      &lt;td&gt;84.0&lt;/td&gt;
      &lt;td&gt;西安市莲湖区三桥和平村十字西南角伯乐城市广场6层&lt;/td&gt;
      &lt;td&gt;暂无时间&lt;/td&gt;
      &lt;td&gt;【蔬菜拼盘】【黄豆芽】【虾饺】【撒尿牛肉丸】【油条】【毛肚】【自在小酥肉】【鸡爪】【自在嫩牛...&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;1282&lt;/td&gt;
      &lt;td&gt;59.5&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;散点图&#34;&gt;散点图&lt;/h2&gt;
&lt;p&gt;ax.scatter(x=,y=,color=&#39;&#39;,marker=&#39;&#39;)&lt;/p&gt;
&lt;h2 id=&#34;直方图&#34;&gt;直方图&lt;/h2&gt;
&lt;p&gt;ax.hist(x=, bins= ,color = ,cumulative = T/F)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(16,15)) 

ax1 = fig.add_subplot(221)    
ax1.scatter(y = merge_data[&#39;评价数&#39;], x = merge_data[&#39;人均&#39;], color=&#39;black&#39;)
ax1.set_title(&#39;人均-评价数 关系图&#39;, fontproperties=prop, fontsize=25)

# 基本设置
ax2 = fig.add_subplot(222)    
ax2.scatter(y = merge_data[&#39;购买人数&#39;], x = merge_data[&#39;评分&#39;], color=&#39;black&#39;)
ax2.set_title(&#39;评分-购买人数 关系图&#39;, fontproperties=prop, fontsize=25)

ax3 = fig.add_subplot(223)    
ax3.scatter(y = merge_data[&#39;评价数&#39;], x = merge_data[&#39;人均&#39;], color=&#39;black&#39;)
ax3.set_title(&#39;人均-评价数 关系图2&#39;, fontproperties=prop, fontsize=25)
ax3.set_ylim((500, 6000))
ax3.set_xlim((20, 60))
ax3.hlines(2000, 20, 60, colors =&amp;quot;r&amp;quot;, linestyles=&amp;quot;dashed&amp;quot;)

ax4 = fig.add_subplot(2,2,4)
ax4.hist(x = merge_data[&#39;评分&#39;], color = &amp;quot;grey&amp;quot;)
ax4.set_xlabel(&#39;评分&#39;, fontproperties=prop, fontsize=25)

plt.show() 
plt.close() 
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.collections.PathCollection at 0x115a723c8&amp;gt;






Text(0.5,1,&#39;人均-评价数 关系图&#39;)






&amp;lt;matplotlib.collections.PathCollection at 0x115ac2470&amp;gt;






Text(0.5,1,&#39;评分-购买人数 关系图&#39;)






&amp;lt;matplotlib.collections.PathCollection at 0x115aef1d0&amp;gt;






Text(0.5,1,&#39;人均-评价数 关系图2&#39;)






(500, 6000)






(20, 60)






&amp;lt;matplotlib.collections.LineCollection at 0x115aef6d8&amp;gt;






(array([  1.,   0.,   1.,   0.,   1.,   0.,   6.,   2.,  54., 132.]),
 array([0. , 0.5, 1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5, 5. ]),
 &amp;lt;a list of 10 Patch objects&amp;gt;)






Text(0.5,0,&#39;评分&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;output_5_11.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;箱线图&#34;&gt;箱线图&lt;/h2&gt;
&lt;p&gt;ax1.boxplot&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig = plt.figure(figsize=(12,8)) 
ax1 = fig.add_subplot(111)

d1 = merge_data[&#39;评价数&#39;][merge_data[&#39;购买人数&#39;] &amp;lt; 500]
d2 = merge_data[&#39;评价数&#39;][merge_data[&#39;购买人数&#39;] &amp;gt;= 500][merge_data[&#39;购买人数&#39;] &amp;lt; 1500]
d3 = merge_data[&#39;评价数&#39;][merge_data[&#39;购买人数&#39;] &amp;gt;= 1500][merge_data[&#39;购买人数&#39;] &amp;lt; 2000]
d = [d1, d2, d3]

ax1.boxplot(d)

#ax1.set_title(&#39;购买人数评价数关系图&#39;, fontproperties=prop, fontsize=20)
ax1.set_xlabel(&#39;购买人数&#39;, fontproperties=prop, fontsize=20)
ax1.set_ylabel(&#39;评价数&#39;, fontproperties=prop, fontsize=20)
ax1.set_xticklabels([&#39;&amp;lt;500&#39;, &#39;[500, 1500)&#39;, &#39;[1500, 2000)&#39;], fontproperties=prop, fontsize=20)
ax1.set_ylim((0, 1600))   # 去掉异常值

plt.show() 
plt.close() 

# 由于d只是为画图而产生的属于中间变量，之后不会再使用到
# 用完就删除，防止内存过大
del d
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{&#39;whiskers&#39;: [&amp;lt;matplotlib.lines.Line2D at 0x115bd26a0&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x115bd2b00&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x116bf7550&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x116bf79b0&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x116c05470&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x116c058d0&amp;gt;],
 &#39;caps&#39;: [&amp;lt;matplotlib.lines.Line2D at 0x115bd2f60&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x116bef400&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x116bf7e10&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x116bf7f28&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x116c05d30&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x116c05e48&amp;gt;],
 &#39;boxes&#39;: [&amp;lt;matplotlib.lines.Line2D at 0x115bd20f0&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x116befd30&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x116bfefd0&amp;gt;],
 &#39;medians&#39;: [&amp;lt;matplotlib.lines.Line2D at 0x116bef7f0&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x116bfe710&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x116c0d630&amp;gt;],
 &#39;fliers&#39;: [&amp;lt;matplotlib.lines.Line2D at 0x116befc50&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x116bfeb70&amp;gt;,
  &amp;lt;matplotlib.lines.Line2D at 0x116c0da90&amp;gt;],
 &#39;means&#39;: []}






Text(0.5,0,&#39;购买人数&#39;)






Text(0,0.5,&#39;评价数&#39;)






[Text(0,0,&#39;&amp;lt;500&#39;), Text(0,0,&#39;[500, 1500)&#39;), Text(0,0,&#39;[1500, 2000)&#39;)]






(0, 1600)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;output_7_5.png&#34; alt=&#34;png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;numpy&#34;&gt;numpy&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;ndarray:数组，存储单一数据类型 ~&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有点类似matrix，只能放数值，但是 T/F 浮点 int都行&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ufunc：对数组做处理&lt;br&gt;
需要了解：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;创建数组 numpy.array&lt;/li&gt;
&lt;li&gt;数据类型的定义dtype和转化float int bool&lt;/li&gt;
&lt;li&gt;统计分析 sum mean std var min max sort&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;创建一个matrix&#34;&gt;创建一个matrix&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;np.array~~ 利用列表构建一个数组&lt;/li&gt;
&lt;li&gt;np.arange(start, stop, step, dtype) ~~~ seq&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import numpy as np

# 用列表构建二维数组
# 可以理解为matrix
# 要求长度一致
np.array([[1,2,3,3,4,2],[&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;]])

# 用arange创建一个数组~~ 非常类似seq
np.arange(0,10,2)
np.arange(0,1,0.2)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;array([[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;3&#39;, &#39;4&#39;, &#39;2&#39;],
       [&#39;a&#39;, &#39;a&#39;, &#39;b&#39;, &#39;a&#39;, &#39;a&#39;, &#39;b&#39;]], dtype=&#39;&amp;lt;U21&#39;)






array([0, 2, 4, 6, 8])






array([0. , 0.2, 0.4, 0.6, 0.8])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;读入数据&#34;&gt;读入数据&lt;/h2&gt;
&lt;p&gt;首先尝试用昨天学的pandas read函数读入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;    

# 设置路径
import os                ## 加载标准库
os.chdir(&#39;/Users/mac/Desktop/快乐研一/python/py0915&#39;)   # 相当于setwd()
os.getcwd()            # 确认位置

# 读入多元作业1-1的csv
import pandas as pd  #导入Pandas模块
duoyuan1 = pd.read_csv(&amp;quot;肺活量与其他指标的数据.csv&amp;quot;)   # 读入当前目录下的某个excel
duoyuan1.head()   # 查看前五行
duoyuan1.dtypes
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;序号          int64
age         int64
weight    float64
time      float64
spulse      int64
rpulse      int64
mpulse      int64
OXY       float64
dtype: object
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着试试numpy创建数据或者读入数据：要求每一列都是一种类型&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加载numpy&lt;/li&gt;
&lt;li&gt;loadtxt 来读入&lt;/li&gt;
&lt;li&gt;定义字段类型 dtype&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 1.加载numpy
# import numpy as np  # 上面加载过了

# 2.读入数据，按定义好的字段类型匹配
# 读入csv文件分隔符delimiter=，
#duoyuan2 = np.loadtxt(&#39;肺活量与其他指标的数据.csv&#39;, delimiter = &amp;quot;,&amp;quot;, dtype = str)
#duoyuan2[3:7]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;定义字段类型&#34;&gt;定义字段类型&lt;/h2&gt;
&lt;p&gt;np.dtype([(字段1&#39;, 类型1), (字段2&#39;, 类型2)...(字段k&#39;, 类型k)])&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 定义字段类型
student = np.dtype([(&#39;name&#39;,np.str_,10), (&#39;age&#39;, np.int64), (&#39;marks&#39;, np.float64),(&#39;isgirl&#39;,np.bool_)]) 
stu_data = np.array([(&#39;abc&#39;, 21, 50, True),(&#39;xyz&#39;, 18, 75,True),(&#39;asd&#39;, 22, 90, False),(&#39;abc&#39;, 21, 50,True),(&#39;wsd&#39;, 20, 76,False)], dtype = student) 

# 查看某个字段用括号
stu_data[&#39;isgirl&#39;]
# 冒号分隔切片参数 start:stop:step 来进行切片操作
stu_data[:4:2]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&amp;lt;ipython-input-12-fc745cc02e4e&amp;gt; in &amp;lt;module&amp;gt;()
      1 # 定义字段类型
----&amp;gt; 2 student = np.dtype([(&#39;name&#39;,np.str_,10), (&#39;age&#39;, np.int64), (&#39;marks&#39;, np.float64),(&#39;isgirl&#39;,np.bool_)])
      3 stu_data = np.array([(&#39;abc&#39;, 21, 50, True),(&#39;xyz&#39;, 18, 75,True),(&#39;asd&#39;, 22, 90, False),(&#39;abc&#39;, 21, 50,True),(&#39;wsd&#39;, 20, 76,False)], dtype = student)
      4 
      5 # 查看某个字段用括号


NameError: name &#39;np&#39; is not defined
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;计算统计量&#34;&gt;计算统计量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;data.sort&lt;/li&gt;
&lt;li&gt;sum/mean/var/max/min&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;marks = stu_data[&#39;marks&#39;]
marks.astype(int)
marks.sort()
marks
[np.sum(marks),np.mean(marks),int(np.var(marks)),np.max(marks)]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&amp;lt;ipython-input-13-79ab63fcf526&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 marks = stu_data[&#39;marks&#39;]
      2 marks.astype(int)
      3 marks.sort()
      4 marks
      5 [np.sum(marks),np.mean(marks),int(np.var(marks)),np.max(marks)]


NameError: name &#39;stu_data&#39; is not defined
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;pandas&#34;&gt;pandas&lt;/h1&gt;
&lt;p&gt;需要掌握：&lt;/p&gt;
&lt;p&gt;基本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读入数据&lt;/li&gt;
&lt;li&gt;处理重复和异常值&lt;/li&gt;
&lt;li&gt;切片索引筛选&lt;/li&gt;
&lt;li&gt;统计量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进阶：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类似apply&lt;/li&gt;
&lt;li&gt;类似group.by&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拓展：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间序列&lt;/li&gt;
&lt;li&gt;结合sql——类似reshape&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;读入数据-2&#34;&gt;读入数据&lt;/h2&gt;
&lt;p&gt;read_csv or read_excel&lt;/p&gt;
&lt;p&gt;出现乱码时可以设置encoding = &#39;utf8&#39;或者&#39;gbk&#39;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 加载pandas 
import pandas as pd

# 读取狗熊会火锅数据
raw_data = pd.read_excel(&#39;https://github.com/xiangyuchang/xiangyuchang.github.io/blob/master/BearData/shops_nm.xlsx?raw=true&#39;)

# 查看数据维度
raw_data.shape
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(699, 9)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;切片索引&#34;&gt;切片索引&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 查看读入结果（注意 head也是针对pd读入，前一节numpy读入head报错了）

# 查看某列某行：
raw_data.iloc[1,0]    # 第2行第1列
#raw_data.iloc[0,:]    # 某一行
#raw_data[&#39;店名&#39;]     # 某一列
#raw_data.iloc[:,3]   # 某一列

# 输出前五行
raw_data.head()
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&#39;鲜上鲜文鱼庄(望庭国际店)&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;店名&lt;/th&gt;
      &lt;th&gt;关键词&lt;/th&gt;
      &lt;th&gt;城市&lt;/th&gt;
      &lt;th&gt;评分&lt;/th&gt;
      &lt;th&gt;评价数&lt;/th&gt;
      &lt;th&gt;人均&lt;/th&gt;
      &lt;th&gt;地址&lt;/th&gt;
      &lt;th&gt;营业时间&lt;/th&gt;
      &lt;th&gt;菜名&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;老北京涮羊肉&lt;/td&gt;
      &lt;td&gt;火锅&lt;/td&gt;
      &lt;td&gt;xa&lt;/td&gt;
      &lt;td&gt;4.4&lt;/td&gt;
      &lt;td&gt;877.0&lt;/td&gt;
      &lt;td&gt;45.5&lt;/td&gt;
      &lt;td&gt;西安市雁塔区朱雀大街250号东方大酒店西门斜对面（子午路站下车向北走60米路西）&lt;/td&gt;
      &lt;td&gt;11:00-21:00&lt;/td&gt;
      &lt;td&gt;【羊肉】【豆腐】【麻酱】【精品肥牛】【粉丝】【羔羊肉】【牛肚】【油豆皮】【香菇】【豆皮】【土...&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;鲜上鲜文鱼庄(望庭国际店)&lt;/td&gt;
      &lt;td&gt;火锅&lt;/td&gt;
      &lt;td&gt;xa&lt;/td&gt;
      &lt;td&gt;4.6&lt;/td&gt;
      &lt;td&gt;535.0&lt;/td&gt;
      &lt;td&gt;56&lt;/td&gt;
      &lt;td&gt;西安市高新区高新路80号望庭国际一栋楼10106室&lt;/td&gt;
      &lt;td&gt;11:00-23:00&lt;/td&gt;
      &lt;td&gt;【菌菇大拼】【麻酱】【菠萝飞饼】【鸳鸯锅】【酸菜鸳鸯锅】【青菜】【毛肚】【文鱼】【菌汤】【鱼...&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;大龙燚火锅(李家村店)&lt;/td&gt;
      &lt;td&gt;火锅&lt;/td&gt;
      &lt;td&gt;xa&lt;/td&gt;
      &lt;td&gt;4.6&lt;/td&gt;
      &lt;td&gt;29.0&lt;/td&gt;
      &lt;td&gt;大概92左右&lt;/td&gt;
      &lt;td&gt;西安市碑林区雁塔北路时亿广场南座2楼李家村华润万家外&lt;/td&gt;
      &lt;td&gt;10:00-22:00&lt;/td&gt;
      &lt;td&gt;【手撕竹笋】【麻辣排骨】【砣砣牛肉】【菠萝飞饼】【鸭血】【四川金针菇】【麻辣牛肉】【贡菜】【...&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;鲜上鲜文鱼庄(阳阳国际店)&lt;/td&gt;
      &lt;td&gt;火锅&lt;/td&gt;
      &lt;td&gt;xa&lt;/td&gt;
      &lt;td&gt;4.6&lt;/td&gt;
      &lt;td&gt;906.0&lt;/td&gt;
      &lt;td&gt;56&lt;/td&gt;
      &lt;td&gt;西安市雁塔区朱雀大街132号阳阳国际广场C座2楼&lt;/td&gt;
      &lt;td&gt;11:00-22:00&lt;/td&gt;
      &lt;td&gt;【海带】【鸳鸯锅】【冻豆腐】【荷包豆腐】【生鱼片】【毛肚】【文鱼】【清汤锅】【山珍菌汤锅】【...&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;大龙燚火锅(粉巷店)&lt;/td&gt;
      &lt;td&gt;火锅&lt;/td&gt;
      &lt;td&gt;xa&lt;/td&gt;
      &lt;td&gt;4.6&lt;/td&gt;
      &lt;td&gt;2253.0&lt;/td&gt;
      &lt;td&gt;人均：100&lt;/td&gt;
      &lt;td&gt;西安市碑林区粉巷南院门15A南苑中央广场食尚南苑2F&lt;/td&gt;
      &lt;td&gt;周一至周日 10:00-21:00&lt;/td&gt;
      &lt;td&gt;【麻辣排骨】【千层毛肚】【鸳鸯锅】【鸭血】【天味香肠】【薄土豆】【功夫黄瓜】【清汤锅】【印度...&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;理解dataframe&#34;&gt;理解DataFrame&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;非常非常类似R里的数据框&lt;/li&gt;
&lt;li&gt;每一列的数据类型要相同，但是不同列可以不同&lt;/li&gt;
&lt;li&gt;基于这个理念，可以通过构建字典或数组的方式生成DataFrame&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;重复值处理&#34;&gt;重复值处理&lt;/h2&gt;
&lt;p&gt;重复：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step1&lt;/strong&gt; .duplicated() 判断各行是否存在重复值&lt;/p&gt;
&lt;p&gt;data[&#39;列名&#39;].duplicated()  /  data.duplicated()&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step2&lt;/strong&gt; .删除重复值&lt;/p&gt;
&lt;p&gt;删除方法1：.drop_duplicates(列名，丢弃方法)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;first 只留第一个&lt;/li&gt;
&lt;li&gt;last 只留最后一个&lt;/li&gt;
&lt;li&gt;false 全部删除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;删除方法2：.duplicated() + 判断表达式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;raw_data[raw_data.duplicated()]  # 结果表明，各行都不重复

# 注意！即使后面有和它重复的，第一次出现时仍然记作T
len(raw_data[raw_data.duplicated()] )  # 看重复的行数


# 写一个小判断，可以编成函数使用
if len(raw_data[raw_data.duplicated()])==0:  # 看是否有重复
    print(&#39;没有任何重复&#39;) 
else:
    print(raw_data[raw_data.duplicated()])   # 输出重复行
    
    
# 加入人为构造一个重复: 把第一行数据赋给第二行
raw_data.iloc[1, : ] = raw_data.iloc[0, :]

# 写一个小判断，可以编成函数使用
if len(raw_data[raw_data.duplicated()])==0:  # 看是否有重复
    print(&#39;没有任何重复&#39;) 
else:
    print(raw_data[raw_data.duplicated()])   # 输出重复行
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;店名&lt;/th&gt;
      &lt;th&gt;关键词&lt;/th&gt;
      &lt;th&gt;城市&lt;/th&gt;
      &lt;th&gt;评分&lt;/th&gt;
      &lt;th&gt;评价数&lt;/th&gt;
      &lt;th&gt;人均&lt;/th&gt;
      &lt;th&gt;地址&lt;/th&gt;
      &lt;th&gt;营业时间&lt;/th&gt;
      &lt;th&gt;菜名&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;0



没有任何重复
       店名 关键词  城市   评分    评价数    人均                                        地址  \
1  老北京涮羊肉  火锅  xa  4.4  877.0  45.5  西安市雁塔区朱雀大街250号东方大酒店西门斜对面（子午路站下车向北走60米路西）   

          营业时间                                                 菜名  
1  11:00-21:00  【羊肉】【豆腐】【麻酱】【精品肥牛】【粉丝】【羔羊肉】【牛肚】【油豆皮】【香菇】【豆皮】【土...  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 处理重复值，把店名当做唯一性的id
raw_data = raw_data.drop_duplicates(subset = [&#39;店名&#39;])  # 含义：删除店名重复的数据，只保留第一条

# 或者用if duplicates 然后subset一下，与上面等价
raw_data = raw_data[raw_data[&#39;店名&#39;].duplicated()==False]

# 当店名不是唯一id，只想删除完全重复两行，方法2更好
# 当希望通过几列共同判断时，maybe只有方法1可行

raw_data.shape
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(698, 9)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;缺失处理&#34;&gt;缺失处理&lt;/h2&gt;
&lt;p&gt;isnull()作用于某一列或某几列——判断是否为缺失值&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;data.isnull().sum(axis = 0)   看各变量缺失总数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;data[&#39;列名&#39;].isnull()   某个变量具体缺失情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;data.dropna(axis=0, how=&#39;any&#39;, thresh = None, subset = None, inplace=True)  等价于na.omit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;data[data[&#39;列名&#39;].isnull() == False]   根据某个变量删除缺失&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt; raw_data1 = pd.read_excel(&#39;https://github.com/xiangyuchang/xiangyuchang.github.io/blob/master/BearData/shops_nm.xlsx?raw=true&#39;)

### 导出缺失数据
raw_data1[raw_data1[&#39;评价数&#39;].isnull()==True]

# subset保留无缺失的
raw_data2 = raw_data1[raw_data1[&#39;评价数&#39;].isnull()==False]
raw_data2.shape
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&amp;lt;ipython-input-1-f7326fdcb62d&amp;gt; in &amp;lt;module&amp;gt;()
----&amp;gt; 1 raw_data1 = pd.read_excel(&#39;https://github.com/xiangyuchang/xiangyuchang.github.io/blob/master/BearData/shops_nm.xlsx?raw=true&#39;)
      2 
      3 ### 导出缺失数据
      4 raw_data1[raw_data1[&#39;评价数&#39;].isnull()==True]
      5 


NameError: name &#39;pd&#39; is not defined
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;0918-pandas继续&#34;&gt;0918 pandas继续&lt;/h1&gt;
&lt;h2 id=&#34;实例exercise&#34;&gt;实例exercise&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#### 读入
os.chdir(&amp;quot;/Users/mac/Desktop/快乐研一/python/data&amp;quot;)
import pandas as pd
gaokao = pd.read_csv(&amp;quot;高考_numpy专用.csv&amp;quot;)

gaokao.head()
gaokao.shape
gaokao.iloc[0,:]
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;大学名称&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;重点学科&lt;/th&gt;
      &lt;th&gt;博士点&lt;/th&gt;
      &lt;th&gt;分数线&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;北京大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;81.0&lt;/td&gt;
      &lt;td&gt;201.0&lt;/td&gt;
      &lt;td&gt;694.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;复旦大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;30.0&lt;/td&gt;
      &lt;td&gt;178.0&lt;/td&gt;
      &lt;td&gt;687.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;清华大学&lt;/td&gt;
      &lt;td&gt;综合&lt;/td&gt;
      &lt;td&gt;37.0&lt;/td&gt;
      &lt;td&gt;253.0&lt;/td&gt;
      &lt;td&gt;686.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;pre&gt;&lt;code&gt;(98, 5)






大学名称    北京大学
类型        综合
重点学科      81
博士点      201
分数线      694
Name: 0, dtype: object
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#### 缺失值检查
# 看各变量中缺失值的数量
gaokao.isnull().sum(axis = 0)             #  每一列缺失几项
gaokao.isnull().sum(axis = 0)/gaokao.shape[0]   # 每个变量的缺失比例
#gaokao.isnull().sum(axis = 1)            #  每一行缺失几项


#### 删除缺失
## 第一种：na.omit 对于包含任意缺失的行直接删除
gaokao.dropna(axis=0, how=&#39;any&#39;, thresh = None, subset = None, inplace=True)
gaokao.isnull().sum(axis = 0)
# axis 指 轴，0是行，1是列，
# how 是删除条件：any 任意一个为na则删除整行/列,all 整行/列为na才删除
# inplace 是否在原DataFrame 上进行删除，false为否

##第二种：subset，对某个变量缺失的列进行删除
gaokao1 = gaokao[gaokao[&#39;大学名称&#39;].isnull() == False]
#gaokao.drop(labels = gaokao.index[data3[&#39;age&#39;].isnull()], axis = 0)  #这个和前一行效果一样
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;大学名称    2
类型      2
重点学科    4
博士点     4
分数线     4
dtype: int64






大学名称    0.020408
类型      0.020408
重点学科    0.040816
博士点     0.040816
分数线     0.040816
dtype: float64






大学名称    0
类型      0
重点学科    0
博士点     0
分数线     0
dtype: int64
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#### 删除大学名称重复的行
gaokao2 = gaokao1[gaokao1[&#39;大学名称&#39;].duplicated()==False]
gaokao1.shape[0]-gaokao2.shape[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;各种切片操作&#34;&gt;各种切片操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;data.iloc[n, m]&lt;/li&gt;
&lt;li&gt;data.loc[n,&#39;列名&#39;]&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;字符串数字-如何清洗变量&#34;&gt;“字符串+数字” 如何清洗变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;整理多余的字符为filter_words&lt;/li&gt;
&lt;li&gt;判断是否包含这些filter_words&lt;/li&gt;
&lt;li&gt;replace(x, &amp;quot;&amp;quot;)  删除字符串，只保留数字&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;raw_data1 = pd.read_excel(&#39;https://github.com/xiangyuchang/xiangyuchang.github.io/blob/master/BearData/shops_nm.xlsx?raw=true&#39;)
raw_data1.shape
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(699, 9)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;raw_data2 = raw_data1[raw_data1[&#39;评价数&#39;].isnull()==False]

# 查看人均这一列前几行
renjun1 = raw_data2.loc[1,&#39;人均&#39;]; [renjun1, type(renjun1)]
renjun2 = raw_data2.loc[2,&#39;人均&#39;]; [renjun2, type(renjun2)]

# 整理出多余的字符
filter_words = [&#39;大概&#39;,&#39;左右&#39;,&#39;人均&#39;,&#39;人均：&#39;,&#39;差不多&#39;,&#39;：&#39;]

# “大概92左右”——&amp;gt; 92
for wordi in filter_words:
    if wordi in renjun2:
        renjun2 = renjun2.replace(wordi,&amp;quot;&amp;quot;)      
int(renjun2)

# 再套一个对所有样本的循环，需要先判断是否为int
for i in  raw_data2.index:
        renjun = raw_data2.loc[i,&#39;人均&#39;]
        if type(renjun) is int or type(renjun) is float:
            continue  # 插入一个判断，如果不含字符跳过下面直接到赋值
        for wordi in filter_words:
            if wordi in renjun:
                raw_data2.at[i,&#39;人均&#39;]  = raw_data2.loc[i,&#39;人均&#39;].replace(wordi,&amp;quot;&amp;quot;)
                
raw_data2[&#39;人均&#39;] = raw_data2[&#39;人均&#39;].astype(float)  # 转换为float类型方便计算统计量

## 不显示warnings
import warnings
warnings.filterwarnings(&amp;quot;ignore&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[56, int]






[&#39;大概92左右&#39;, str]






92



/Users/mac/anaconda3/lib/python3.7/site-packages/ipykernel_launcher.py:25: SettingWithCopyWarning: 
A value is trying to be set on a copy of a slice from a DataFrame.
Try using .loc[row_indexer,col_indexer] = value instead

See the caveats in the documentation: http://pandas.pydata.org/pandas-docs/stable/indexing.html#indexing-view-versus-copy
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;描述统计量&#34;&gt;描述统计量&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;raw_data2.describe()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;评分&lt;/th&gt;
      &lt;th&gt;评价数&lt;/th&gt;
      &lt;th&gt;人均&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;count&lt;/th&gt;
      &lt;td&gt;695.000000&lt;/td&gt;
      &lt;td&gt;695.000000&lt;/td&gt;
      &lt;td&gt;695.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;mean&lt;/th&gt;
      &lt;td&gt;4.025036&lt;/td&gt;
      &lt;td&gt;373.473381&lt;/td&gt;
      &lt;td&gt;53.533669&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;std&lt;/th&gt;
      &lt;td&gt;1.449120&lt;/td&gt;
      &lt;td&gt;930.327264&lt;/td&gt;
      &lt;td&gt;47.406067&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;min&lt;/th&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;5.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;25%&lt;/th&gt;
      &lt;td&gt;4.300000&lt;/td&gt;
      &lt;td&gt;5.000000&lt;/td&gt;
      &lt;td&gt;32.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;50%&lt;/th&gt;
      &lt;td&gt;4.500000&lt;/td&gt;
      &lt;td&gt;69.000000&lt;/td&gt;
      &lt;td&gt;43.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;75%&lt;/th&gt;
      &lt;td&gt;4.700000&lt;/td&gt;
      &lt;td&gt;301.500000&lt;/td&gt;
      &lt;td&gt;63.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;max&lt;/th&gt;
      &lt;td&gt;5.000000&lt;/td&gt;
      &lt;td&gt;9417.000000&lt;/td&gt;
      &lt;td&gt;548.000000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;apply-加速循环&#34;&gt;apply 加速循环&lt;/h2&gt;
&lt;p&gt;等价于for循环+if条件判断&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 定义function：
def clean_price(x):
    filter_words = [&#39;人均：&#39;, &#39;人均&#39;, &#39;大概&#39;, &#39;左右&#39;, &#39;差不多&#39;]
    
    if type(x) is int or type(x) is float:
        return x 
    for word in filter_words:
        if word in x:
            x = x.replace(word, &#39;&#39;)
    return x 

raw_data2 = raw_data1[raw_data1[&#39;评价数&#39;].isnull()==False]
# apply代替循环——应用该function
raw_data2[&#39;人均&#39;] = raw_data2[&#39;人均&#39;].apply(clean_price)
# 转化为float
raw_data2[&#39;人均&#39;] = raw_data2[&#39;人均&#39;].astype(float)
# 描述统计
raw_data2.describe()
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;评分&lt;/th&gt;
      &lt;th&gt;评价数&lt;/th&gt;
      &lt;th&gt;人均&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;count&lt;/th&gt;
      &lt;td&gt;695.000000&lt;/td&gt;
      &lt;td&gt;695.000000&lt;/td&gt;
      &lt;td&gt;695.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;mean&lt;/th&gt;
      &lt;td&gt;4.025036&lt;/td&gt;
      &lt;td&gt;373.473381&lt;/td&gt;
      &lt;td&gt;53.533669&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;std&lt;/th&gt;
      &lt;td&gt;1.449120&lt;/td&gt;
      &lt;td&gt;930.327264&lt;/td&gt;
      &lt;td&gt;47.406067&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;min&lt;/th&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;0.000000&lt;/td&gt;
      &lt;td&gt;5.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;25%&lt;/th&gt;
      &lt;td&gt;4.300000&lt;/td&gt;
      &lt;td&gt;5.000000&lt;/td&gt;
      &lt;td&gt;32.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;50%&lt;/th&gt;
      &lt;td&gt;4.500000&lt;/td&gt;
      &lt;td&gt;69.000000&lt;/td&gt;
      &lt;td&gt;43.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;75%&lt;/th&gt;
      &lt;td&gt;4.700000&lt;/td&gt;
      &lt;td&gt;301.500000&lt;/td&gt;
      &lt;td&gt;63.000000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;max&lt;/th&gt;
      &lt;td&gt;5.000000&lt;/td&gt;
      &lt;td&gt;9417.000000&lt;/td&gt;
      &lt;td&gt;548.000000&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;groupby-agg&#34;&gt;groupby &amp;amp; agg&lt;/h2&gt;
&lt;p&gt;key + data——字典分组非常快&lt;/p&gt;
&lt;p&gt;data.groupby(by = 按某列分组).agg({&amp;quot;列名&amp;quot;:&amp;quot;函数&amp;quot;})&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def cate_shops(x):
    if x&amp;gt;4.5:
        return &amp;quot;高分&amp;quot;
    if x&amp;gt;3 and x&amp;lt;=4.5:
        return &amp;quot;中等&amp;quot;
    if x&amp;lt;=3:
        return &amp;quot;低分&amp;quot;


# 用apply完成对商家评分的分级
raw_data2[&#39;商家等级&#39;] = raw_data2[&#39;评分&#39;].apply(cate_shops)  # 新建变量商家评价分级
raw_data2[&#39;商家等级&#39;].value_counts()   # 统计各类数量

# groupby+agg分组计算，等价于aggregate
# 看不同评分等级商家的平均人均
raw_data2.groupby(by = &#39;商家等级&#39;).agg({&#39;人均&#39;: &amp;quot;mean&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;高分    321
中等    290
低分     84
Name: 商家等级, dtype: int64
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;人均&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;商家等级&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;中等&lt;/th&gt;
      &lt;td&gt;54.052414&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;低分&lt;/th&gt;
      &lt;td&gt;63.550000&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;高分&lt;/th&gt;
      &lt;td&gt;50.443925&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;merge&#34;&gt;merge&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;多表合并&lt;/strong&gt;：暂时不学，用到再研究&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;data.merge：两个表按照字段合并&lt;/li&gt;
&lt;li&gt;data.concat：连接 rbind &amp;amp; cbind(靠axis=0/1来控制)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;输出excel&#34;&gt;输出excel&lt;/h2&gt;
&lt;p&gt;data.to_excel&lt;/p&gt;
">pandas&numpy</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/python-jichu1/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#0915-%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87&#34;&gt;0915 学习目标：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#jupyter-notebook%E7%BC%96%E8%BE%91%E5%99%A8&#34;&gt;jupyter notebook编辑器&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AF%95%E7%94%A8&#34;&gt;试用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BC%96%E8%BE%91%E6%8A%80%E5%B7%A7&#34;&gt;编辑技巧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BE%93%E5%87%BA%E6%8A%A5%E5%91%8A&#34;&gt;输出报告&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE&#34;&gt;读入数据&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%BE%E7%BD%AE%E8%B7%AF%E5%BE%84%E5%92%8C%E8%AF%BB%E5%85%A5&#34;&gt;设置路径和读入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9F%A5%E7%9C%8B%E8%AF%BB%E5%85%A5%E6%95%B0%E6%8D%AE%E6%9F%90%E8%A1%8C%E6%9F%90%E5%88%97&#34;&gt;查看读入数据某行某列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%86%99%E6%95%B0%E6%8D%AE&#34;&gt;写数据&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&#34;&gt;数据类型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&#34;&gt;查看数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AE%80%E5%8D%95%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97&#34;&gt;简单逻辑运算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86&#34;&gt;字符串处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E5%8C%96&#34;&gt;数据类型转化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&#34;&gt;数据结构&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%97%E8%A1%A8&#34;&gt;列表&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90-%E5%B5%8C%E5%A5%97-%E5%88%A0%E9%99%A4&#34;&gt;列表生成、嵌套、删除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%97%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C&#34;&gt;列表基本操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%97%E8%A1%A8%E5%87%BD%E6%95%B0&#34;&gt;列表函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%83%E7%A5%96&#34;&gt;元祖&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AD%97%E5%85%B8&#34;&gt;字典&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9B%86%E5%90%88&#34;&gt;集合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E6%95%B0%E6%8D%AE&#34;&gt;时间序列数据&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%93%E6%9E%84&#34;&gt;结构&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84-if-else&#34;&gt;分支结构 if-else&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%81%8D%E5%8E%86-for&#34;&gt;遍历 for&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%81%8D%E5%8E%86-%E5%88%97%E8%A1%A8%E7%94%9F%E6%88%90%E5%BC%8F&#34;&gt;遍历 列表生成式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BE%AA%E7%8E%AF-while&#34;&gt;循环 while&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%A8%A1%E5%9D%97&#34;&gt;函数与模块&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;0915-学习目标&#34;&gt;0915 学习目标：&lt;/h1&gt;
&lt;p&gt;上午&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;了解jupyter编辑器使用基本方法~&lt;/li&gt;
&lt;li&gt;尝试读入读出数据&lt;/li&gt;
&lt;li&gt;数据类型&lt;/li&gt;
&lt;li&gt;数据结构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下午&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构&lt;/li&gt;
&lt;li&gt;循环控制&lt;/li&gt;
&lt;li&gt;函数与模块基本概念&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;————————————————————————————————————————&lt;/p&gt;
&lt;h1 id=&#34;jupyter-notebook编辑器&#34;&gt;jupyter notebook编辑器&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;非常类似Rmarkdown！方便初学记笔记&lt;/li&gt;
&lt;li&gt;markdown语法&lt;/li&gt;
&lt;li&gt;公式用latex：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mi&gt;μ&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;f(x) = \mu&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.625em;vertical-align:-0.19444em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;μ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;试用&#34;&gt;试用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 代码块1
my_str = &#39;试用jupyter&#39;
my_list = [9,15,&#39;试用jupyter&#39;]
print(my_str)
print(my_list)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;试用jupyter
[9, 15, &#39;试用jupyter&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;编辑技巧&#34;&gt;编辑技巧&lt;/h2&gt;
&lt;p&gt;1.点击esc进入命令模式，可以用快捷键运行代码：和r一样control+return。还可以快速调整代码块的顺序，快速插入新的——b，强制停止——正方形，等等&lt;/p&gt;
&lt;p&gt;2.输出结果太多时候，可以点输出左侧的区域——折叠&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;!pwd   # jupyter专属的，获取当前目录的方式

## 将代码块运行结果全部输出，而不是只输出最后的，适用于全文
from IPython.core.interactiveshell import InteractiveShell
InteractiveShell.ast_node_interactivity = &amp;quot;all&amp;quot;     
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;/Users/mac/Desktop/快乐研一/python/py0915
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;输出报告&#34;&gt;输出报告&lt;/h2&gt;
&lt;p&gt;1.file-download可以制作PDF/HTML/...&lt;/p&gt;
&lt;p&gt;2.view-cell toolbar-slideshow可以制作PPT&lt;/p&gt;
&lt;p&gt;————————————————————————————————————————&lt;/p&gt;
&lt;h1 id=&#34;读入数据&#34;&gt;读入数据&lt;/h1&gt;
&lt;p&gt;学习步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;step1.设置路径&lt;/li&gt;
&lt;li&gt;step2.导入pandas&lt;/li&gt;
&lt;li&gt;step3.读入excel或csv&lt;/li&gt;
&lt;li&gt;step4.read或者head看看数据内容&lt;/li&gt;
&lt;li&gt;step5.读取某列某行&lt;/li&gt;
&lt;li&gt;step6.创建一个新txt&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设置路径和读入&#34;&gt;设置路径和读入&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;############################
# 查看路径
import os             ## 加载标准库（暂时不理解）
os.getcwd()          ## 查看当前工作目录
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&#39;/Users/mac/Desktop/快乐研一/python/py0915&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;############################
# 读入数据excel或者csv——pandas
import pandas as pd  #导入Pandas模块

# 设置路径
os.chdir(&#39;/Users/mac/Desktop/快乐研一/python/py0915&#39;)   # 相当于setwd()
os.getcwd()   # 确认位置

# 读入excel
duoyuan = pd.read_excel(&amp;quot;肺活量与其他指标的数据.xlsx&amp;quot;)   # 读入当前目录下的某个excel
duoyuan.head()   # 查看前五行

# 读入csv
duoyuan_csv = pd.read_csv(&amp;quot;肺活量与其他指标的数据.csv&amp;quot;)

# 从网上下载数据读取（函数不变）
coupon = pd.read_excel(&amp;quot;https://github.com/xiangyuchang/xiangyuchang.github.io/blob/master/BearData/coupon_nm.xlsx?raw=true&amp;quot;)
coupon.head()  #狗熊会火锅数据
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&#39;/Users/mac/Desktop/快乐研一/python/py0915&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;序号&lt;/th&gt;
      &lt;th&gt;age&lt;/th&gt;
      &lt;th&gt;weight&lt;/th&gt;
      &lt;th&gt;time&lt;/th&gt;
      &lt;th&gt;spulse&lt;/th&gt;
      &lt;th&gt;rpulse&lt;/th&gt;
      &lt;th&gt;mpulse&lt;/th&gt;
      &lt;th&gt;OXY&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;57&lt;/td&gt;
      &lt;td&gt;73.37&lt;/td&gt;
      &lt;td&gt;12.63&lt;/td&gt;
      &lt;td&gt;58&lt;/td&gt;
      &lt;td&gt;174&lt;/td&gt;
      &lt;td&gt;176&lt;/td&gt;
      &lt;td&gt;39.407&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;54&lt;/td&gt;
      &lt;td&gt;79.38&lt;/td&gt;
      &lt;td&gt;11.17&lt;/td&gt;
      &lt;td&gt;62&lt;/td&gt;
      &lt;td&gt;156&lt;/td&gt;
      &lt;td&gt;165&lt;/td&gt;
      &lt;td&gt;46.080&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;52&lt;/td&gt;
      &lt;td&gt;76.32&lt;/td&gt;
      &lt;td&gt;9.63&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;164&lt;/td&gt;
      &lt;td&gt;166&lt;/td&gt;
      &lt;td&gt;45.441&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
      &lt;td&gt;70.87&lt;/td&gt;
      &lt;td&gt;8.92&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;146&lt;/td&gt;
      &lt;td&gt;155&lt;/td&gt;
      &lt;td&gt;54.625&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;51&lt;/td&gt;
      &lt;td&gt;67.25&lt;/td&gt;
      &lt;td&gt;11.08&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
      &lt;td&gt;172&lt;/td&gt;
      &lt;td&gt;182&lt;/td&gt;
      &lt;td&gt;45.118&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;团购名&lt;/th&gt;
      &lt;th&gt;店名&lt;/th&gt;
      &lt;th&gt;团购活动ID&lt;/th&gt;
      &lt;th&gt;团购介绍&lt;/th&gt;
      &lt;th&gt;购买人数&lt;/th&gt;
      &lt;th&gt;团购评价&lt;/th&gt;
      &lt;th&gt;评价人数&lt;/th&gt;
      &lt;th&gt;到期时间&lt;/th&gt;
      &lt;th&gt;团购价&lt;/th&gt;
      &lt;th&gt;市场价&lt;/th&gt;
      &lt;th&gt;地址&lt;/th&gt;
      &lt;th&gt;团购内容&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
      &lt;th&gt;购买须知&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;壹分之贰豪华生日派对套餐&lt;/td&gt;
      &lt;td&gt;壹分之贰聚会吧桌游轰趴馆(旗舰店)&lt;/td&gt;
      &lt;td&gt;38744470&lt;/td&gt;
      &lt;td&gt;仅售880元，价值7342元豪华生日派对聚会桌游轰趴夜场10小时（通宵包场）！免费WiFi，...&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;暂无评价&lt;/td&gt;
      &lt;td&gt;暂无评价&lt;/td&gt;
      &lt;td&gt;2018-08-10&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;【西安市雁塔区小寨东路11号壹又贰分之壹B楼1003】&lt;/td&gt;
      &lt;td&gt;【内容: 豪华主题场地, 规格: 10小时, 价格: 600元】【内容: 轰趴场地布置, 规...&lt;/td&gt;
      &lt;td&gt;随便退&lt;/td&gt;
      &lt;td&gt;【有效期2017年06月07日至2018年08月10日】\n【可用时间周末法定节假日通用08...&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;壹分之贰豪华棋牌包间&lt;/td&gt;
      &lt;td&gt;壹分之贰聚会吧桌游轰趴馆(旗舰店)&lt;/td&gt;
      &lt;td&gt;38632123&lt;/td&gt;
      &lt;td&gt;仅售98元，价值240元豪华棋牌包间4小时套餐（4人）1份！免费WiFi！&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;暂无评价&lt;/td&gt;
      &lt;td&gt;暂无评价&lt;/td&gt;
      &lt;td&gt;2018-08-10&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;【西安市雁塔区小寨东路11号壹又贰分之壹B楼1003】&lt;/td&gt;
      &lt;td&gt;【内容: 豪华棋牌包间4小时套餐（4人）, 规格: 1份, 价格: 240元】&lt;/td&gt;
      &lt;td&gt;随便退&lt;/td&gt;
      &lt;td&gt;【有效期2017年05月26日至2018年08月10日】\n【可用时间周末法定节假日通用08...&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;壹分之贰豪华生日派对套餐&lt;/td&gt;
      &lt;td&gt;壹分之贰聚会吧桌游轰趴馆(旗舰店)&lt;/td&gt;
      &lt;td&gt;38744514&lt;/td&gt;
      &lt;td&gt;仅售480元，价值3685元豪华生日派对聚会桌游轰趴5小时（包场）！免费WiFi，需预约！&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;暂无评价&lt;/td&gt;
      &lt;td&gt;暂无评价&lt;/td&gt;
      &lt;td&gt;2018-08-10&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;【西安市雁塔区小寨东路11号壹又贰分之壹B楼1003】&lt;/td&gt;
      &lt;td&gt;【内容: 豪华主题场地, 规格: 5小时, 价格: 300元】【内容: 轰趴场地布置, 规格...&lt;/td&gt;
      &lt;td&gt;随便退&lt;/td&gt;
      &lt;td&gt;【有效期2017年06月07日至2018年08月10日】\n【可用时间周末法定节假日通用08...&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;396元1-15人服务&lt;/td&gt;
      &lt;td&gt;壹分之贰聚会吧桌游轰趴馆(旗舰店)&lt;/td&gt;
      &lt;td&gt;13377118&lt;/td&gt;
      &lt;td&gt;仅售396元，价值2575元台球优享套餐！免费WiFi，需预约！&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;2018-09-04&lt;/td&gt;
      &lt;td&gt;396.0&lt;/td&gt;
      &lt;td&gt;2575.0&lt;/td&gt;
      &lt;td&gt;【西安市雁塔区小寨东路11号壹又贰分之壹B楼1003】&lt;/td&gt;
      &lt;td&gt;【内容: 复式结构场地, 规格: 1次, 价格: 200元】【内容: 场地布置, 规格: 1...&lt;/td&gt;
      &lt;td&gt;随便退&lt;/td&gt;
      &lt;td&gt;【有效期2016年05月06日至2018年09月04日】\n【可用时间周末法定节假日通用24...&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;六婆串串香火锅100代金券&lt;/td&gt;
      &lt;td&gt;六婆串串香火锅&lt;/td&gt;
      &lt;td&gt;38767590&lt;/td&gt;
      &lt;td&gt;仅售85元，价值100元代金券！免费停车，免费WiFi！&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;暂无评价&lt;/td&gt;
      &lt;td&gt;暂无评价&lt;/td&gt;
      &lt;td&gt;2018-08-30&lt;/td&gt;
      &lt;td&gt;85.0&lt;/td&gt;
      &lt;td&gt;100.0&lt;/td&gt;
      &lt;td&gt;【西安市雁塔区长丰园小区12号楼7号商铺】【西安市周至县中心街隆发云塔广场C016号】&lt;/td&gt;
      &lt;td&gt;【内容: 代金券, 规格: 1张, 价格: 100元】&lt;/td&gt;
      &lt;td&gt;随便退&lt;/td&gt;
      &lt;td&gt;【有效期2017年06月09日至2018年08月30日】\n【可用时间周末法定节假日通用09...&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;查看读入数据某行某列&#34;&gt;查看读入数据某行某列&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Pandas模块导入的数据都以数据框（Data Frame)的方式存储。如何读取某列某行：&lt;strong&gt;在数据集后加.iloc，并用方括号 [ ,] 表示行列的位置&lt;/strong&gt;,要注意Python中&lt;strong&gt;从零开始计数&lt;/strong&gt;，所以[1,1]表示第2行第2列！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;等数据结构部分再细学&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;coupon.iloc[0, 1]              # 查看火锅数据第1行第2列
coupon.loc[100, &#39;地址&#39;]     # 查看第100行店铺地址
coupon.loc[1000,]            # 查看第1000条数据全部信息
# coupon[&#39;团购名&#39;]           # 查看某列
# 似乎有很多方法，这部分后面细学
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&#39;壹分之贰聚会吧桌游轰趴馆(旗舰店)&#39;






&#39;【西安市碑林区东大街452号西北金行4楼】&#39;






团购名                                               王婆大虾2-3人餐
店名                                               王婆大虾(万科城店)
团购活动ID                                             38243352
团购介绍                          仅售98元，价值122元3人餐！可使用包间，免费WiFi！
购买人数                                                     34
团购评价                                                      4
评价人数                                                      3
到期时间                                             2018-09-04
团购价                                                      98
市场价                                                     122
地址        【郑州市管城区中州大道与航海东路交叉口富田太阳城东方美食街向北150米路西（启元国际小学对面...
团购内容      【内容: 王婆大虾, 规格: 1份, 价格: 78元】【内容: 金针菇, 规格: 1份, 价...
备注                                                      随便退
购买须知      【有效期2017年04月17日至2018年09月04日】\n【可用时间周末法定节假日通用11...
Name: 1000, dtype: object
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;写数据&#34;&gt;写数据&lt;/h2&gt;
&lt;p&gt;读写数据用内置函数open，读写txt文件&lt;/p&gt;
&lt;p&gt;f = open(&amp;lt;文件名&amp;gt;, &amp;lt;打开模式&amp;gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;############################
# 读写数据txt——open
new_txt = open(&amp;quot;创建新文件练习.txt&amp;quot;,&amp;quot;w&amp;quot;)  #w代表写一个新文件
new_txt.write(&amp;quot;这是杨舒仪的一个新txt文件!\n建立在当前工作目录下\n9月15日~&amp;quot;)
new_txt.close() #一定记得关闭文件，否则会占用系统资源
# 建立成功~~

# 接着再次读取这个数据
data = open(&amp;quot;创建新文件练习.txt&amp;quot;,&amp;quot;r&amp;quot;) 
data.read()    # 查看内容
data.close()   #关闭文件
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;33






&#39;这是杨舒仪的一个新txt文件!\n建立在当前工作目录下\n9月15日~&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;————————————————————————————————————————&lt;/p&gt;
&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;p&gt;首先简单了解下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数 int，可以直接计算&lt;/li&gt;
&lt;li&gt;布尔/BOOL True和False&lt;/li&gt;
&lt;li&gt;浮点，&lt;/li&gt;
&lt;li&gt;复数&lt;/li&gt;
&lt;li&gt;字符串&lt;/li&gt;
&lt;li&gt;时间数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;查看数据类型&#34;&gt;查看数据类型&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 查看数据类型
type(915)
type(&amp;quot;915&amp;quot;)
type(9.15)
type(True)

# 查看某个数据集所有变量的type
coupon.dtypes
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;int






str






float






bool






团购名        object
店名         object
团购活动ID      int64
团购介绍       object
购买人数        int64
团购评价       object
评价人数       object
到期时间       object
团购价       float64
市场价       float64
地址         object
团购内容       object
备注         object
购买须知       object
dtype: object
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;简单逻辑运算&#34;&gt;简单逻辑运算&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;and 和 or 连接&lt;/li&gt;
&lt;li&gt;使用：利用布尔值寻找需要的特点数据&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 简单逻辑运算
(1!= 2) and (1==1)   
((3+2)&amp;gt;5) or (1&amp;gt;(3/2)) 

# 找到火锅店名为六婆串串香火锅的数据
coupon[coupon[&#39;店名&#39;]==&#39;六婆串串香火锅&#39;]   

# 还没学数据结构，暂时靠猜测上面的代码含义，仿写出下面的：

# 找到团购价高于2000的火锅数据
coupon[coupon[&#39;团购价&#39;]&amp;gt;2000]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;True






False
&lt;/code&gt;&lt;/pre&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;团购名&lt;/th&gt;
      &lt;th&gt;店名&lt;/th&gt;
      &lt;th&gt;团购活动ID&lt;/th&gt;
      &lt;th&gt;团购介绍&lt;/th&gt;
      &lt;th&gt;购买人数&lt;/th&gt;
      &lt;th&gt;团购评价&lt;/th&gt;
      &lt;th&gt;评价人数&lt;/th&gt;
      &lt;th&gt;到期时间&lt;/th&gt;
      &lt;th&gt;团购价&lt;/th&gt;
      &lt;th&gt;市场价&lt;/th&gt;
      &lt;th&gt;地址&lt;/th&gt;
      &lt;th&gt;团购内容&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
      &lt;th&gt;购买须知&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;六婆串串香火锅100代金券&lt;/td&gt;
      &lt;td&gt;六婆串串香火锅&lt;/td&gt;
      &lt;td&gt;38767590&lt;/td&gt;
      &lt;td&gt;仅售85元，价值100元代金券！免费停车，免费WiFi！&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;暂无评价&lt;/td&gt;
      &lt;td&gt;暂无评价&lt;/td&gt;
      &lt;td&gt;2018-08-30&lt;/td&gt;
      &lt;td&gt;85.0&lt;/td&gt;
      &lt;td&gt;100.0&lt;/td&gt;
      &lt;td&gt;【西安市雁塔区长丰园小区12号楼7号商铺】【西安市周至县中心街隆发云塔广场C016号】&lt;/td&gt;
      &lt;td&gt;【内容: 代金券, 规格: 1张, 价格: 100元】&lt;/td&gt;
      &lt;td&gt;随便退&lt;/td&gt;
      &lt;td&gt;【有效期2017年06月09日至2018年08月30日】\n【可用时间周末法定节假日通用09...&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;style scoped&gt;
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }
&lt;pre&gt;&lt;code&gt;.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/style&gt;
&lt;table border=&#34;1&#34; class=&#34;dataframe&#34;&gt;
  &lt;thead&gt;
    &lt;tr style=&#34;text-align: right;&#34;&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;团购名&lt;/th&gt;
      &lt;th&gt;店名&lt;/th&gt;
      &lt;th&gt;团购活动ID&lt;/th&gt;
      &lt;th&gt;团购介绍&lt;/th&gt;
      &lt;th&gt;购买人数&lt;/th&gt;
      &lt;th&gt;团购评价&lt;/th&gt;
      &lt;th&gt;评价人数&lt;/th&gt;
      &lt;th&gt;到期时间&lt;/th&gt;
      &lt;th&gt;团购价&lt;/th&gt;
      &lt;th&gt;市场价&lt;/th&gt;
      &lt;th&gt;地址&lt;/th&gt;
      &lt;th&gt;团购内容&lt;/th&gt;
      &lt;th&gt;备注&lt;/th&gt;
      &lt;th&gt;购买须知&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;469&lt;/th&gt;
      &lt;td&gt;天骊君廷大酒店美食套餐&lt;/td&gt;
      &lt;td&gt;天骊君廷大酒店&lt;/td&gt;
      &lt;td&gt;8412752&lt;/td&gt;
      &lt;td&gt;仅售3999元，价值5368元美食套餐！请至少提前1天预约，提供免费WiFi、停车位，可使用...&lt;/td&gt;
      &lt;td&gt;195&lt;/td&gt;
      &lt;td&gt;暂无评价&lt;/td&gt;
      &lt;td&gt;暂无评价&lt;/td&gt;
      &lt;td&gt;2018-09-05&lt;/td&gt;
      &lt;td&gt;3999.0&lt;/td&gt;
      &lt;td&gt;5368.0&lt;/td&gt;
      &lt;td&gt;【西安市高新区太白南路198号】&lt;/td&gt;
      &lt;td&gt;【内容: 一帆风顺（蓝莓山药、酱汁萝卜、虾皮海藻、广式椒圈、黄瓜蜇头、茶香酱鸭、酱牛肉、君廷...&lt;/td&gt;
      &lt;td&gt;随便退&lt;/td&gt;
      &lt;td&gt;【有效期2016年02月08日至2018年09月05日】\n【可用时间法定节假日当天不可使用...&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;h2 id=&#34;字符串处理&#34;&gt;字符串处理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;字符串拼接 +  （R中的paste？）&lt;/li&gt;
&lt;li&gt;复制 *  （R中的rep？）&lt;/li&gt;
&lt;li&gt;是否在字符串中 in （R中的grep？）&lt;/li&gt;
&lt;li&gt;长度 len&lt;/li&gt;
&lt;li&gt;单个索引和切片索引？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;字符串通过一种特殊的数据结构列表（list）存储。在下面学数据结构里理解。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;storename = &#39;python学习笔记&#39;
storename*3              # 复制
&#39;杨舒仪的&#39; + storename + &#39;-day1&#39;     # 拼接
&#39;python&#39; in storename  # 查找
storename[0:6]            # 前6个字，问题为什么0:6是前6个字？
len(storename)            # 字符长度
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&#39;python学习笔记python学习笔记python学习笔记&#39;






&#39;杨舒仪的python学习笔记-day1&#39;






True






&#39;python&#39;






10
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;数据类型转化&#34;&gt;数据类型转化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;float(): 转化为浮点数，类似as.numeric&lt;/li&gt;
&lt;li&gt;str: 转化为字符串，类似as.character&lt;/li&gt;
&lt;li&gt;int：转化为整数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;coupon数据中id被处理成了int，事实上应该是字符串，因此需要str()转化。但是出现&lt;strong&gt;一个错误&lt;/strong&gt;&#39;str&#39; object is not callable，str转化对象只能是单个id。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mstyle mathcolor=&#34;red&#34;&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;问&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;题&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\color{red}{问题：}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34; style=&#34;color:red;&#34;&gt;&lt;span class=&#34;mord cjk_fallback&#34; style=&#34;color:red;&#34;&gt;问&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34; style=&#34;color:red;&#34;&gt;题&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34; style=&#34;color:red;&#34;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; 一次转化多个id怎么写呢，写个循环吗？&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mstyle mathcolor=&#34;red&#34;&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;答&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;案&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;：&lt;/mi&gt;&lt;/mrow&gt;&lt;/mstyle&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;\color{red}{答案：}&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34; style=&#34;color:red;&#34;&gt;&lt;span class=&#34;mord cjk_fallback&#34; style=&#34;color:red;&#34;&gt;答&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34; style=&#34;color:red;&#34;&gt;案&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34; style=&#34;color:red;&#34;&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;写个循环似乎是可行的，“使用列表推导式把列表中的单个元素全部转化为str”&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ID = coupon.loc[0,&#39;团购活动ID&#39;]   # 第一家店铺id
type(ID)
type(str(ID))  # int转化为str
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;numpy.int64






str
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;————————————————————————————————————————&lt;/p&gt;
&lt;h1 id=&#34;数据结构&#34;&gt;数据结构&lt;/h1&gt;
&lt;p&gt;首先简单了解下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;列表&lt;/strong&gt;：有序的，[ &#39;abcd&#39;, 786 , 2.23, &#39;runoob&#39;, 70.2 ]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;字典&lt;/strong&gt;：无序的，键(key) : 值(value) 的集合 ，如{&#39;name&#39;: &#39;yy&#39;,&#39;date&#39;:9.15, &#39;topic&#39;: &#39;python&#39;}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集合： { } 或者 set() 函数创建集合，{&#39;r&#39;, &#39;b&#39;, &#39;d&#39;}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;元祖：与列表类似，但元素不能修改，(123, &#39;yyy&#39;)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dataframe数据框（pandas里面的数据结构）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;列表&#34;&gt;列表&lt;/h2&gt;
&lt;p&gt;需要了解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;列表生成，嵌套，删除&lt;/li&gt;
&lt;li&gt;基本操作：查看数据类型，合并列表，列表长度，查找/是否存在某个元素，切片，删除&lt;/li&gt;
&lt;li&gt;常用函数：append 插入&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;列表生成-嵌套-删除&#34;&gt;列表生成、嵌套、删除&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;### 列表生成
list0 = []  #空列表
list1 = [&#39;yyy&#39;,&#39;0915&#39;,&#39;上午&#39;]

# 列表嵌套
list2 = [list1,&#39;study&#39;,&#39;python&#39;]  # 把另一个列表当做一个元素
list2

# 列表删除
del list1[1]  # 删除某个元素
del list2[0]  # 注意！！！嵌套的结果在del时整体被删除！！！
del list2     # 删除一个列表
#list2       # 报错说明成功删除
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[[&#39;yyy&#39;, &#39;0915&#39;, &#39;上午&#39;], &#39;study&#39;, &#39;python&#39;]






[&#39;study&#39;, &#39;python&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;列表基本操作&#34;&gt;列表基本操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;查看数据类型：type()&lt;/li&gt;
&lt;li&gt;连接：直接用+&lt;/li&gt;
&lt;li&gt;查找：in &amp;amp; not in ，返回布尔值&lt;/li&gt;
&lt;li&gt;切片：list[a:b] &lt;strong&gt;第一个索引的元素包含在切片中，第二个不包含在切片内（可以理解为区间中的左闭右开）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 连接数组
list3 = list1 + [&#39;study&#39;,&#39;python&#39;] + [123,0.456] 
list3

# 数组 type len 查找结果
[type(list3), &#39;python&#39;in list3, 123 in list3, 1234 in list3]     

# 索引切片
list3[0]
list3[2:4]  # 第3和4个
list3[:4]    # 第1-4个
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;[&#39;yyy&#39;, &#39;上午&#39;, &#39;study&#39;, &#39;python&#39;, 123, 0.456]






[list, True, True, False]






&#39;yyy&#39;






[&#39;study&#39;, &#39;python&#39;]






[&#39;yyy&#39;, &#39;上午&#39;, &#39;study&#39;, &#39;python&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;列表函数&#34;&gt;列表函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;末尾添加新元素: list.append()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除：del list[n]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;移除：list.pop(index = n)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入：list.insert(插入位置，新元素）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;翻转：list.reverse()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;排序：list.sort()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统计某个元素出现次数 list.count()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到匹配的第一项的位置（因为list里面元素可重复）：list.index()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;迭代&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;长度：len()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最值：max()  min()&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# append() 添加元素
list3.append(&#39;yyy&#39;)  

# extend 增加多个元素，相当于+
list3.extend([123, &#39;python&#39;,&#39;yyy&#39;,&#39;最后的元素&#39;,&#39;最后的元素&#39;])

# del 删除最后一个元素
del list3[len(list3)-1]

# list.pop 删除最后一个元素
list3.pop(-1)

# insert 插入一个元素
list3.insert(2,&#39;yyy&#39;)

# 翻转
list3.reverse()

# 统计yyy出现次数
print(&#39;yyy出现&#39; + str(list3.count(&#39;yyy&#39;)) + &#39;次&#39;)

# 循环
for x in list3[0:3]: print(x)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&amp;lt;ipython-input-15-cb2007bec1fb&amp;gt; in &amp;lt;module&amp;gt;()
      1 # append() 添加元素
----&amp;gt; 2 list3.append(&#39;yyy&#39;)
      3 
      4 # extend 增加多个元素，相当于+
      5 list3.extend([123, &#39;python&#39;,&#39;yyy&#39;,&#39;最后的元素&#39;,&#39;最后的元素&#39;])


NameError: name &#39;list3&#39; is not defined
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 数值型list
list4 = [11,2,44,23,34,6,34,37,33,8]

# 找出最大值的位置
print(&#39;list4的最大值为&#39; + str(max(list4)) + &#39;，对应index是&#39;+str(list4.index(max(list4))))

# 大小排序
list4.sort()
list4
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;list4的最大值为44，对应index是2





[2, 6, 8, 11, 23, 33, 34, 34, 37, 44]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;元祖&#34;&gt;元祖&lt;/h2&gt;
&lt;p&gt;需要了解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建 ()&lt;/li&gt;
&lt;li&gt;截取、访问&lt;/li&gt;
&lt;li&gt;修改：**不可以修改！**但是可以截取（[]) 和拼贴（+）从而实现修改&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;tuple0 = ()     # 空元祖
tuple1 = tuple0 +(1, 2,3,4)   
(&#39;a&#39;,&#39;b&#39;) + tuple1[0:3]      # 截取和拼贴
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;(&#39;a&#39;, &#39;b&#39;, 1, 2, 3)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;字典&#34;&gt;字典&lt;/h2&gt;
&lt;p&gt;需要了解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建：使用键-值（key-value）存储，其中key与value用冒号对应&lt;/li&gt;
&lt;li&gt;访问：dict[键]&lt;/li&gt;
&lt;li&gt;增加、修改&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 创建一个字典
dict0 = {&#39;六婆串串香火锅&#39;:66, &#39;嗲串串&#39;:14}    

# 访问
dict0[&#39;六婆串串香火锅&#39;]  

# 增加
dict0[&#39;古城串串&#39;]  = 30
dict0

# 删除
del dict0[&#39;嗲串串&#39;]
dict0

# 返回
dict0.keys()     # 返回键
dict0.values()   # 返回值
dict0.items()    # 返回键+值
dict0.get(&#39;古城串串&#39;)  # 如何键值存在，则返回对应值
dict0.get(&#39;嗲串串&#39;)    # 如果键值不存在，不返回
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;66






{&#39;六婆串串香火锅&#39;: 66, &#39;嗲串串&#39;: 14, &#39;古城串串&#39;: 30}






{&#39;六婆串串香火锅&#39;: 66, &#39;古城串串&#39;: 30}






dict_keys([&#39;六婆串串香火锅&#39;, &#39;古城串串&#39;])






dict_values([66, 30])






dict_items([(&#39;六婆串串香火锅&#39;, 66), (&#39;古城串串&#39;, 30)])






30
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;集合&#34;&gt;集合&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;创建集合，
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;重复的不输出&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;set()，把list和tuple变成集合，但是顺序不再保持了&lt;/li&gt;
&lt;li&gt;set(字符串)，每个字母变成单个元素&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进行集合操作
&lt;ul&gt;
&lt;li&gt;集合运算 &amp;amp; |&lt;/li&gt;
&lt;li&gt;添加删除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 创建集合
set1 = {&#39;古城串串&#39;,&#39;嗲串串&#39;,&#39;六婆串串香火锅&#39;}
set([1,2,1,&#39;ss&#39;,3])  
# 有点像把list转化为set
# 重复的元素没有输出！！！
# 顺序也自动调整了！！


# 集合运算
set(&#39;python&#39;)-set(&#39;rstudio&#39;)  # 差集
set(&#39;python&#39;) | set(&#39;rstudio&#39;) # 并集
set(&#39;python&#39;) &amp;amp; set(&#39;rstudio&#39;) # 交集

# 集合元素增加删除
set1.remove(&#39;嗲串串&#39;)
set1.add(&#39;嗲串串串串&#39;)
set1
set1.clear()     # 直接清空
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;{1, 2, 3, &#39;ss&#39;}






{&#39;h&#39;, &#39;n&#39;, &#39;p&#39;, &#39;y&#39;}






{&#39;d&#39;, &#39;h&#39;, &#39;i&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;y&#39;}






{&#39;o&#39;, &#39;t&#39;}






{&#39;六婆串串香火锅&#39;, &#39;古城串串&#39;, &#39;嗲串串串串&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;时间序列数据&#34;&gt;时间序列数据&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;原本字符串 -&amp;gt; 标准时间——Pandas模块里的to_datetime函数&lt;/li&gt;
&lt;li&gt;输出形式%Y年%m月%d日——time模块里的time.strftime按照给定形式输出&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;em&gt;使用火锅数据做例子：&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 转换前是object?? 暂时不懂
#coupon[&#39;到期时间&#39;].dtypes

# to_datatime是用来转换为时间类型数据的函数
coupon[&#39;到期时间&#39;] = pd.to_datetime(coupon[&#39;到期时间&#39;]) 

# 转换后
coupon[&#39;到期时间&#39;].dtypes           # 转换后的数据类型
coupon[&#39;到期时间&#39;][{0,100,1000}]  # 转换后数据样子
[coupon[&#39;到期时间&#39;][0].year, coupon[&#39;到期时间&#39;][0].month, coupon[&#39;到期时间&#39;][0].day]  # 可以按照年月日分割提取

# 当前时间
import time        # 加载time模块！！
time.localtime()   # time模块的localtime提取当前时间

# 时间序列数据的输出形式
print(time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime())) # time.strftime按照给定形式输出
print(time.strftime(&#39;%Y年%m月%d日&#39;,time.localtime())) # time.strftime按照给定形式输出
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;dtype(&#39;&amp;lt;M8[ns]&#39;)






0      2018-08-10
1000   2018-09-04
100    2018-08-05
Name: 到期时间, dtype: datetime64[ns]






[2018, 8, 10]






time.struct_time(tm_year=2020, tm_mon=9, tm_mday=15, tm_hour=15, tm_min=2, tm_sec=38, tm_wday=1, tm_yday=259, tm_isdst=0)



2020-09-15 15:02:38
2020年09月15日
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;结构&#34;&gt;结构&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;顺序结构&lt;/li&gt;
&lt;li&gt;分支结构 if else&lt;/li&gt;
&lt;li&gt;循环结构 for while&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分支结构-if-else&#34;&gt;分支结构 if-else&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;num = int(input(&#39;本次火锅团购购买人数多了吗？：(如果有请填写个数)&#39;))
if num &amp;gt;150:
    print(&amp;quot;效果好棒!&amp;quot;)
elif 50&amp;lt;= num&amp;lt; 150:
    print(&amp;quot;活动内容微调&amp;quot;)
else:
    print(&#39;内容整改，再接再厉!&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;本次火锅团购购买人数多了吗？：(如果有请填写个数)22
内容整改，再接再厉!
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;遍历-for&#34;&gt;遍历 for&lt;/h2&gt;
&lt;p&gt;for &amp;lt;循环变量&amp;gt; in range(初始值，终止值，步长)：&lt;br&gt;
&amp;lt;语句块&amp;gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# list 遍历
for i in coupon[&#39;团购活动ID&#39;][0:3]: print(&amp;quot;团购ID:&amp;quot;+ str(i))

# range 遍历
for i in range(0, 100, 25): print(i)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;团购ID:38744470
团购ID:38632123
团购ID:38744514
0
25
50
75
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;遍历-列表生成式&#34;&gt;遍历 列表生成式&lt;/h2&gt;
&lt;p&gt;[表达式 for i in 序列]&lt;/p&gt;
&lt;p&gt;比如提取时间中的年份、月份、day:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于序列中某个元素的提取：coupon[&#39;到期时间&#39;][i].year&lt;/li&gt;
&lt;li&gt;表达式：i.year&lt;/li&gt;
&lt;li&gt;序列：coupon[&#39;到期时间&#39;]&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#把每个团购的到期时间转换成时间格式 
coupon[&#39;到期时间&#39;] = pd.to_datetime(coupon[&#39;到期时间&#39;]) 

# 序列某个元素提取年份
coupon[&#39;到期时间&#39;][10].year

# 遍历序列提取年份
year = [i.year for i in coupon[&#39;到期时间&#39;]]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;2018
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;循环-while&#34;&gt;循环 while&lt;/h2&gt;
&lt;p&gt;while 条件或表达式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     语句...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;else:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     语句...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 从1 加到10：
i = 1 ; x = 0       # 设定初始值
while i &amp;lt;= 10:    # 截止到10
    x += i           # 累加 x = x+i 的简化写法
    i += 1           # 累加 i = i+1 的简化写法
print(x)  
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;55
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;函数与模块&#34;&gt;函数与模块&lt;/h1&gt;
&lt;p&gt;函数&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;复杂定义函数之后再学&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本定义函数的规则：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;def  函数名（&amp;lt;参数列表&amp;gt;）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;        函数体
        
        return &amp;lt;返回值列表 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模块&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加载模块
&lt;ul&gt;
&lt;li&gt;import    模块名&lt;/li&gt;
&lt;li&gt;import    模块名 as 新名字&lt;/li&gt;
&lt;li&gt;from       模块名  import 函数名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;模块中函数的使用：&lt;strong&gt;模块名.函数名&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 求根号2的大小：从math模块中引入sqrt函数
import math
from math import sqrt
math.sqrt(2)   
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1.4142135623730951
&lt;/code&gt;&lt;/pre&gt;
">python基础</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/wo-hao-xiang-bu-ke-ai-liao/"" data-c="
          &lt;p&gt;以前有人问我喜欢什么类型，我会说喜欢温柔的，现在我会说可爱。&lt;/p&gt;
&lt;p&gt;可爱是最高级的形容词，也是我这样词汇匮乏的人常用的夸赞手法。如果想形容一个人很有亲和力，看起来很好相处，我总是会用可爱这个词汇。&lt;/p&gt;
&lt;p&gt;遇到一个能够很好相处的人应该就是极大的幸运了吧...可是我呢，好像不可爱了。一方面是近年来没人夸我可爱，另一方面烦恼增加，除了社交时那份半真半假的快乐可能是可爱的。一次简单的小组作业，我也会忍不住push大家，是不是会招人厌烦呢。这样的我，真的好像不可爱了。&lt;/p&gt;
">我好像不可爱了</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://yangggshuyi.github.io/post/know-myself-wizi/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://music.163.com/song?id=523461987&amp;amp;userid=495679022&#34;&gt;know myself——wizi 网易云&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总觉得自己很不争气 无能为力 不够卖力&lt;br&gt;
妈妈却说别太大压力 只要最后能对得起自己&lt;/p&gt;
&lt;p&gt;都想要找个寄托 来控制住自己的懦弱&lt;br&gt;
忙的太累闲的太废 计划都安排好最后变废纸&lt;/p&gt;
&lt;p&gt;不需要着急 一切都有条不紊的进行着顺其自然&lt;br&gt;
慢慢变独立 别总是不停的制造障碍让自己为难&lt;br&gt;
琐碎万千大脑容量退减 调整好心态烦恼消失不见&lt;br&gt;
生活像天 瞬息万变 就把握好当下的每个瞬间&lt;/p&gt;
">know myself——wizi</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>


<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>





</html>